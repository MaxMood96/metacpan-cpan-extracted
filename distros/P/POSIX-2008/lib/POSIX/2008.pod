=pod

=head1 NAME

POSIX::2008 - Perl interface to POSIX.1-2008

=head1 SYNOPSIS

  use POSIX::2008 qw(:fcntl openat pwrite);

  sysopen my $dh, '/tmp', O_RDONLY|O_DIRECTORY|O_NOFOLLOW
    or die 'Dafuq?';
  my $fh = openat($dh, 'foobar', O_RDWR|O_CREAT);
  pwrite($fh, 'fuckyounsa', 10, 0);

=head1 DESCRIPTION

POSIX::2008 contains many of the interfaces specified by
L<POSIX.1-2008|https://pubs.opengroup.org/onlinepubs/9699919799/> that the
core POSIX module withholds, implements in Perl or fucked up.

It also contains a few nonstandard interfaces present in Linux, BSD and Solaris
that are extensions of the POSIX interfaces.

This module is provided "as is" unless someone volunteers to maintain it.
Use at your own risk.

=head1 FILE DESCRIPTORS AND HANDLES

Since version 0.05, all I/O functions that take numeric file descriptors also
accept Perl file or directory handles, except for L<C<fdopen()>|"fdopen"> and
L<C<fdopendir()>|"fdopendir">.

Since version 0.22, returned handles support IO::Handle methods.

=head1 SYSTEM CALL RETURN VALUES

A system call return value of -1 meaning "error" is mapped to undef except for
L<C<poll()>|"poll"> which returns -1 to be consistent with
L<C<select()>|perlfunc/select>.

A system call return value of 0 meaning "success" is mapped to "0 but true".

For system calls where 0 does not just mean "success", 0 is returned
unchanged. These are L<C<creat()>|"creat">, L<C<open()>|"open">,
L<C<read()>|"read">, L<C<write()>|"write">, L<C<readv()>|"readv">,
L<C<writev()>|"writev">, L<C<pread()>|"pread">, L<C<pwrite()>|"pwrite">,
L<C<preadv()>|"preadv">, L<C<pwritev()>|"pwritev">, L<C<preadv2()>|"preadv2">,
L<C<pwritev2()>|"pwritev2">, L<C<getpriority()>|"getpriority">,
L<C<nice()>|"nice">. L<C<openat()>|"openat"> gets a special treatment in this
regard, see below.

=head1 FUNCTIONS

=over 4

=item C<a64l>

l = a64l(s);

=item C<abort>

abort();

=item C<abs>

ui = abs(i);

Calls C<llabs()>, C<labs()>, or C<abs()>, whichever is the maximum supported
by your system.

Note that the library functions use signed integers, so C<abs(~0)> is 1.
If you don't want that, use C<CORE::abs()>.

=item C<access>

ret = access(path, mode);

I<New in version 0.08.>

=item C<acos>

y = acos(x);

=item C<acosh>

y = acosh(x);

=item C<alarm>

remaining_sec = alarm(sec);

=item C<asin>

y = asin(x);

=item C<asinh>

y = asinh(x);

=item C<atan2>

z = atan2(y, x);

=item C<atan>

y = atan(x);

=item C<atanh>

y = atanh(x);

=item C<atof>

f = atof(s);

=item C<atoi>

i = atoi(s);

Calls C<atoll()>, C<atol()>, or C<atoi()>, whichever is the maximum supported
by your system. This is of course silly because you could just use C<int()>.

I<Changed in version 0.19:> Deprecated I<atol> and I<atoll> now covered by
I<atoi>.

=item C<basename>

s = basename(path);

=item C<cabs>

r = cabs(re, im);

=item C<cacos>

(re, im) = cacos(re, im);

=item C<cacosh>

(re, im) = cacosh(re, im);

=item C<carg>

phi = carg(re, im);

=item C<casin>

y = casin(x);

=item C<casinh>

(re, im) = casinh(re, im);

=item C<catan>

(re, im) = catan(re, im);

=item C<catanh>

(re, im) = catanh(re, im);

=item C<catclose>

ret = catclose(catd);

=item C<catgets>

s = catgets(catd, set_id, msg_id, dflt_string);

=item C<catopen>

catd = catopen(name, flag);

=item C<cbrt>

y = cbrt(x);

=item C<ccos>

(re, im) = ccos(re, im);

=item C<ccosh>

(re, im) = ccosh(re, im);

=item C<ceil>

y = ceil(x);

=item C<cexp>

(re, im) = cexp(re, im);

I<New in version 0.19.>

=item C<chdir>

ret = chdir(dir);

C<dir> can be a path, a Perl file or directory handle, or a file descriptor.

I<Changed in version 0.19:> Deprecated I<fchdir> now covered by I<chdir>.

=item C<chmod>

ret = chmod(what, mode);

C<what> can be a path, a Perl file or directory handle (see L</"NOTES">), or a
file descriptor.

I<Changed in version 0.19:> Deprecated I<fchmod> now covered by I<chmod>.

=item C<chown>

ret = chown(what, uid, gid);

C<what> can be a path, a Perl file or directory handle (see L</"NOTES">), or a
file descriptor.

I<Changed in version 0.19:> Deprecated I<fchown> now covered by I<chown>.

=item C<cimag>

im = cimag(re, im);

=item C<clock>

t = clock()

I<New in version 0.08.>

=item C<clock_getcpuclockid>

clock_id = clock_getcpuclockid(pid);

I<pid> defaults to 0. Returns undef on error.

=item C<clock_getres>

(sec, nsec) = clock_getres(clock_id);
floating_sec = clock_getres(clock_id);

I<clock_id> defaults to C<CLOCK_REALTIME>. Returns empty list or undef on
error.

I<Changed in version 0.25:> Return floating seconds in scalar context.

=item C<clock_gettime>

(sec, nsec) = clock_gettime(clock_id);
floating_sec = clock_gettime(clock_id);

clock_id defaults to C<CLOCK_REALTIME>. Returns empty list or undef on error.

I<Changed in version 0.25:> Return floating seconds in scalar context.

=item C<clock_nanosleep>

(rem_sec, rem_nsec) = clock_nanosleep(clock_id, flags, floating_sec);
floating_rem_sec = clock_nanosleep(clock_id, flags, floating_sec);

(rem_sec, rem_nsec) = clock_nanosleep(clock_id, flags, sec, nsec);
floating_rem_sec = clock_nanosleep(clock_id, flags, sec, nsec);

Returns zero(es) on success, the remaining time on EINTR, the empty list or
undef otherwise. The remaining time is zero if the flag C<TIMER_ABSTIME> is
set.

I<Changed in version 0.25:> Sleep time can be floating seconds only or seconds
and nanoseconds.

=item C<clock_settime>

ret = clock_settime(clock_id, sec, nsec);
ret = clock_settime(clock_id, floating_sec);

I<Changed in version 0.25:> Time can be floating seconds only or seconds and
nanoseconds.

=item C<clog>

(re, im) = clog(re, im);

=item C<close>

ret = close(fd);

=item C<confstr>

s = confstr(name);

I<name> is one of the C<_CS_*> integer constants.

Returns undef on error.

=item C<conj>

(re, im) = conj(re, im);

=item C<copysign>

xs = copysign(x, y);

=item C<cos>

y = cos(x);

=item C<cosh>

y = cosh(x);

=item C<cpow>

(re, im) = cpow(re_x, im_x, re_y, im_y);

=item C<cproj>

(re, im) = cproj(re, im);

=item C<creal>

re = creal(re, im);

=item C<creat>

ret = creat(path, mode=0666);

I<New in version 0.22.>

=item C<csin>

(re, im) = csin(re, im);

=item C<csinh>

(re, im) = csinh(re, im);

=item C<csqrt>

(re, im) = csqrt(re, im);

=item C<ctan>

(re, im) = ctan(re, im);

=item C<ctanh>

(re, im) = ctanh(re, im);

=item C<dirname>

name = dirname(path);

=item C<div>

(quot, rem) = div(numer, denom);

Calls C<lldiv()>, C<ldiv()>, or C<div()>, whichever is the maximum supported
by your system.

Note that the library functions use signed integers, so C<div(~0, 1)> is
C<(-1, 0)>. If you don't want that, use Perls C<int()>, C</> and C<%>.

I<Changed in version 0.19:> Deprecated I<ldiv> and I<lldiv> now covered by
I<div>.

=item C<dlclose>

dlclose(dlhandle);

=item C<dlerror>

dlerror();

=item C<dlopen>

dlhandle = dlopen(file, mode);

=item C<dlsym>

addr = dlsym(dlhandle, name);

=item C<drand48>

r = drand48();

=item C<endutxent>

endutxent();

=item C<erand48>

(r, X0, X1, X2) = erand48(X0, X1, X2);

=item C<erf>

y = erf(x);

=item C<erfc>

y = erfc(x);

=item C<execveat>

execveat(dirfd, path, args, env=undef, flags=0);

The C<execveat()> system call is a nonstandard extension present in Linux.
See also L<C<fexecve()>|"fexecve">.

It executes the program referred to by I<path>, which is interpreted relative
to I<dirfd> as with the other I<*at> functions, passing I<args> as its
command-line arguments and optionally I<env> as its environment.

I<args> must be an array reference and, by convention, I<args-E<gt>[0]> should
be the name of the program being executed.

I<env> must be a hash reference. If omitted or undef, the environment of the
calling proces is used (which you can manipulate via C<%ENV>).

I<flags> is a bit mask that can include zero or more of the flags
C<AT_EMPTY_PATH>, C<AT_SYMLINK_NOFOLLOW>.

I<path> is executed "as is", i.e. no C<PATH> search or interpretation of shell
metacharacters takes place as opposed to Perl's built-in
L<C<exec>|perlfunc/exec>.

Returns undef on error, otherwise it doesn't return.

Usage example:

  sysopen my $dh, '/usr', O_DIRECTORY|O_PATH;
  execveat($dh, 'bin/date', [qw(date +%T)], {TZ => 'UTC'}, AT_SYMLINK_NOFOLLOW);

I<New in version 0.22.>

=item C<exp>

y = exp(x);

=item C<exp2>

y = exp2(x);

=item C<expm1>

y = expm1(x);

=item C<faccessat>

ret = faccessat(dirfd, path, amode, flags=0);

I<flags> is the bitwise OR of zero or more of C<AT_EACCESS>,
C<AT_SYMLINK_NOFOLLOW>.

=item C<fchmodat>

ret = fchmodat(dirfd, path, mode, flags=0);

I<flags> can be 0 or C<AT_SYMLINK_NOFOLLOW>. Your system might support a
different set of flags.

=item C<fchownat>

ret = fchownat(dirfd, path, uid, gid, flags=0);

I<flags> can be 0 or C<AT_SYMLINK_NOFOLLOW>. Your system might support a
different set of flags.

=item C<fdatasync>

ret = fdatasync(fd);

=item C<fdopen>

ret = fdopen(fd, mode);

Returns a file handle associated with the numeric file descriptor I<fd> or
undef on error. I<mode> is one of the values C<"r">, C<"w">, C<"a"> with an
optional C<"+"> and/or C<"b">.

The file descriptor is not dup'ed and will be closed when the handle is closed.

It's similar to C<IO::Handle::new_from_fd()> with the following improvements:

=over

=item *
It I<really> calls C<fdopen(3)>.

=item *
It expects POSIX mode strings (e.g. C<"r">, not C<"<">).

=item *
It fails if I<mode> is not compatible with the flags of I<fd>.

=back

Usage example:

  my $fh = do {
    opendir my $dh, '.';
    fdopen(POSIX::dup(fileno $dh), 'r');
  };
  chmod 0700, $fh;  # this would fail with $dh from opendir

I<New in version 0.05.>

I<Changed in version 0.22:> I<fd> can no longer be a handle (that was a wrong
turn).

=item C<fdopendir>

ret = fdopendir(fd);

Returns a directory handle associated with the numeric file descriptor I<fd>
or undef on error.

The file descriptor is not dup'ed and will be closed when the handle is closed.

Usage example:

  my $dh = do {
    sysopen my $fh, '/tmp', O_RDONLY|O_DIRECTORY|O_NOFOLLOW;
    fdopendir(POSIX::dup(fileno $fh));
  };
  my @dents = readdir $dh;  # this would fail with $fh from sysopen

I<New in version 0.05.>

I<Changed in version 0.22:> I<fd> can no longer be a handle (that was a wrong
turn).

=item C<fdim>

d = fdim(double x, double y);

=item C<feclearexcept>

ret = feclearexcept(excepts);

Returns C<0 but true> on success, undef on error.

I<New in version 0.20.>

=item C<fegetround>

rounding_mode = fegetround();

=item C<feraiseexcept>

ret = feraiseexcept(excepts);

Returns C<0 but true> on success, undef on error.

I<New in version 0.20.>

=item C<fesetround>

ret = fesetround(round);

Returns C<0 but true> on success, undef on error.

=item C<fetestexcept>

excepts_currently_set = fetestexcept(excepts);

I<New in version 0.20.>

=item C<fexecve>

fexecve(fd, args, env=undef);

Executes the program referred to by the file descriptor I<fd>, passing I<args>
as its command-line arguments and optionally I<env> as its environment.

I<args> must be an array reference and, by convention, I<args-E<gt>[0]> should
be the name of the program being executed.

I<env> must be a hash reference. If omitted or undef, the environment of the
calling proces is used (which you can manipulate via C<%ENV>).

See the manpage for issues regarding the close-on-exec flag and the /proc
filesystem.

Returns undef on error, otherwise it doesn't return.

Usage example:

  sysopen my $fh, '/usr/bin/date', O_PATH;
  fexecve($fh, [qw(date +%T)], {TZ => 'UTC'});

See also L<C<execveat()>|"execveat">.

I<New in version 0.22.>

=item C<ffs>

pos = ffs(i);

Calls C<ffsll()>, C<ffsl()>, or C<ffs()>, whichever is the maximum available
on your system.

=item C<floor>

y = floor(x);

=item C<fma>

r = fma(x, y, z);

=item C<fmax>

m = fmax(x, y);

=item C<fmin>

m = fmin(x, y);

=item C<fmod>

m = fmod(x, y);

=item C<fnmatch>

ret = fnmatch(pattern, string, flags);

Returns 0 if I<string> matches I<pattern>, C<FNM_NOMATCH> if there is no
match, undef if there is an error.

I<flags> is the bitwise OR of zero or more of C<FNM_NOESCAPE>,
C<FNM_PATHNAME>, C<FNM_PERIOD>, C<FNM_FILE_NAME>, C<FNM_LEADING_DIR>,
C<FNM_CASEFOLD>.

=item C<fpclassify>

fpclassify(x);

Returns one of C<FP_NAN>, C<FP_INFINITE>, C<FP_ZERO>, C<FP_SUBNORMAL>,
C<FP_NORMAL>.

=item C<fstatat>

(dev, ino, mode, nlink, uid, gid, rdev, size, atim_sec, mtim_sec, ctim_sec,
blksize, blocks, atim_nsec, mtim_nsec, ctim_nsec) = fstatat(dirfd, path,
flags = 0);

I<flags> is the bitwise OR of zero or more of C<AT_SYMLINK_NOFOLLOW>,
C<AT_NO_AUTOMOUNT>. Your system might support a different set of flags.

See L<C<stat()>|"stat"> for notes on the return values and bugs in
C<CORE::stat()>.

Returns the empty list on error.

=item C<fsync>

ret = fsync(fd);

=item C<futimens>

ret = futimens(fd, atime_sec, atime_nsec, mtime_sec, mtime_nsec);

I<atime_sec> and I<mtime_sec> default to 0, I<atime_nsec> and I<mtime_nsec>
default to C<UTIME_NOW>.

=item C<getdate>

(sec, min, hour, mday, mon, year, wday, yday, isdst) = getdate(string);

=item C<getdate_err>

getdate_err() returns the value of the getdate_err variable.

=item C<getegid>

egid = getegid();

=item C<geteuid>

euid = geteuid();

=item C<getgid>

gid = getgid();

=item C<gethostid>

hostid = gethostid();

=item C<gethostname>

hostname = gethostname();

=item C<getitimer>

(int_sec, int_usec, val_sec, val_usec) = getitimer(which);

I<which> can be one of C<ITIMER_REAL>, C<ITIMER_VIRTUAL>, C<ITIMER_PROF>.

POSIX.1-2008 marks C<getitimer()> and C<setitimer()> obsolete, recommending
the use of the POSIX timers API (L<C<timer_gettime()>|"timer_gettime">,
L<C<timer_settime()>|"timer_settime">, etc.)  instead.

POSIX.1-2024 removed C<getitimer()> and C<setitimer()>.

=item C<getpriority>

prio = getpriority(which=PRIO_PROCESS, who=0);

I<which> can be one of C<PRIO_PROCESS>, C<PRIO_PGRP>, C<PRIO_USER>, defaults
to C<PRIO_PROCESS>. I<who> defaults to 0.

Returns undef on error.

=item C<getsid>

sid = getsid(pid);

I<pid> defaults to 0.

=item C<getuid>

uid = getuid();

=item C<getutxent>

(user, id, line, pid, type, sec, usec) = getutxent();

C<getutxent()> reads a line from the current file position in the utmp file.

=item C<getutxid>

(user, id, line, pid, type, sec, usec) = getutxid(ut_type, ut_id);

C<getutxid()> searches forward from the current file position in the utmp file
based upon I<ut_type> and I<ut_id>. If I<ut_type> is one of C<RUN_LVL>,
C<BOOT_TIME>, C<NEW_TIME>, or C<OLD_TIME>, C<getutxid()> will find the first
entry whose I<ut_type> field matches I<ut_type>. If I<ut_type> is one of
C<INIT_PROCESS>, C<LOGIN_PROCESS>, C<USER_PROCESS>, or C<DEAD_PROCESS>,
C<getutxid()> will find the first entry whose I<ut_id> field matches I<ut_id>.

=item C<getutxline>

(user, id, line, pid, type, sec, usec) = getutxline(ut_line);

C<getutxline()> searches forward from the current file position in the utmp
file. It scans entries whose I<ut_type> is C<USER_PROCESS> or C<LOGIN_PROCESS>
and returns the first one whose I<ut_line> field matches I<ut_line>.

=item C<hypot>

r = hypot(x, y);

=item C<ilogb>

y = ilogb(x);

=item C<isalnum>

ret = isalnum(charstring);

Like POSIX::isalnum() but returns 0 for the empty string.

=item C<isalpha>

ret = isalpha(charstring);

Like POSIX::isalpha() but returns 0 for the empty string.

=item C<isascii>

ret = isascii(charstring);

POSIX.1-2008 marks it as obsolete and it was removed in POSIX.1-2024, but I
include it anyway.

I<New in version 0.19.>

=item C<isatty>

ret = isatty(fd);

=item C<isblank>

ret = isblank(charstring);

Like POSIX::isblank() but returns 0 for the empty string.

=item C<iscntrl>

ret = iscntrl(charstring);

Like POSIX::iscntrl() but returns 0 for the empty string.

=item C<isdigit>

ret = isdigit(charstring);

Like POSIX::isdigit() but returns 0 for the empty string.

=item C<isfinite>

ret = isfinite(x);

=item C<isgraph>

ret = isgraph(charstring);

Like POSIX::isgraph() but returns 0 for the empty string.

=item C<isgreaterequal>

ret = isgreaterequal(x, y);

I<New in version 0.20.>

=item C<isinf>

ret = isinf(x);

=item C<isless>

ret = isless(x, y);

I<New in version 0.20.>

=item C<islessequal>

ret = islessequal(x, y);

I<New in version 0.20.>

=item C<islessgreater>

ret = islessgreater(x, y);

I<New in version 0.20.>

=item C<islower>

ret = islower(charstring);

Like POSIX::islower() but returns 0 for the empty string.

=item C<isnan>

ret = isnan(x);

=item C<isnormal>

ret = isnormal(x);

=item C<isprint>

ret = isprint(charstring);

Like POSIX::isprint() but returns 0 for the empty string.

=item C<ispunct>

ret = ispunct(charstring);

Like POSIX::ispunct() but returns 0 for the empty string.

=item C<isspace>

ret = isspace(charstring);

Like POSIX::isspace() but returns 0 for the empty string.

=item C<isunordered>

ret = isunordered(x, y);

I<New in version 0.20.>

=item C<isupper>

ret = isupper(charstring);

Like POSIX::isupper() but returns 0 for the empty string.

=item C<isxdigit>

ret = isxdigit(charstring);

Like POSIX::isxdigit() but returns 0 for the empty string.

=item C<j0>

y = j0(x);

C<j0()> is the Bessel function of the first kind of order 0.

=item C<j1>

y = j1(x);

C<j1()> is the Bessel function of the first kind of order 1.

=item C<jn>

y = jn(n, x);

C<jn()> is the Bessel function of the first kind of order I<n>.

=item C<jrand48>

(r, X0, X1, X2) = jrand48(X0, X1, X2);

=item C<killpg>

ret = killpg(pgrp, sig);

=item C<l64a>

s = l64a(n);

=item C<lchown>

ret = lchown(path, uid, gid);

I<New in version 0.08.>

=item C<ldexp>

y = ldexp(x, exp);

=item C<lgamma>

y = lgamma(x);

=item C<link>

ret = link(path1, path2);

=item C<linkat>

ret = linkat(fd1, path1, fd2, path2, flags=0);

I<flags> can be 0 or C<AT_SYMLINK_FOLLOW>. Your system might support a
different set of flags.

=item C<log>

y = log(x);

=item C<log10>

y = log10(x);

=item C<log1p>

y = log1p(x);

=item C<log2>

y = log2(x);

=item C<logb>

y = logb(x);

=item C<lrand48>

r = lrand48();

=item C<lround>

l = lround(x);

Calls C<llround()> or C<lround()> whichever is the maximum available on your
system. If the rounded value is outside Perl's internal signed integer range,
it is returned as a string. If the rounded value is too large to be stored in
a long long or long, undef is returned.

=item C<lstat>

(dev, ino, mode, nlink, uid, gid, rdev, size, atim_sec, mtim_sec, ctim_sec,
blksize, blocks, atim_nsec, mtim_nsec, ctim_nsec) = lstat(path);

C<path> is assumed to be a string (or will be converted to a string).

See L<C<stat()>|"stat"> for notes on the return values and bugs in
C<CORE::stat()>.

Returns the empty list on error.

=item C<mkdir>

ret = mkdir(path, [mode = 0777]);

=item C<mkdirat>

ret = mkdirat(fd, path, mode);

=item C<mkdtemp>

name = mkdtemp(template);

=item C<mkfifo>

ret = mkfifo(path, mode);

=item C<mkfifoat>

ret = mkfifoat(fd, path, mode);

=item C<mknod>

ret = mknod(path, mode, dev);

=item C<mknodat>

ret = mknodat(fd, path, mode, dev);

=item C<mkstemp>

(fd, name) = mkstemp(template);

=item C<mrand48>

mrand48();

=item C<nanosleep>

(rem_sec, rem_nsec) = nanosleep(floating_sec);
floating_rem_sec = nanosleep(floating_sec);

(rem_sec, rem_nsec) = nanosleep(sec, nsec);
floating_rem_sec = nanosleep(sec, nsec);

Returns zero(es) on success, the remaining time on EINTR, the empty list or
undef otherwise.

I<Changed in version 0.25:> Sleep time can be floating seconds only or seconds
and nanoseconds.

=item C<nearbyint>

y = nearbyint(x);

=item C<nextafter>

z = nextafter(x, y);

=item C<nexttoward>

z = nexttoward(x, y);

=item C<nice>

ret = nice(incr);

Returns undef on error.

=item C<nrand48>

r = nrand48()

=item C<open>

ret = open(path, flags=O_RDONLY, mode=0666);

=item C<openat>

ret = openat(dirfd, path, flags=O_RDONLY, mode=0666);

If I<dirfd> is numeric (i.e. a file descriptor), C<openat()> returns a file
descriptor. If I<dirfd> is a file or directory handle, the return value is
also a handle whose type depends on the file type of I<path>: If I<path> is a
directory, the return value is a directory handle, otherwise it's a file
handle.

To get a handle even for the special numeric I<dirfd> value C<AT_FDCWD>, you
can pass a reference to that value instead, i.e. C<openat(\AT_FDCWD, ...)>.

Returns undef on error.

I<Changed in version 0.18:> Support added for C<\AT_FDCWD> reference.

=item C<openat2>

ret = openat2(dirfd, path, how);

The C<openat2()> system call is a Linux-specific extension of
L<C<openat()>|"openat"> and provides a superset of its functionality.

The I<how> parameter is a hash reference corresponding to the I<struct
open_how>. It currently supports the keys I<flags>, I<mode> and
I<resolve>. Missing keys are treated as having a zero value.

Example:

  my $fh = openat2(
    \AT_FDCWD, '/foobar',
    {flags => O_RDWR|O_CREAT, mode => 0600, resolve => RESOLVE_IN_ROOT}
  );

Note that, unlike L<C<open()>|"open"> or L<C<openat()>|"openat">, C<openat2()>
is very picky about I<flags> and I<mode>. See the manpage for details.

Returns undef on error.

I<New in version 0.18.>

=item C<pathconf>

ret = pathconf(what, name);

I<what> can be a path or, if your system supports C<fpathconf()>, a Perl file
or directory handle or a file descriptor.

I<name> is one of the C<_PC_*> integer constants.

Returns undef on error.

I<New in version 0.22.>

=item C<poll>

ret = poll(pollfds, timeout=-1);

I<timeout> specifies the number of milliseconds that C<poll()> should block
waiting for a file descriptor to become ready. A negative I<timeout> value
means an infinite timeout. A I<timeout> of zero causes C<poll()> to return
immediately.

I<pollfds> is an array reference holding array references of the form I<[fd,
events, revents]> where I<fd> is an integer file descriptor or a file handle,
I<events> is a bit mask of events you are interested in for I<fd>, and
I<revents> is a bit mask of events that actually occurred.

I<revents> is changed by the call (unless a timeout or error occurs),
everything else remains unchanged.

If I<fd> is negative or anything sv_2io() doesn't consider a file handle then
the corresponding events field is ignored and the revents field returns zero.

Returns the number of elements in I<pollfds> whose I<revents> have been set to
a non-zero value, zero if the call timed out, -1 on error.

Usage example:

  open my $pipe, '-|', qw(tail -f /var/log/messages);
  my $pollfds = [[\*STDIN, POLLIN, 0], [2, POLLOUT, 0], [$pipe, POLLIN, 0]];
  my $rv = poll($pollfds, -1);

  # Skip events for fd 2 this time:
  my $pollfds = [[\*STDIN, POLLIN, 0], [-2, POLLOUT, 0], [$pipe, POLLIN, 0]];
  my $rv = poll($pollfds, -1);

I<New in version 0.25.>

=item C<posix_fadvise>

ret = posix_fadvise(fd, offset, len, advice);

I<advice> is one of the C<POSIX_FADV_> constants.

I<New in version 0.14.>

=item C<posix_fallocate>

ret = posix_fallocate(fd, offset, len);

I<New in version 0.14.>

=item C<pread>

bytes_read = pread(fd, buf, count, offset=0, buf_offset=0);

C<pread()> reads I<count> bytes (not characters) of data from the file
descriptor I<fd> at file offset I<offset> into the scalar I<buf> without
changing the file offset. I<buf> will be enlarged automatically if necessary.

I<offset> and I<buf_offset> are set to 0 if omitted or undef.

C<pread()> treats I<buf> just like C<sysread()> does: I<buf_offset> may be
specified to place the read data at that position in I<buf>. If I<buf_offset>
is past the end of I<buf>, I<buf> will be padded with zeros before appending
the data. If I<buf_offset> is negative, it is counted from the end of the
string. I<buf> will be grown or shrunk so that the last byte actually read is
the last byte of I<buf> after the read.

Returns the number of bytes read, 0 at EOF, undef on error.

Croaks if I<buf> is read-only and I<count> is non-zero.

I<Changed in version 0.13:> Argument order is now (count, offset) instead of
(offset, count).

I<Changed in version 0.22:> Croak with read-only I<buf> and non-zero I<count>.

=item C<preadv>

bytes_read = preadv(fd, buffers, sizes, offset=0);

C<preadv()> behaves like L<C<readv()>|"readv"> but adds an optional I<offset>
argument, which specifies the file position at which the data is to be
read. I<offset> is set to 0 if omitted or undef.

The file offset is not changed by this system call. The file referred to by
I<fd> must be capable of seeking.

This syscall is present in Linux and BSD.

I<New in version 0.13.>

=item C<preadv2>

bytes_read = preadv2(fd, buffers, sizes, offset=0, flags=0);

C<preadv2()> is similar to L<C<preadv()>|"preadv"> but adds an optional I<flags>
argument, which is a bitwise OR of zero or more of the C<RWF_*> flags (see the
manpage for details). I<flags> is set to 0 if omitted or undef.

This syscall is Linux-specific.

I<New in version 0.20.>

=item C<psignal>

psignal(sig, msg);

I<New in version 0.25.>

=item C<ptsname>

name = ptsname(fd);

I<Changed in version 0.19:> Calls C<ptsname_r()> if available.

I<Changed in version 0.22:> I<fd> may also be a file handle.

=item C<pwrite>

bytes_written = pwrite(fd, buf, count=undef, offset=0, buf_offset=0);

C<pwrite()> writes I<count> bytes of data from the scalar I<buf> to the file
descriptor I<fd> at file offset I<offset> without changing the file
offset. The file referenced by I<fd> must be capable of seeking.

If I<count> is omitted or undef, everything from I<buf_offset> up to the end
of I<buf> is written.

I<buf_offset> may be specified to write data from that position in
I<buf>. If I<buf_offset> is negative it is counted from the end
of the string.

I<offset> and I<buf_offset> are set to 0 if omitted or undef.

Returns the number of bytes written, undef on error.

On Linux, if a file is opened with C<O_APPEND>, C<pwrite()> appends data to
the end of the file, regardless of the value of I<offset> (in violation of
POSIX).

I<Changed in version 0.13:> Argument order is now (count, offset) instead of
(offset, count).

=item C<pwritev>

bytes_written = pwritev(fd, buffers, offset=0);

C<pwritev()> behaves like L<C<writev()>|"writev"> but adds an optional
I<offset> argument, which specifies the file position at which the data is to
be written. I<offset> is set to 0 if omitted or undef.

The file offset is not changed by this system call. The file referred to by
I<fd> must be capable of seeking.

On Linux, if a file is opened with C<O_APPEND>, C<pwritev()> appends data to
the end of the file, regardless of the value of I<offset> (in violation of
POSIX).

This syscall is present in Linux and BSD.

I<New in version 0.08.>

=item C<pwritev2>

bytes_written = pwritev2(fd, buffers, offset=0, flags=0);

C<pwritev2()> is similar to L<C<pwritev()>|"pwritev"> but adds an optional
I<flags> argument, which is a bitwise OR of zero or more of the C<RWF_*>
flags (see the manpage for details). I<flags> is set to 0 if omitted or undef.

This syscall is Linux-specific.

I<New in version 0.20.>

=item C<random>

r = random();

=item C<raise>

ret = raise(sig);

=item C<read>

bytes_read = read(fd, buf, count);

Like C<POSIX::read()> but returns 0 at EOF instead of C<0 but true>. Croaks if
I<buf> is read-only and I<count> is non-zero.

I<Changed in version 0.22:> Croak with read-only I<buf> and non-zero I<count>.

=item C<readv>

bytes_read = readv(fd, buffers, sizes);

C<readv()> reads from the file descriptor I<fd> into I<buffers> as many
strings as there are elements in I<sizes>.

I<buffers> must be a I<variable> holding an array (C<@buf>), an array reference
or undef (C<$buf>). If it is undef it will be upgraded to an array reference.

I<sizes> must be an array reference, i.e. C<\@sizes>, C<$sizes>, or C<[...]>.

I<sizes> is expected to hold unsigned integers that specify how many bytes are
to be read into each buffer. A byte count of 0 or undef creates an empty
string. I<sizes> is processed in array order.

I<buffers> will be extended if necessary, but it will never be shrunk. If
I<buffers> is not empty, any existing elements are replaced as long as
sufficient data was read from I<fd>.

C<readv()> returns the number of bytes read, undef on error.

Note that it is not an error for a successful call to transfer fewer bytes
than requested. In this case there may be one "partially" filled buffer, i.e.
it contains fewer bytes than the corresponding size. Surplus size entries lead
to corresponding empty buffers.

Usage example:

  my $fh = openat(\AT_FDCWD, '/tmp/foobar', O_RDWR|O_CREAT|O_TRUNC);
  pwrite($fh, 'foobar', 6, 0);
  readv($fh, my $buf1, [3, 0, 8]); # $buf1: ['foo', '', 'bar']
  sysseek $fh, 0, 0;
  readv($fh, my @buf2, [1, 3, 2]); # @buf2: ('f', 'oob', 'ar')

I<New in version 0.13.>

I<Changed in version 0.22:> I<buffers> may be an undef variable, buffers
beyond EOF are created as empty strings instead of being skipped.

=item C<readlink>

name = readlink(path);

Returns undef on error.

=item C<readlinkat>

name = readlinkat(dirfd, path);

Returns undef on error.

=item C<realpath>

resolved_path = realpath(path);

Calls the actual C library fuction C<realpath()> and relies on it to be able
to allocate memory for the resolved path automatically (as required by
POSIX-2008).

Returns undef on error.

I<New in version 0.18.>

=item C<remainder>

rem = remainder(x, y);

Returns  undef on error.

=item C<remove>

ret = remove(path);

Calls the actual C library function C<remove()>.

Note that core C<POSIX::remove()> fails if I<path> is a symlink to a directory
because someone "couldn't read the plans right and did a piss-poor job of
putting it together" as C<(-d $_[0]) ? CORE::rmdir($_[0]) :
CORE::unlink($_[0])>. Quote from Armageddon.

This could be fixed like this: C<unlink $_[0] or ($!{EISDIR} or $!{EPERM}) and
rmdir $_[0]> (correct errno check depends on OS), or by using the library call
right away.

=item C<removeat>

ret = removeat(dirfd, path);

The C<removeat()> function works exactly like L<C<remove()>|"remove"> but
I<path> is interpreted relative to I<dirfd> as with the other I<*at>
functions.

This function is a home-grown non-standard extension only available in this
module (to my knowledge).

I<New in version 0.22.>

=item C<remquo>

(rem, quo) = remquo(x, y);

Returns the empty list on error.

I<New in version 0.20.>

=item C<rename>

ret = rename(old, new);

=item C<renameat>

ret = renameat(olddirfd, oldpath, newdirfd, newpath);

=item C<renameat2>

ret = renameat(olddirfd, oldpath, newdirfd, newpath, flags=0);

The C<renameat2()> system call is a Linux-specific extension of
L<C<renameat()>|"renameat"> and provides a superset of its functionality.

I<flags> is the bitwise OR of zero or more of C<RENAME_EXCHANGE>,
C<RENAME_NOREPLACE>, C<RENAME_WHITEOUT>.

I<New in version 0.21.>

=item C<rmdir>

ret = rmdir(path);

I<New in version 0.19.>

=item C<round>

r = round(x);

=item C<scalbn>

y = scalbn(x, n);

Calls C<scalbln()> or C<scalbn()>, whichever is the maximum supported by your
system.

=item C<seed48>

(old_seed1, old_seed2, old_seed3) = seed48(seed1, seed2, seed3);

=item C<setegid>

ret = setegid(gid);

=item C<seteuid>

ret = seteuid(uid);

=item C<setgid>

ret = setgid(gid);

=item C<setitimer>

(old_int_sec, old_int_usec, old_val_sec, old_val_usec) = setitimer(which,
int_sec, int_usec, val_sec, val_usec);

I<which> is one of C<ITIMER_REAL>, C<ITIMER_VIRTUAL>, C<ITIMER_PROF>.

POSIX.1-2008 marks C<getitimer()> and C<setitimer()> obsolete, recommending
the use of the POSIX timers API (L<C<timer_gettime()>|"timer_gettime">,
L<C<timer_settime()>|"timer_settime">, etc.)  instead.

POSIX.1-2024 removed C<getitimer()> and C<setitimer()>.

=item C<setpriority>

ret = setpriority(prio, which=PRIO_PROCESS, who=0);

I<which> can be one of C<PRIO_PROCESS>, C<PRIO_PGRP>, C<PRIO_USER>, defaults
to C<PRIO_PROCESS>. I<who> defaults to 0.

Note that due to the support of default values for I<which> and I<who>,
I<prio> is the first call parameter, whereas in the actual syscall it is the
last.

Returns true on success, undef on error.

=item C<setregid>

ret = setregid(rgid, egid);

=item C<setreuid>

ret = setreuid(ruid, euid);

=item C<setsid>

sid = setsid();

I<New in version 0.19.>

=item C<setuid>

ret = setuid(uid);

=item C<setutxent>

setutxent();

=item C<sighold>

ret = sighold(sig);

POSIX.1-2008 marks this function as obsolete, recommending the use of
L<POSIX/"sigprocmask"> instead.

=item C<sigignore>

ret = sigignore(sig);

POSIX.1-2008 marks this function as obsolete, recommending the use of
L<POSIX/"sigaction"> instead. Or use C<$SIG{SIG} = 'IGNORE';>.

=item C<signbit>

b = signbit(x);

=item C<sigpause>

sigpause(sig);

POSIX.1-2008 marks this function as obsolete, recommending the use of
L<POSIX/"sigsuspend"> instead.

=item C<sigrelse>

ret = sigrelse(sig);

POSIX.1-2008 marks this function as obsolete, recommending the use of
L<POSIX/"sigprocmask"> instead.

=item C<sin>

y = sin(x);

I<New in version 0.19.>

=item C<sinh>

y = sinh(x);

=item C<srand48>

srand48(seedval);

=item C<srandom>

srandom(seed);

=item C<stat>

(dev, ino, mode, nlink, uid, gid, rdev, size, atim_sec, mtim_sec, ctim_sec,
blksize, blocks, atim_nsec, mtim_nsec, ctim_nsec) = stat(what);

I<what> can be a path, a Perl file handle or a file descriptor.

I<ctim_sec>, I<blksize>, I<blocks> and nanoseconds may not be available on
your system.

Values outside Perl's internal integer range are returned as strings, i.e. if
you need the exact values you should, for example, use C<eq> instead of C<==>
for comparisons.

Note that C<CORE::stat()> lies to you in some cases: It returns I<rdev> as a
signed integer even if your OS's C<dev_t> is unsigned. It returns I<size> as
a floating point number if your OS's C<off_t> is bigger than Perl's integer
size. It returns the times as floating point numbers if your OS's C<time_t>
is unsigned.

C<POSIX::2008::stat()> doesn't mimic these bugs and uses the correct data types
for all values.

Returns the empty list on error.

=item C<statvfs>

(f_bsize, f_frsize, f_blocks, f_bfree, f_bavail, f_files, f_ffree, f_favail,
f_fsid, f_flag, f_namemax) = statvfs(what);

I<what> can be a path, a Perl file handle or a file descriptor.

Values outside Perl's internal integer range are returned as strings as with
L<C<stat()>|"stat">. Note that L<Filesys::Statvfs|Filesys::Statvfs> returns
only floating point numbers which may give wrong results, and it lacks
I<f_fsid>.

Only the ST_NOSUID and ST_RDONLY flags of the I<f_flag> field are specified
in POSIX but this module provides additional ST_ flags if available.

Returns the empty list on error.

I<New in version 0.25.>

=item C<strptime>

  (sec, min, hour, mday, mon, year, wday, yday, isdst) =
    strptime(s, format[, sec, min, hour, mday, mon, year, wday, yday, isdst]);

  ... = strptime(s, format, \@tm);

C<strptime()> converts the string I<s> into a broken-down time according to
the format string I<format>.

The time fields may optionally be initialized in whole or in part either with
up to 9 separate arguments or with a single array reference after the format.
Omitted arguments are treated as undef. In case of an array reference the array
is updated according to the fields affected by the format string. If an error
occurred the array is not udpated.

In list context returns the broken-down time or the empty list on error.
Fields not affected by the format string are returned as initialized.

In scalar context returns the index of the first byte in I<s> that was not
processed or the byte length of I<s> if the whole string was consumed or undef
on error.

As C<strptime()> acts on null-terminated strings, strings containing NUL bytes
will only be processed up to the first NUL byte.

I<New in version 0.02.>

I<Changed in version 0.24:> Accept an array reference as the third argument
(L<https://rt.cpan.org/Public/Bug/Display.html?id=66519>).

=item C<strsignal>

str = strsignal(sig);

I<New in version 0.25.>

=item C<symlink>

ret = symlink(target, linkpath);

=item C<symlinkat>

ret = symlinkat(target, dirfd, linkpath);

=item C<sync>

sync();

This function doesn't return any value.

=item C<sysconf>

ret = sysconf(name);

I<name> is one of the C<_SC_*> integer constants.

Returns undef on error.

I<New in version 0.22.>

=item C<tan>

y = tan(x);

=item C<tanh>

y = tanh(x);

=item C<tgamma>

y = tgamma(x);

=item C<timer_create>

timerid = timer_create(clockid, signal=undef);

Creates a new per-process interval timer using the clock given by I<clock_id>
as the timing base. I<signal> is the signal number to be delivered when the
timer expires. If I<signal> is omitted or undef, no signal is delivered and
the progress of the timer can be monitored using
L<C<timer_gettime()>|"timer_gettime">.

Calling a notification function on timer expiration is currently not
supported.

Returns undef on error.

I<New in version 0.16.>

I<Changed in version 0.22:> I<signal> is optional.

=item C<timer_delete>

ret = timer_delete(timerid);

Returns C<0 but true> on success, undef on error.

I<New in version 0.16.>

=item C<timer_getoverrun>

count = timer_getoverrun(timerid);

Returns undef on error.

I<New in version 0.16.>

=item C<timer_gettime>

(interval_sec, interval_nsec, initial_sec, initial_nsec) = timer_gettime(timerid);

Returns the empty list on error.

I<New in version 0.16.>

=item C<timer_settime>

(old_int_sec, old_int_nsec, old_init_sec, old_init_nsec) = timer_settime(timerid, flags, int_sec, int_nsec, [init_sec, init_nsec]);

I<flags> may be 0 or C<TIMER_ABSTIME>. If the I<init> values are omitted, they
are set to the I<int> values.

I<New in version 0.16.>

=item C<truncate>

ret = truncate(what, length);

I<what> can be a path, a Perl file handle, or a file descriptor.

Note that it does not flush the file handle before truncating. Perl's built-in
truncate() does (this is undocumented, probably because it's silly).

I<Changed in version 0.19:> Deprecated I<ftruncate> now covered by I<truncate>.

=item C<trunc>

y = trunc(x);

=item C<ttyname>

name = ttyname(fd);

Calls C<ttyname_r()> if available.

I<New in version 0.19.>

I<Changed in version 0.22:> I<fd> may also be a file handle.

=item C<unlink>

ret = unlink(path);

Calls the actual C library function C<unlink()>.

Note that core C<POSIX::unlink()> calls C<CORE::unlink()>, which, unless you
start Perl with C<-U>, a) is prone to time-of-check/time-of-use race
conditions due to an additional lstat(), and b) blindly fails with C<EISDIR>
for directories (due to said lstat()), ignoring that some OSes use C<EPERM> in
this case (as required by POSIX).

=item C<unlinkat>

ret = unlinkat(dirfd, path, flags=0);

I<flags> can be 0 or C<AT_REMOVEDIR>.

=item C<utimensat>

ret = utimensat(dirfd, path, flags, atime_sec, atime_nsec, mtime_sec,
mtime_nsec);

I<flags> can be 0 or C<AT_SYMLINK_NOFOLLOW>, defaults to 0. Your system might
support a different set of flags.

I<atime_sec> and I<mtime_sec> default to 0. I<atime_nsec> and I<mtime_nsec>
default to C<UTIME_NOW>.

=item C<write>

bytes_written = write(fd, buf, count=undef);

Like C<POSIX::write()> but returns 0 instead of C<0 but true> if 0 bytes were
written, and never writes more bytes than I<buf> contains even if I<count>
exceeds the length of I<buf>.

If I<count> is omitted or undef, it defaults to the length of I<buf>.

=item C<writev>

bytes_written = writev(fd, buffers);

C<writev()> writes multiple I<buffers> of data to the file associated with the
file descriptor I<fd>.

I<buffers> must be an array reference, i.e. C<\@buf>, C<$buf> or C<[...]>. The
buffers are processed in array order.

Note that C<writev($fh, $buf);> is not the same as C<print $fh, @$buf;> or
C<syswrite $fh, $_ for @$buf;> because C<writev()> transfers data atomically
as a single block. See the manpage for details.

Returns the number of bytes written or undef on error.

I<New in version 0.08.>

=item C<y0>

y = y0(x);

C<y0()> is the Bessel function of the second kind of order 0.

=item C<y1>

y = y1(x);

C<y1()> is the Bessel function of the second kind of order 1.

=item C<yn>

y = yn(n, x);

C<yn()> is the Bessel function of the second kind of order n.

=back

=head1 EXPORTS

This module does not export anything by default. The following export tags are
available:

 :at      All *at() functions like openat(), all AT_/RENAME_/RESOLVE_ constants
 :id      All get/set*id() functions like getuid() etc.
 :is      All is* functions like isdigit() etc.
 :rw      read(), readv(), write(), writev()
 :prw     pread(), preadv(), preadv2(), pwrite(), pwritev(), pwritev2()
 :clock   All clock* functions and CLOCK_ constants and TIMER_ABSTIME
 :fcntl   All F_, FD_, O_, POSIX_FADV_, SEEK_, _OK constants (for AT_ use :at)
 :fenv_h  All FE_ constants and fe* functions
 :fnm     fnmatch() and all FNM_ constants
 :poll    poll() and all POLL constants
 :stat_h  All S_I* and UTIME_ constants
 :time_h  All CLOCK_ and TIMER_ constants
 :timer   All timer_ functions and TIMER_ constants
 :utmpx_h   All *utx* functions and utmpx.h constants
 :confstr   confstr() and all _CS_ constants
 :pathconf  pathconf() and all _PC_ constants
 :sysconf   sysconf() and all _SC_ constants

I<New in version 0.19:> :stat_h export tag.

I<New in version 0.20:> :fenv_h export tag.

I<New in version 0.22:> :confstr, :pathconf, :sysconf export tags.

I<New in version 0.25:> :poll export tag.

=head1 CONSTANTS

C<AT_EACCESS> C<AT_EMPTY_PATH> C<AT_FDCWD> C<AT_NO_AUTOMOUNT> C<AT_REMOVEDIR>
C<AT_RESOLVE_BENEATH> C<AT_SYMLINK_FOLLOW> C<AT_SYMLINK_NOFOLLOW>
C<RENAME_EXCHANGE> C<RENAME_NOREPLACE> C<RENAME_WHITEOUT> C<RESOLVE_BENEATH>
C<RESOLVE_CACHED> C<RESOLVE_IN_ROOT> C<RESOLVE_NO_MAGICLINKS>
C<RESOLVE_NO_SYMLINKS> C<RESOLVE_NO_XDEV>

C<ACCOUNTING> C<EMPTY> C<BOOT_TIME> C<NEW_TIME> C<OLD_TIME> C<DEAD_PROCESS>
C<INIT_PROCESS> C<LOGIN_PROCESS> C<USER_PROCESS> C<RUN_LVL>

C<CLOCK_BOOTTIME> C<CLOCK_BOOTTIME_ALARM> C<CLOCK_HIGHRES> C<CLOCK_MONOTONIC>
C<CLOCK_MONOTONIC_COARSE> C<CLOCK_MONOTONIC_FAST> C<CLOCK_MONOTONIC_PRECISE>
C<CLOCK_MONOTONIC_RAW> C<CLOCK_PROCESS_CPUTIME_ID> C<CLOCK_REALTIME>
C<CLOCK_REALTIME_ALARM> C<CLOCK_REALTIME_COARSE> C<CLOCK_REALTIME_FAST>
C<CLOCK_REALTIME_PRECISE> C<CLOCK_SOFTTIME> C<CLOCK_TAI>
C<CLOCK_THREAD_CPUTIME_ID> C<CLOCK_UPTIME> C<CLOCK_UPTIME_FAST>
C<CLOCK_UPTIME_PRECISE>

C<F_DUPFD> C<F_DUPFD_CLOEXEC> C<F_GETFD> C<F_SETFD> C<F_GETFL>
C<F_SETFL> C<F_GETLK> C<F_SETLK> C<F_SETLKW> C<F_GETOWN> C<F_SETOWN>
C<F_RDLCK> C<F_UNLCK> C<F_WRLCK>

C<FD_CLOEXEC>

C<FE_ALL_EXCEPT> C<FE_DIVBYZERO> C<FE_INEXACT> C<FE_INVALID> C<FE_OVERFLOW>
C<FE_UNDERFLOW> C<FE_TONEAREST> C<FE_TOWARDZERO> C<FE_UPWARD> C<FE_DOWNWARD>

C<FNM_CASEFOLD> C<FNM_FILE_NAME> C<FNM_LEADING_DIR> C<FNM_NOESCAPE>
C<FNM_NOMATCH> C<FNM_PATHNAME> C<FNM_PERIOD>

C<FP_INFINITE> C<FP_NAN> C<FP_NORMAL> C<FP_SUBNORMAL> C<FP_ZERO>

C<TIMER_ABSTIME> C<ITIMER_PROF> C<ITIMER_REAL> C<ITIMER_VIRTUAL>

C<O_ACCMODE> C<O_APPEND> C<O_ASYNC> C<O_CLOEXEC> C<O_CREAT> C<O_DIRECT>
C<O_DIRECTORY> C<O_DSYNC> C<O_EMPTY_PATH> C<O_EXCL> C<O_EXEC> C<O_EXLOCK>
C<O_LARGEFILE> C<O_NDELAY> C<O_NOATIME> C<O_NOCTTY> C<O_NOFOLLOW>
C<O_NONBLOCK> C<O_NOSIGPIPE> C<O_PATH> C<O_RDONLY> C<O_REGULAR>
C<O_RESOLVE_BENEATH> C<O_RDWR> C<O_RSYNC> C<O_SEARCH> C<O_SHLOCK> C<O_SYNC>
C<O_TMPFILE> C<O_TRUNC> C<O_TTY_INIT> C<O_WRONLY> C<FASYNC>

C<POLLIN> C<POLLRDNORM> C<POLLRDBAND> C<POLLPRI> C<POLLOUT> C<POLLWRNORM>
C<POLLWRBAND> C<POLLERR> C<POLLHUP> C<POLLNVAL>

C<INFTIM> C<POLLFREE> C<POLLMSG> C<POLLNORM> C<POLLRDHUP> C<POLLREMOVE>
C<POLL_BUSY_LOOP>

C<POSIX_FADV_NORMAL> C<POSIX_FADV_SEQUENTIAL> C<POSIX_FADV_RANDOM>
C<POSIX_FADV_NOREUSE> C<POSIX_FADV_WILLNEED> C<POSIX_FADV_DONTNEED>

C<PRIO_PROCESS> C<PRIO_PGRP> C<PRIO_USER>

C<RTLD_DEEPBIND> C<RTLD_GLOBAL> C<RTLD_LAZY> C<RTLD_LOCAL> C<RTLD_MEMBER>
C<RTLD_NOAUTODEFER> C<RTLD_NODELETE> C<RTLD_NOLOAD> C<RTLD_NOW>

C<RWF_APPEND> C<RWF_DSYNC> C<RWF_HIPRI> C<RWF_NOWAIT> C<RWF_SYNC>

C<SEEK_SET> C<SEEK_CUR> C<SEEK_END> C<SEEK_DATA> C<SEEK_HOLE> C<F_OK> C<R_OK>
C<W_OK> C<X_OK>

C<S_IFMT> C<S_IFBLK> C<S_IFCHR> C<S_IFIFO> C<S_IFREG> C<S_IFDIR> C<S_IFLNK>
C<S_IFSOCK> C<S_ISUID> C<S_ISGID> C<S_IRWXU> C<S_IRUSR> C<S_IWUSR> C<S_IXUSR>
C<S_IRWXG> C<S_IRGRP> C<S_IWGRP> C<S_IXGRP> C<S_IRWXO> C<S_IROTH> C<S_IWOTH>
C<S_IXOTH> C<S_ISVTX>

C<ST_NOSUID> C<ST_RDONLY>

C<ST_MANDLOCK> C<ST_NOATIME> C<ST_NODEV> C<ST_NODIRATIME> C<ST_NOEXEC>
C<ST_RELATIME> C<ST_SYNCHRONOUS>

C<ST_ASYNC> C<ST_DEFEXPORTED> C<ST_EXKERB> C<ST_EXNORESPORT> C<ST_EXPORTANON>
C<ST_EXPORTED> C<ST_EXPUBLIC> C<ST_EXRDONLY> C<ST_LOCAL> C<ST_LOG>
C<ST_NOCOREDUMP> C<ST_NODEVMTIME> C<ST_QUOTA> C<ST_ROOTFS> C<ST_SYMPERM>
C<ST_UNION>

C<UTIME_NOW> C<UTIME_OMIT>

C<_CS_GNU_LIBC_VERSION> C<_CS_GNU_LIBPTHREAD_VERSION> C<_CS_LFS64_CFLAGS>
C<_CS_LFS64_LDFLAGS> C<_CS_LFS64_LIBS> C<_CS_LFS64_LINTFLAGS>
C<_CS_LFS_CFLAGS> C<_CS_LFS_LDFLAGS> C<_CS_LFS_LIBS> C<_CS_LFS_LINTFLAGS>
C<_CS_PATH> C<_CS_POSIX_V5_WIDTH_RESTRICTED_ENVS>
C<_CS_POSIX_V6_ILP32_OFF32_CFLAGS> C<_CS_POSIX_V6_ILP32_OFF32_LDFLAGS>
C<_CS_POSIX_V6_ILP32_OFF32_LIBS> C<_CS_POSIX_V6_ILP32_OFF32_LINTFLAGS>
C<_CS_POSIX_V6_ILP32_OFFBIG_CFLAGS> C<_CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS>
C<_CS_POSIX_V6_ILP32_OFFBIG_LIBS> C<_CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS>
C<_CS_POSIX_V6_LP64_OFF64_CFLAGS> C<_CS_POSIX_V6_LP64_OFF64_LDFLAGS>
C<_CS_POSIX_V6_LP64_OFF64_LIBS> C<_CS_POSIX_V6_LP64_OFF64_LINTFLAGS>
C<_CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS> C<_CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS>
C<_CS_POSIX_V6_LPBIG_OFFBIG_LIBS> C<_CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS>
C<_CS_POSIX_V6_WIDTH_RESTRICTED_ENVS> C<_CS_POSIX_V7_ILP32_OFF32_CFLAGS>
C<_CS_POSIX_V7_ILP32_OFF32_LDFLAGS> C<_CS_POSIX_V7_ILP32_OFF32_LIBS>
C<_CS_POSIX_V7_ILP32_OFF32_LINTFLAGS> C<_CS_POSIX_V7_ILP32_OFFBIG_CFLAGS>
C<_CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS> C<_CS_POSIX_V7_ILP32_OFFBIG_LIBS>
C<_CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS> C<_CS_POSIX_V7_LP64_OFF64_CFLAGS>
C<_CS_POSIX_V7_LP64_OFF64_LDFLAGS> C<_CS_POSIX_V7_LP64_OFF64_LIBS>
C<_CS_POSIX_V7_LP64_OFF64_LINTFLAGS> C<_CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS>
C<_CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS> C<_CS_POSIX_V7_LPBIG_OFFBIG_LIBS>
C<_CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS> C<_CS_POSIX_V7_WIDTH_RESTRICTED_ENVS>
C<_CS_V5_WIDTH_RESTRICTED_ENVS> C<_CS_V6_ENV> C<_CS_V6_WIDTH_RESTRICTED_ENVS>
C<_CS_V7_ENV> C<_CS_V7_WIDTH_RESTRICTED_ENVS> C<_CS_XBS5_ILP32_OFF32_CFLAGS>
C<_CS_XBS5_ILP32_OFF32_LDFLAGS> C<_CS_XBS5_ILP32_OFF32_LIBS>
C<_CS_XBS5_ILP32_OFF32_LINTFLAGS> C<_CS_XBS5_ILP32_OFFBIG_CFLAGS>
C<_CS_XBS5_ILP32_OFFBIG_LDFLAGS> C<_CS_XBS5_ILP32_OFFBIG_LIBS>
C<_CS_XBS5_ILP32_OFFBIG_LINTFLAGS> C<_CS_XBS5_LP64_OFF64_CFLAGS>
C<_CS_XBS5_LP64_OFF64_LDFLAGS> C<_CS_XBS5_LP64_OFF64_LIBS>
C<_CS_XBS5_LP64_OFF64_LINTFLAGS> C<_CS_XBS5_LPBIG_OFFBIG_CFLAGS>
C<_CS_XBS5_LPBIG_OFFBIG_LDFLAGS> C<_CS_XBS5_LPBIG_OFFBIG_LIBS>
C<_CS_XBS5_LPBIG_OFFBIG_LINTFLAGS>

C<_PC_2_SYMLINKS> C<_PC_ALLOC_SIZE_MIN> C<_PC_ASYNC_IO>
C<_PC_CHOWN_RESTRICTED> C<_PC_FILESIZEBITS> C<_PC_LINK_MAX> C<_PC_MAX_CANON>
C<_PC_MAX_INPUT> C<_PC_NAME_MAX> C<_PC_NO_TRUNC> C<_PC_PATH_MAX>
C<_PC_PIPE_BUF> C<_PC_PRIO_IO> C<_PC_REC_INCR_XFER_SIZE>
C<_PC_REC_MAX_XFER_SIZE> C<_PC_REC_MIN_XFER_SIZE> C<_PC_REC_XFER_ALIGN>
C<_PC_SOCK_MAXBUF> C<_PC_SYMLINK_MAX> C<_PC_SYNC_IO> C<_PC_VDISABLE>

C<_SC_2_CHAR_TERM> C<_SC_2_C_BIND> C<_SC_2_C_DEV> C<_SC_2_C_VERSION>
C<_SC_2_FORT_DEV> C<_SC_2_FORT_RUN> C<_SC_2_LOCALEDEF> C<_SC_2_PBS>
C<_SC_2_PBS_ACCOUNTING> C<_SC_2_PBS_CHECKPOINT> C<_SC_2_PBS_LOCATE>
C<_SC_2_PBS_MESSAGE> C<_SC_2_PBS_TRACK> C<_SC_2_SW_DEV> C<_SC_2_UPE>
C<_SC_2_VERSION> C<_SC_ADVISORY_INFO> C<_SC_AIO_LISTIO_MAX> C<_SC_AIO_MAX>
C<_SC_AIO_PRIO_DELTA_MAX> C<_SC_ARG_MAX> C<_SC_ASYNCHRONOUS_IO>
C<_SC_ATEXIT_MAX> C<_SC_AVPHYS_PAGES> C<_SC_BARRIERS> C<_SC_BASE>
C<_SC_BC_BASE_MAX> C<_SC_BC_DIM_MAX> C<_SC_BC_SCALE_MAX> C<_SC_BC_STRING_MAX>
C<_SC_CHARCLASS_NAME_MAX> C<_SC_CHAR_BIT> C<_SC_CHAR_MAX> C<_SC_CHAR_MIN>
C<_SC_CHILD_MAX> C<_SC_CLK_TCK> C<_SC_CLOCK_SELECTION> C<_SC_COLL_WEIGHTS_MAX>
C<_SC_CPUTIME> C<_SC_C_LANG_SUPPORT> C<_SC_C_LANG_SUPPORT_R>
C<_SC_DELAYTIMER_MAX> C<_SC_DEVICE_IO> C<_SC_DEVICE_SPECIFIC>
C<_SC_DEVICE_SPECIFIC_R> C<_SC_EQUIV_CLASS_MAX> C<_SC_EXPR_NEST_MAX>
C<_SC_FD_MGMT> C<_SC_FIFO> C<_SC_FILE_ATTRIBUTES> C<_SC_FILE_LOCKING>
C<_SC_FILE_SYSTEM> C<_SC_FSYNC> C<_SC_GETGR_R_SIZE_MAX>
C<_SC_GETPW_R_SIZE_MAX> C<_SC_HOST_NAME_MAX> C<_SC_INT_MAX> C<_SC_INT_MIN>
C<_SC_IOV_MAX> C<_SC_IPV6> C<_SC_JOB_CONTROL> C<_SC_LEVEL1_DCACHE_ASSOC>
C<_SC_LEVEL1_DCACHE_LINESIZE> C<_SC_LEVEL1_DCACHE_SIZE>
C<_SC_LEVEL1_ICACHE_ASSOC> C<_SC_LEVEL1_ICACHE_LINESIZE>
C<_SC_LEVEL1_ICACHE_SIZE> C<_SC_LEVEL2_CACHE_ASSOC>
C<_SC_LEVEL2_CACHE_LINESIZE> C<_SC_LEVEL2_CACHE_SIZE>
C<_SC_LEVEL3_CACHE_ASSOC> C<_SC_LEVEL3_CACHE_LINESIZE>
C<_SC_LEVEL3_CACHE_SIZE> C<_SC_LEVEL4_CACHE_ASSOC>
C<_SC_LEVEL4_CACHE_LINESIZE> C<_SC_LEVEL4_CACHE_SIZE> C<_SC_LINE_MAX>
C<_SC_LOGIN_NAME_MAX> C<_SC_LONG_BIT> C<_SC_MAPPED_FILES> C<_SC_MB_LEN_MAX>
C<_SC_MEMLOCK> C<_SC_MEMLOCK_RANGE> C<_SC_MEMORY_PROTECTION>
C<_SC_MESSAGE_PASSING> C<_SC_MINSIGSTKSZ> C<_SC_MONOTONIC_CLOCK>
C<_SC_MQ_OPEN_MAX> C<_SC_MQ_PRIO_MAX> C<_SC_MULTI_PROCESS> C<_SC_NETWORKING>
C<_SC_NGROUPS_MAX> C<_SC_NL_ARGMAX> C<_SC_NL_LANGMAX> C<_SC_NL_MSGMAX>
C<_SC_NL_NMAX> C<_SC_NL_SETMAX> C<_SC_NL_TEXTMAX> C<_SC_NPROCESSORS_CONF>
C<_SC_NPROCESSORS_ONLN> C<_SC_NZERO> C<_SC_OPEN_MAX> C<_SC_PAGESIZE>
C<_SC_PAGE_SIZE> C<_SC_PASS_MAX> C<_SC_PHYS_PAGES> C<_SC_PII>
C<_SC_PII_INTERNET> C<_SC_PII_INTERNET_DGRAM> C<_SC_PII_INTERNET_STREAM>
C<_SC_PII_OSI> C<_SC_PII_OSI_CLTS> C<_SC_PII_OSI_COTS> C<_SC_PII_OSI_M>
C<_SC_PII_SOCKET> C<_SC_PII_XTI> C<_SC_PIPE> C<_SC_POLL> C<_SC_PRIORITIZED_IO>
C<_SC_PRIORITY_SCHEDULING> C<_SC_RAW_SOCKETS> C<_SC_READER_WRITER_LOCKS>
C<_SC_REALTIME_SIGNALS> C<_SC_REGEXP> C<_SC_REGEX_VERSION> C<_SC_RE_DUP_MAX>
C<_SC_RTSIG_MAX> C<_SC_SAVED_IDS> C<_SC_SCHAR_MAX> C<_SC_SCHAR_MIN>
C<_SC_SELECT> C<_SC_SEMAPHORES> C<_SC_SEM_NSEMS_MAX> C<_SC_SEM_VALUE_MAX>
C<_SC_SHARED_MEMORY_OBJECTS> C<_SC_SHELL> C<_SC_SHRT_MAX> C<_SC_SHRT_MIN>
C<_SC_SIGNALS> C<_SC_SIGQUEUE_MAX> C<_SC_SIGSTKSZ> C<_SC_SINGLE_PROCESS>
C<_SC_SPAWN> C<_SC_SPIN_LOCKS> C<_SC_SPORADIC_SERVER> C<_SC_SSIZE_MAX>
C<_SC_SS_REPL_MAX> C<_SC_STREAMS> C<_SC_STREAM_MAX> C<_SC_SYMLOOP_MAX>
C<_SC_SYNCHRONIZED_IO> C<_SC_SYSTEM_DATABASE> C<_SC_SYSTEM_DATABASE_R>
C<_SC_THREADS> C<_SC_THREAD_ATTR_STACKADDR> C<_SC_THREAD_ATTR_STACKSIZE>
C<_SC_THREAD_CPUTIME> C<_SC_THREAD_DESTRUCTOR_ITERATIONS>
C<_SC_THREAD_KEYS_MAX> C<_SC_THREAD_PRIORITY_SCHEDULING>
C<_SC_THREAD_PRIO_INHERIT> C<_SC_THREAD_PRIO_PROTECT>
C<_SC_THREAD_PROCESS_SHARED> C<_SC_THREAD_ROBUST_PRIO_INHERIT>
C<_SC_THREAD_ROBUST_PRIO_PROTECT> C<_SC_THREAD_SAFE_FUNCTIONS>
C<_SC_THREAD_SPORADIC_SERVER> C<_SC_THREAD_STACK_MIN>
C<_SC_THREAD_THREADS_MAX> C<_SC_TIMEOUTS> C<_SC_TIMERS> C<_SC_TIMER_MAX>
C<_SC_TRACE> C<_SC_TRACE_EVENT_FILTER> C<_SC_TRACE_EVENT_NAME_MAX>
C<_SC_TRACE_INHERIT> C<_SC_TRACE_LOG> C<_SC_TRACE_NAME_MAX>
C<_SC_TRACE_SYS_MAX> C<_SC_TRACE_USER_EVENT_MAX> C<_SC_TTY_NAME_MAX>
C<_SC_TYPED_MEMORY_OBJECTS> C<_SC_TZNAME_MAX> C<_SC_T_IOV_MAX>
C<_SC_UCHAR_MAX> C<_SC_UINT_MAX> C<_SC_UIO_MAXIOV> C<_SC_ULONG_MAX>
C<_SC_USER_GROUPS> C<_SC_USER_GROUPS_R> C<_SC_USHRT_MAX> C<_SC_V6_ILP32_OFF32>
C<_SC_V6_ILP32_OFFBIG> C<_SC_V6_LP64_OFF64> C<_SC_V6_LPBIG_OFFBIG>
C<_SC_V7_ILP32_OFF32> C<_SC_V7_ILP32_OFFBIG> C<_SC_V7_LP64_OFF64>
C<_SC_V7_LPBIG_OFFBIG> C<_SC_VERSION> C<_SC_WORD_BIT> C<_SC_XBS5_ILP32_OFF32>
C<_SC_XBS5_ILP32_OFFBIG> C<_SC_XBS5_LP64_OFF64> C<_SC_XBS5_LPBIG_OFFBIG>
C<_SC_XOPEN_CRYPT> C<_SC_XOPEN_ENH_I18N> C<_SC_XOPEN_LEGACY>
C<_SC_XOPEN_REALTIME> C<_SC_XOPEN_REALTIME_THREADS> C<_SC_XOPEN_SHM>
C<_SC_XOPEN_STREAMS> C<_SC_XOPEN_UNIX> C<_SC_XOPEN_VERSION>
C<_SC_XOPEN_XCU_VERSION> C<_SC_XOPEN_XPG2> C<_SC_XOPEN_XPG3> C<_SC_XOPEN_XPG4>

=head1 NOTES

C<removeat()> is a home-grown nonstandard extension present only in this
module.

C<preadv()> and C<pwritev()> are nonstandard extensions present in Linux and
BSD.

C<execveat()>, C<openat2()>, C<preadv2()>, C<pwritev2()> and C<renameat2()>
are nonstandard extensions present in Linux.

C<fstatat()>, C<lstat()> and C<stat()> do not set the special underscore
filehandle C<_> (mostly because I have no clue how that works).

C<open()>, C<openat()> and C<openat2()> do not set the C<O_CLOEXEC> flag
automatically. You have to take care of that yourself if needed.

C<isalnum()> and friends were cowardly removed from the POSIX module with Perl
5.24.0. They have found a cozy home here with a fix for a long-standing bug.

C<SEEK_DATA> and C<SEEK_HOLE> were added to C<unistd.h> in
L<POSIX.1-2024|https://pubs.opengroup.org/onlinepubs/9799919799/> (Issue
8). Before that, they were nonstandard extensions present in Linux, Solaris,
FreeBSD, and DragonFly BSD.

For some inexplicable reason, Perl forbids you to use the built-in C<chmod()>
and C<chown()> on an C<opendir()> handle and to use C<readdir()> and
C<rewinddir()> on a C<sysopen()> handle (provided it refers to a directory).
Needless to say that C<chmod()> and C<chown()> from POSIX::2008 happily work
with C<opendir()> handles, and of course you can use C<readdir()> and
C<rewinddir()> on an C<openat()> handle that refers to a directory.

=head1 AUTHOR

Initially hacked together by Carsten Gaebler.

=head1 LICENSE

This library is free software. You can redistribute and/or modify it under the
terms of the Do What The Fuck You Want To Public License, Version 2, as
published by Sam Hocevar. See the COPYING file or L<http://www.wtfpl.net/> for
more details.

=cut
