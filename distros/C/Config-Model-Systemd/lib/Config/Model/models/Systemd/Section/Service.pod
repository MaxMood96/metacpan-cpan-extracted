# PODNAME: Config::Model::models::Systemd::Section::Service
# ABSTRACT:  Configuration class Systemd::Section::Service

=encoding utf8

=head1 NAME

Config::Model::models::Systemd::Section::Service - Configuration class Systemd::Section::Service

=head1 DESCRIPTION

Configuration classes used by L<Config::Model>

A unit configuration file whose name ends in
C<.service> encodes information about a process
controlled and supervised by systemd.

This man page lists the configuration options specific to
this unit type. See
L<systemd.unit(5)>
for the common options of all unit configuration files. The common
configuration items are configured in the generic
[Unit] and [Install]
sections. The service specific configuration options are
configured in the [Service] section.

Additional options are listed in
L<systemd.exec(5)>,
which define the execution environment the commands are executed
in, and in
L<systemd.kill(5)>,
which define the way the processes of the service are terminated,
and in
L<systemd.resource-control(5)>,
which configure resource control settings for the processes of the
service.

If SysV init compat is enabled, systemd automatically creates service units that wrap SysV init
scripts (the service name is the same as the name of the script, with a C<.service>
suffix added); see
L<systemd-sysv-generator(8)>.


The L<systemd-run(1)>
command allows creating C<.service> and C<.scope> units dynamically
and transiently from the command line.
This configuration class was generated from systemd documentation.
by L<parse-man.pl|https://github.com/dod38fr/config-model-systemd/contrib/parse-man.pl>


=head1 Elements

=head2 CPUWeight

These settings control the C<cpu> controller in the unified hierarchy.

These options accept an integer value or the special string "idle":

While C<StartupCPUWeight> applies to the startup and shutdown phases of the system,
C<CPUWeight> applies to normal runtime of the system, and if the former is not set also to
the startup and shutdown phases. Using C<StartupCPUWeight> allows prioritizing specific services at
boot-up and shutdown differently than during normal runtime.

In addition to the resource allocation performed by the C<cpu> controller, the
kernel may automatically divide resources based on session-id grouping, see "The autogroup feature"
in L<sched(7)>.
The effect of this feature is similar to the C<cpu> controller with no explicit
configuration, so users should be careful to not mistake one for the other. I< Optional. Type uniline.  > 

=head2 StartupCPUWeight

These settings control the C<cpu> controller in the unified hierarchy.

These options accept an integer value or the special string "idle":

While C<StartupCPUWeight> applies to the startup and shutdown phases of the system,
C<CPUWeight> applies to normal runtime of the system, and if the former is not set also to
the startup and shutdown phases. Using C<StartupCPUWeight> allows prioritizing specific services at
boot-up and shutdown differently than during normal runtime.

In addition to the resource allocation performed by the C<cpu> controller, the
kernel may automatically divide resources based on session-id grouping, see "The autogroup feature"
in L<sched(7)>.
The effect of this feature is similar to the C<cpu> controller with no explicit
configuration, so users should be careful to not mistake one for the other. I< Optional. Type uniline.  > 

=head2 CPUQuota

This setting controls the C<cpu> controller in the unified hierarchy.

Assign the specified CPU time quota to the processes executed. Takes a percentage value, suffixed with
"%". The percentage specifies how much CPU time the unit shall get at maximum, relative to the total CPU time
available on one CPU. Use values > 100% for allotting CPU time on more than one CPU. This controls the
C<cpu.max> attribute on the unified control group hierarchy and
C<cpu.cfs_quota_us> on legacy. For details about these control group attributes, see L<Control Groups
v2|https://docs.kernel.org/admin-guide/cgroup-v2.html> and L<CFS Bandwidth
Control|https://docs.kernel.org/scheduler/sched-bwc.html>.
Setting C<CPUQuota> to an empty value unsets the quota.

Example: C<CPUQuota=20%> ensures that the executed processes will never get more than
20% CPU time on one CPU. I< Optional. Type uniline.  > 

=head2 CPUQuotaPeriodSec

This setting controls the C<cpu> controller in the unified hierarchy.

Assign the duration over which the CPU time quota specified by C<CPUQuota> is measured.
Takes a time duration value in seconds, with an optional suffix such as "ms" for milliseconds (or "s" for seconds.)
The default setting is 100ms. The period is clamped to the range supported by the kernel, which is [1ms, 1000ms].
Additionally, the period is adjusted up so that the quota interval is also at least 1ms.
Setting C<CPUQuotaPeriodSec> to an empty value resets it to the default.

This controls the second field of C<cpu.max> attribute on the unified control group hierarchy
and C<cpu.cfs_period_us> on legacy. For details about these control group attributes, see
L<Control Groups v2|https://docs.kernel.org/admin-guide/cgroup-v2.html> and
L<CFS Scheduler|https://docs.kernel.org/scheduler/sched-design-CFS.html>.

Example: C<CPUQuotaPeriodSec=10ms> to request that the CPU quota is measured in periods of 10ms. I< Optional. Type uniline.  > 

=head2 AllowedCPUs

This setting controls the C<cpuset> controller in the unified hierarchy.

Restrict processes to be executed on specific CPUs. Takes a list of CPU indices or ranges separated by either
whitespace or commas. CPU ranges are specified by the lower and upper CPU indices separated by a dash.

Setting C<AllowedCPUs> or C<StartupAllowedCPUs> does not guarantee that all
of the CPUs will be used by the processes as it may be limited by parent units. The effective configuration is
reported as C<EffectiveCPUs>.

While C<StartupAllowedCPUs> applies to the startup and shutdown phases of the system,
C<AllowedCPUs> applies to normal runtime of the system, and if the former is not set also to
the startup and shutdown phases. Using C<StartupAllowedCPUs> allows prioritizing specific services at
boot-up and shutdown differently than during normal runtime.

This setting is supported only with the unified control group hierarchy. I< Optional. Type uniline.  > 

=head2 StartupAllowedCPUs

This setting controls the C<cpuset> controller in the unified hierarchy.

Restrict processes to be executed on specific CPUs. Takes a list of CPU indices or ranges separated by either
whitespace or commas. CPU ranges are specified by the lower and upper CPU indices separated by a dash.

Setting C<AllowedCPUs> or C<StartupAllowedCPUs> does not guarantee that all
of the CPUs will be used by the processes as it may be limited by parent units. The effective configuration is
reported as C<EffectiveCPUs>.

While C<StartupAllowedCPUs> applies to the startup and shutdown phases of the system,
C<AllowedCPUs> applies to normal runtime of the system, and if the former is not set also to
the startup and shutdown phases. Using C<StartupAllowedCPUs> allows prioritizing specific services at
boot-up and shutdown differently than during normal runtime.

This setting is supported only with the unified control group hierarchy. I< Optional. Type uniline.  > 

=head2 MemoryAccounting

This setting controls the C<memory> controller in the unified hierarchy.

Turn on process and kernel memory accounting for this
unit. Takes a boolean argument. Note that turning on memory
accounting for one unit will also implicitly turn it on for
all units contained in the same slice and for all its parent
slices and the units contained therein. The system default
for this setting may be controlled with
C<DefaultMemoryAccounting> in
L<systemd-system.conf(5)>. I< Optional. Type boolean.  > 

=head2 MemoryMin

These settings control the C<memory> controller in the unified hierarchy.

Specify the memory usage protection of the executed processes in this unit.
When reclaiming memory, the unit is treated as if it was using less memory resulting in memory
to be preferentially reclaimed from unprotected units.
Using C<MemoryLow> results in a weaker protection where memory may still
be reclaimed to avoid invoking the OOM killer in case there is no other reclaimable memory.

For a protection to be effective, it is generally required to set a corresponding
allocation on all ancestors, which is then distributed between children
(with the exception of the root slice).
Any C<MemoryMin> or C<MemoryLow> allocation that is not
explicitly distributed to specific children is used to create a shared protection for all children.
As this is a shared protection, the children will freely compete for the memory.

Takes a memory size in bytes. If the value is suffixed with K, M, G or T, the specified memory size is
parsed as Kilobytes, Megabytes, Gigabytes, or Terabytes (with the base 1024), respectively. Alternatively, a
percentage value may be specified, which is taken relative to the installed physical memory on the
system. If assigned the special value C<infinity>, all available memory is protected, which may be
useful in order to always inherit all of the protection afforded by ancestors.
This controls the C<memory.min> or C<memory.low> control group attribute.
For details about this control group attribute, see L<Memory Interface
Files|https://docs.kernel.org/admin-guide/cgroup-v2.html#memory-interface-files>.

Units may have their children use a default C<memory.min> or
C<memory.low> value by specifying C<DefaultMemoryMin> or
C<DefaultMemoryLow>, which has the same semantics as
C<MemoryMin> and C<MemoryLow>, or C<DefaultStartupMemoryLow>
which has the same semantics as C<StartupMemoryLow>.
This setting does not affect C<memory.min> or C<memory.low>
in the unit itself.
Using it to set a default child allocation is only useful on kernels older than 5.7,
which do not support the C<memory_recursiveprot> cgroup2 mount option.

While C<StartupMemoryLow> applies to the startup and shutdown phases of the system,
C<MemoryMin> applies to normal runtime of the system, and if the former is not set also to
the startup and shutdown phases. Using C<StartupMemoryLow> allows prioritizing specific services at
boot-up and shutdown differently than during normal runtime. I< Optional. Type uniline.  > 

=head2 StartupMemoryLow

These settings control the C<memory> controller in the unified hierarchy.

Specify the memory usage protection of the executed processes in this unit.
When reclaiming memory, the unit is treated as if it was using less memory resulting in memory
to be preferentially reclaimed from unprotected units.
Using C<MemoryLow> results in a weaker protection where memory may still
be reclaimed to avoid invoking the OOM killer in case there is no other reclaimable memory.

For a protection to be effective, it is generally required to set a corresponding
allocation on all ancestors, which is then distributed between children
(with the exception of the root slice).
Any C<MemoryMin> or C<MemoryLow> allocation that is not
explicitly distributed to specific children is used to create a shared protection for all children.
As this is a shared protection, the children will freely compete for the memory.

Takes a memory size in bytes. If the value is suffixed with K, M, G or T, the specified memory size is
parsed as Kilobytes, Megabytes, Gigabytes, or Terabytes (with the base 1024), respectively. Alternatively, a
percentage value may be specified, which is taken relative to the installed physical memory on the
system. If assigned the special value C<infinity>, all available memory is protected, which may be
useful in order to always inherit all of the protection afforded by ancestors.
This controls the C<memory.min> or C<memory.low> control group attribute.
For details about this control group attribute, see L<Memory Interface
Files|https://docs.kernel.org/admin-guide/cgroup-v2.html#memory-interface-files>.

Units may have their children use a default C<memory.min> or
C<memory.low> value by specifying C<DefaultMemoryMin> or
C<DefaultMemoryLow>, which has the same semantics as
C<MemoryMin> and C<MemoryLow>, or C<DefaultStartupMemoryLow>
which has the same semantics as C<StartupMemoryLow>.
This setting does not affect C<memory.min> or C<memory.low>
in the unit itself.
Using it to set a default child allocation is only useful on kernels older than 5.7,
which do not support the C<memory_recursiveprot> cgroup2 mount option.

While C<StartupMemoryLow> applies to the startup and shutdown phases of the system,
C<MemoryMin> applies to normal runtime of the system, and if the former is not set also to
the startup and shutdown phases. Using C<StartupMemoryLow> allows prioritizing specific services at
boot-up and shutdown differently than during normal runtime. I< Optional. Type uniline.  > 

=head2 MemoryHigh

These settings control the C<memory> controller in the unified hierarchy.

Specify the throttling limit on memory usage of the executed processes in this unit. Memory usage may go
above the limit if unavoidable, but the processes are heavily slowed down and memory is taken away
aggressively in such cases. This is the main mechanism to control memory usage of a unit.

Takes a memory size in bytes. If the value is suffixed with K, M, G or T, the specified memory size is
parsed as Kilobytes, Megabytes, Gigabytes, or Terabytes (with the base 1024), respectively. Alternatively, a
percentage value may be specified, which is taken relative to the installed physical memory on the
system. If assigned the
special value C<infinity>, no memory throttling is applied. This controls the
C<memory.high> control group attribute. For details about this control group attribute, see
L<Memory Interface Files|https://docs.kernel.org/admin-guide/cgroup-v2.html#memory-interface-files>.
The effective configuration is reported as C<EffectiveMemoryHigh>
(see also C<EffectiveMemoryMax>).

While C<StartupMemoryHigh> applies to the startup and shutdown phases of the system,
C<MemoryHigh> applies to normal runtime of the system, and if the former is not set also to
the startup and shutdown phases. Using C<StartupMemoryHigh> allows prioritizing specific services at
boot-up and shutdown differently than during normal runtime. I< Optional. Type uniline.  > 

=head2 StartupMemoryHigh

These settings control the C<memory> controller in the unified hierarchy.

Specify the throttling limit on memory usage of the executed processes in this unit. Memory usage may go
above the limit if unavoidable, but the processes are heavily slowed down and memory is taken away
aggressively in such cases. This is the main mechanism to control memory usage of a unit.

Takes a memory size in bytes. If the value is suffixed with K, M, G or T, the specified memory size is
parsed as Kilobytes, Megabytes, Gigabytes, or Terabytes (with the base 1024), respectively. Alternatively, a
percentage value may be specified, which is taken relative to the installed physical memory on the
system. If assigned the
special value C<infinity>, no memory throttling is applied. This controls the
C<memory.high> control group attribute. For details about this control group attribute, see
L<Memory Interface Files|https://docs.kernel.org/admin-guide/cgroup-v2.html#memory-interface-files>.
The effective configuration is reported as C<EffectiveMemoryHigh>
(see also C<EffectiveMemoryMax>).

While C<StartupMemoryHigh> applies to the startup and shutdown phases of the system,
C<MemoryHigh> applies to normal runtime of the system, and if the former is not set also to
the startup and shutdown phases. Using C<StartupMemoryHigh> allows prioritizing specific services at
boot-up and shutdown differently than during normal runtime. I< Optional. Type uniline.  > 

=head2 MemoryMax

These settings control the C<memory> controller in the unified hierarchy.

Specify the absolute limit on memory usage of the executed processes in this unit. If memory usage
cannot be contained under the limit, out-of-memory killer is invoked inside the unit. It is recommended to
use C<MemoryHigh> as the main control mechanism and use C<MemoryMax> as the
last line of defense.

Takes a memory size in bytes. If the value is suffixed with K, M, G or T, the specified memory size is
parsed as Kilobytes, Megabytes, Gigabytes, or Terabytes (with the base 1024), respectively. Alternatively, a
percentage value may be specified, which is taken relative to the installed physical memory on the system. If
assigned the special value C<infinity>, no memory limit is applied. This controls the
C<memory.max> control group attribute. For details about this control group attribute, see
L<Memory Interface Files|https://docs.kernel.org/admin-guide/cgroup-v2.html#memory-interface-files>.
The effective configuration is reported as C<EffectiveMemoryMax> (the value is
the most stringent limit of the unit and parent slices and it is capped by physical memory).

While C<StartupMemoryMax> applies to the startup and shutdown phases of the system,
C<MemoryMax> applies to normal runtime of the system, and if the former is not set also to
the startup and shutdown phases. Using C<StartupMemoryMax> allows prioritizing specific services at
boot-up and shutdown differently than during normal runtime. I< Optional. Type uniline.  > 

=head2 StartupMemoryMax

These settings control the C<memory> controller in the unified hierarchy.

Specify the absolute limit on memory usage of the executed processes in this unit. If memory usage
cannot be contained under the limit, out-of-memory killer is invoked inside the unit. It is recommended to
use C<MemoryHigh> as the main control mechanism and use C<MemoryMax> as the
last line of defense.

Takes a memory size in bytes. If the value is suffixed with K, M, G or T, the specified memory size is
parsed as Kilobytes, Megabytes, Gigabytes, or Terabytes (with the base 1024), respectively. Alternatively, a
percentage value may be specified, which is taken relative to the installed physical memory on the system. If
assigned the special value C<infinity>, no memory limit is applied. This controls the
C<memory.max> control group attribute. For details about this control group attribute, see
L<Memory Interface Files|https://docs.kernel.org/admin-guide/cgroup-v2.html#memory-interface-files>.
The effective configuration is reported as C<EffectiveMemoryMax> (the value is
the most stringent limit of the unit and parent slices and it is capped by physical memory).

While C<StartupMemoryMax> applies to the startup and shutdown phases of the system,
C<MemoryMax> applies to normal runtime of the system, and if the former is not set also to
the startup and shutdown phases. Using C<StartupMemoryMax> allows prioritizing specific services at
boot-up and shutdown differently than during normal runtime. I< Optional. Type uniline.  > 

=head2 MemorySwapMax

These settings control the C<memory> controller in the unified hierarchy.

Specify the absolute limit on swap usage of the executed processes in this unit.

Takes a swap size in bytes. If the value is suffixed with K, M, G or T, the specified swap size is
parsed as Kilobytes, Megabytes, Gigabytes, or Terabytes (with the base 1024), respectively. Alternatively, a
percentage value may be specified, which is taken relative to the specified swap size on the system. If assigned the
special value C<infinity>, no swap limit is applied. These settings control the
C<memory.swap.max> control group attribute. For details about this control group attribute,
see L<Memory Interface Files|https://docs.kernel.org/admin-guide/cgroup-v2.html#memory-interface-files>.

While C<StartupMemorySwapMax> applies to the startup and shutdown phases of the system,
C<MemorySwapMax> applies to normal runtime of the system, and if the former is not set also to
the startup and shutdown phases. Using C<StartupMemorySwapMax> allows prioritizing specific services at
boot-up and shutdown differently than during normal runtime. I< Optional. Type uniline.  > 

=head2 StartupMemorySwapMax

These settings control the C<memory> controller in the unified hierarchy.

Specify the absolute limit on swap usage of the executed processes in this unit.

Takes a swap size in bytes. If the value is suffixed with K, M, G or T, the specified swap size is
parsed as Kilobytes, Megabytes, Gigabytes, or Terabytes (with the base 1024), respectively. Alternatively, a
percentage value may be specified, which is taken relative to the specified swap size on the system. If assigned the
special value C<infinity>, no swap limit is applied. These settings control the
C<memory.swap.max> control group attribute. For details about this control group attribute,
see L<Memory Interface Files|https://docs.kernel.org/admin-guide/cgroup-v2.html#memory-interface-files>.

While C<StartupMemorySwapMax> applies to the startup and shutdown phases of the system,
C<MemorySwapMax> applies to normal runtime of the system, and if the former is not set also to
the startup and shutdown phases. Using C<StartupMemorySwapMax> allows prioritizing specific services at
boot-up and shutdown differently than during normal runtime. I< Optional. Type uniline.  > 

=head2 MemoryZSwapMax

These settings control the C<memory> controller in the unified hierarchy.

Specify the absolute limit on zswap usage of the processes in this unit. Zswap is a lightweight compressed
cache for swap pages. It takes pages that are in the process of being swapped out and attempts to compress them into a
dynamically allocated RAM-based memory pool. If the limit specified is hit, no entries from this unit will be
stored in the pool until existing entries are faulted back or written out to disk. See the kernel's
L<Zswap|https://docs.kernel.org/admin-guide/mm/zswap.html> documentation for more details.

Takes a size in bytes. If the value is suffixed with K, M, G or T, the specified size is
parsed as Kilobytes, Megabytes, Gigabytes, or Terabytes (with the base 1024), respectively. If assigned the
special value C<infinity>, no limit is applied. These settings control the
C<memory.zswap.max> control group attribute. For details about this control group attribute,
see L<Memory Interface Files|https://docs.kernel.org/admin-guide/cgroup-v2.html#memory-interface-files>.

While C<StartupMemoryZSwapMax> applies to the startup and shutdown phases of the system,
C<MemoryZSwapMax> applies to normal runtime of the system, and if the former is not set also to
the startup and shutdown phases. Using C<StartupMemoryZSwapMax> allows prioritizing specific services at
boot-up and shutdown differently than during normal runtime. I< Optional. Type uniline.  > 

=head2 StartupMemoryZSwapMax

These settings control the C<memory> controller in the unified hierarchy.

Specify the absolute limit on zswap usage of the processes in this unit. Zswap is a lightweight compressed
cache for swap pages. It takes pages that are in the process of being swapped out and attempts to compress them into a
dynamically allocated RAM-based memory pool. If the limit specified is hit, no entries from this unit will be
stored in the pool until existing entries are faulted back or written out to disk. See the kernel's
L<Zswap|https://docs.kernel.org/admin-guide/mm/zswap.html> documentation for more details.

Takes a size in bytes. If the value is suffixed with K, M, G or T, the specified size is
parsed as Kilobytes, Megabytes, Gigabytes, or Terabytes (with the base 1024), respectively. If assigned the
special value C<infinity>, no limit is applied. These settings control the
C<memory.zswap.max> control group attribute. For details about this control group attribute,
see L<Memory Interface Files|https://docs.kernel.org/admin-guide/cgroup-v2.html#memory-interface-files>.

While C<StartupMemoryZSwapMax> applies to the startup and shutdown phases of the system,
C<MemoryZSwapMax> applies to normal runtime of the system, and if the former is not set also to
the startup and shutdown phases. Using C<StartupMemoryZSwapMax> allows prioritizing specific services at
boot-up and shutdown differently than during normal runtime. I< Optional. Type uniline.  > 

=head2 MemoryZSwapWriteback

This setting controls the C<memory> controller in the unified hierarchy.

Takes a boolean argument. When true, pages stored in the Zswap cache are permitted to be
written to the backing storage, false otherwise. Defaults to true. This allows disabling
writeback of swap pages for IO-intensive applications, while retaining the ability to store
compressed pages in Zswap. See the kernel's
L<Zswap|https://docs.kernel.org/admin-guide/mm/zswap.html> documentation
for more details. I< Optional. Type boolean.  > 

=over 4

=item upstream_default value :

yes

=back



=head2 AllowedMemoryNodes

These settings control the C<cpuset> controller in the unified hierarchy.

Restrict processes to be executed on specific memory NUMA nodes. Takes a list of memory NUMA nodes indices
or ranges separated by either whitespace or commas. Memory NUMA nodes ranges are specified by the lower and upper
NUMA nodes indices separated by a dash.

Setting C<AllowedMemoryNodes> or C<StartupAllowedMemoryNodes> does not
guarantee that all of the memory NUMA nodes will be used by the processes as it may be limited by parent units.
The effective configuration is reported as C<EffectiveMemoryNodes>.

While C<StartupAllowedMemoryNodes> applies to the startup and shutdown phases of the system,
C<AllowedMemoryNodes> applies to normal runtime of the system, and if the former is not set also to
the startup and shutdown phases. Using C<StartupAllowedMemoryNodes> allows prioritizing specific services at
boot-up and shutdown differently than during normal runtime.

This setting is supported only with the unified control group hierarchy. I< Optional. Type uniline.  > 

=head2 StartupAllowedMemoryNodes

These settings control the C<cpuset> controller in the unified hierarchy.

Restrict processes to be executed on specific memory NUMA nodes. Takes a list of memory NUMA nodes indices
or ranges separated by either whitespace or commas. Memory NUMA nodes ranges are specified by the lower and upper
NUMA nodes indices separated by a dash.

Setting C<AllowedMemoryNodes> or C<StartupAllowedMemoryNodes> does not
guarantee that all of the memory NUMA nodes will be used by the processes as it may be limited by parent units.
The effective configuration is reported as C<EffectiveMemoryNodes>.

While C<StartupAllowedMemoryNodes> applies to the startup and shutdown phases of the system,
C<AllowedMemoryNodes> applies to normal runtime of the system, and if the former is not set also to
the startup and shutdown phases. Using C<StartupAllowedMemoryNodes> allows prioritizing specific services at
boot-up and shutdown differently than during normal runtime.

This setting is supported only with the unified control group hierarchy. I< Optional. Type uniline.  > 

=head2 TasksAccounting

This setting controls the C<pids> controller in the unified hierarchy.

Turn on task accounting for this unit. Takes a boolean argument. If enabled, the kernel will
keep track of the total number of tasks in the unit and its children. This number includes both
kernel threads and userspace processes, with each thread counted individually. Note that turning on
tasks accounting for one unit will also implicitly turn it on for all units contained in the same
slice and for all its parent slices and the units contained therein. The system default for this
setting may be controlled with C<DefaultTasksAccounting> in
L<systemd-system.conf(5)>. I< Optional. Type boolean.  > 

=head2 TasksMax

This setting controls the C<pids> controller in the unified hierarchy.

Specify the maximum number of tasks that may be created in the unit. This ensures that the
number of tasks accounted for the unit (see above) stays below a specific limit. This either takes
an absolute number of tasks or a percentage value that is taken relative to the configured maximum
number of tasks on the system. If assigned the special value C<infinity>, no tasks
limit is applied. This controls the C<pids.max> control group attribute. For
details about this control group attribute, see the
L<pids controller|https://docs.kernel.org/admin-guide/cgroup-v2.html#pid>.
The effective configuration is reported as C<EffectiveTasksMax>.

The system default for this setting may be controlled with
C<DefaultTasksMax> in
L<systemd-system.conf(5)>. I< Optional. Type uniline.  > 

=head2 IOAccounting

This setting controls the C<io> controller in the unified hierarchy.

Turn on Block I/O accounting for this unit, if the unified control group hierarchy is used on the
system. Takes a boolean argument. Note that turning on block I/O accounting for one unit will also implicitly
turn it on for all units contained in the same slice and all for its parent slices and the units contained
therein. The system default for this setting may be controlled with C<DefaultIOAccounting>
in
L<systemd-system.conf(5)>. I< Optional. Type boolean.  > 

=head2 IOWeight

These settings control the C<io> controller in the unified hierarchy.

Set the default overall block I/O weight for the executed processes, if the unified control
group hierarchy is used on the system. Takes a single weight value (between 1 and 10000) to set the
default block I/O weight. This controls the C<io.weight> control group attribute,
which defaults to 100. For details about this control group attribute, see L<IO
Interface Files|https://docs.kernel.org/admin-guide/cgroup-v2.html#io-interface-files>.  The available I/O bandwidth is
split up among all units within one slice
relative to their block I/O weight. A higher weight means more I/O bandwidth, a lower weight means
less.

While C<StartupIOWeight> applies
to the startup and shutdown phases of the system,
C<IOWeight> applies to the later runtime of
the system, and if the former is not set also to the startup
and shutdown phases. This allows prioritizing specific services at boot-up
and shutdown differently than during runtime. I< Optional. Type uniline.  > 

=head2 StartupIOWeight

These settings control the C<io> controller in the unified hierarchy.

Set the default overall block I/O weight for the executed processes, if the unified control
group hierarchy is used on the system. Takes a single weight value (between 1 and 10000) to set the
default block I/O weight. This controls the C<io.weight> control group attribute,
which defaults to 100. For details about this control group attribute, see L<IO
Interface Files|https://docs.kernel.org/admin-guide/cgroup-v2.html#io-interface-files>.  The available I/O bandwidth is
split up among all units within one slice
relative to their block I/O weight. A higher weight means more I/O bandwidth, a lower weight means
less.

While C<StartupIOWeight> applies
to the startup and shutdown phases of the system,
C<IOWeight> applies to the later runtime of
the system, and if the former is not set also to the startup
and shutdown phases. This allows prioritizing specific services at boot-up
and shutdown differently than during runtime. I< Optional. Type uniline.  > 

=head2 IODeviceWeight

This setting controls the C<io> controller in the unified hierarchy.

Set the per-device overall block I/O weight for the executed processes, if the unified control group
hierarchy is used on the system. Takes a space-separated pair of a file path and a weight value to specify
the device specific weight value, between 1 and 10000. (Example: C</dev/sda 1000>). The file
path may be specified as path to a block device node or as any other file, in which case the backing block
device of the file system of the file is determined. This controls the C<io.weight> control
group attribute, which defaults to 100. Use this option multiple times to set weights for multiple devices.
For details about this control group attribute, see L<IO Interface
Files|https://docs.kernel.org/admin-guide/cgroup-v2.html#io-interface-files>.

The specified device node should reference a block device that has an I/O scheduler
associated, i.e. should not refer to partition or loopback block devices, but to the originating,
physical device. When a path to a regular file or directory is specified it is attempted to
discover the correct originating device backing the file system of the specified path. This works
correctly only for simpler cases, where the file system is directly placed on a partition or
physical block device, or where simple 1:1 encryption using dm-crypt/LUKS is used. This discovery
does not cover complex storage and in particular RAID and volume management storage devices. I< Optional. Type uniline.  > 

=head2 IOReadBandwidthMax

These settings control the C<io> controller in the unified hierarchy.

Set the per-device overall block I/O bandwidth maximum limit for the executed processes, if the unified
control group hierarchy is used on the system. This limit is not work-conserving and the executed processes
are not allowed to use more even if the device has idle capacity.  Takes a space-separated pair of a file
path and a bandwidth value (in bytes per second) to specify the device specific bandwidth. The file path may
be a path to a block device node, or as any other file in which case the backing block device of the file
system of the file is used. If the bandwidth is suffixed with K, M, G, or T, the specified bandwidth is
parsed as Kilobytes, Megabytes, Gigabytes, or Terabytes, respectively, to the base of 1000. (Example:
"/dev/disk/by-path/pci-0000:00:1f.2-scsi-0:0:0:0 5M"). This controls the C<io.max> control
group attributes. Use this option multiple times to set bandwidth limits for multiple devices. For details
about this control group attribute, see L<IO Interface
Files|https://docs.kernel.org/admin-guide/cgroup-v2.html#io-interface-files>.

Similar restrictions on block device discovery as for C<IODeviceWeight> apply, see above. I< Optional. Type uniline.  > 

=head2 IOWriteBandwidthMax

These settings control the C<io> controller in the unified hierarchy.

Set the per-device overall block I/O bandwidth maximum limit for the executed processes, if the unified
control group hierarchy is used on the system. This limit is not work-conserving and the executed processes
are not allowed to use more even if the device has idle capacity.  Takes a space-separated pair of a file
path and a bandwidth value (in bytes per second) to specify the device specific bandwidth. The file path may
be a path to a block device node, or as any other file in which case the backing block device of the file
system of the file is used. If the bandwidth is suffixed with K, M, G, or T, the specified bandwidth is
parsed as Kilobytes, Megabytes, Gigabytes, or Terabytes, respectively, to the base of 1000. (Example:
"/dev/disk/by-path/pci-0000:00:1f.2-scsi-0:0:0:0 5M"). This controls the C<io.max> control
group attributes. Use this option multiple times to set bandwidth limits for multiple devices. For details
about this control group attribute, see L<IO Interface
Files|https://docs.kernel.org/admin-guide/cgroup-v2.html#io-interface-files>.

Similar restrictions on block device discovery as for C<IODeviceWeight> apply, see above. I< Optional. Type uniline.  > 

=head2 IOReadIOPSMax

These settings control the C<io> controller in the unified hierarchy.

Set the per-device overall block I/O IOs-Per-Second maximum limit for the executed processes, if the
unified control group hierarchy is used on the system. This limit is not work-conserving and the executed
processes are not allowed to use more even if the device has idle capacity.  Takes a space-separated pair of
a file path and an IOPS value to specify the device specific IOPS. The file path may be a path to a block
device node, or as any other file in which case the backing block device of the file system of the file is
used. If the IOPS is suffixed with K, M, G, or T, the specified IOPS is parsed as KiloIOPS, MegaIOPS,
GigaIOPS, or TeraIOPS, respectively, to the base of 1000. (Example:
"/dev/disk/by-path/pci-0000:00:1f.2-scsi-0:0:0:0 1K"). This controls the C<io.max> control
group attributes. Use this option multiple times to set IOPS limits for multiple devices. For details about
this control group attribute, see L<IO Interface
Files|https://docs.kernel.org/admin-guide/cgroup-v2.html#io-interface-files>.

Similar restrictions on block device discovery as for C<IODeviceWeight> apply, see above. I< Optional. Type uniline.  > 

=head2 IOWriteIOPSMax

These settings control the C<io> controller in the unified hierarchy.

Set the per-device overall block I/O IOs-Per-Second maximum limit for the executed processes, if the
unified control group hierarchy is used on the system. This limit is not work-conserving and the executed
processes are not allowed to use more even if the device has idle capacity.  Takes a space-separated pair of
a file path and an IOPS value to specify the device specific IOPS. The file path may be a path to a block
device node, or as any other file in which case the backing block device of the file system of the file is
used. If the IOPS is suffixed with K, M, G, or T, the specified IOPS is parsed as KiloIOPS, MegaIOPS,
GigaIOPS, or TeraIOPS, respectively, to the base of 1000. (Example:
"/dev/disk/by-path/pci-0000:00:1f.2-scsi-0:0:0:0 1K"). This controls the C<io.max> control
group attributes. Use this option multiple times to set IOPS limits for multiple devices. For details about
this control group attribute, see L<IO Interface
Files|https://docs.kernel.org/admin-guide/cgroup-v2.html#io-interface-files>.

Similar restrictions on block device discovery as for C<IODeviceWeight> apply, see above. I< Optional. Type uniline.  > 

=head2 IODeviceLatencyTargetSec

This setting controls the C<io> controller in the unified hierarchy.

Set the per-device average target I/O latency for the executed processes, if the unified control group
hierarchy is used on the system. Takes a file path and a timespan separated by a space to specify
the device specific latency target. (Example: "/dev/sda 25ms"). The file path may be specified
as path to a block device node or as any other file, in which case the backing block device of the file
system of the file is determined. This controls the C<io.latency> control group
attribute. Use this option multiple times to set latency target for multiple devices. For details about this
control group attribute, see L<IO Interface
Files|https://docs.kernel.org/admin-guide/cgroup-v2.html#io-interface-files>.

Implies C<IOAccounting=yes>.

These settings are supported only if the unified control group hierarchy is used.

Similar restrictions on block device discovery as for C<IODeviceWeight> apply, see above. I< Optional. Type uniline.  > 

=head2 IPAccounting

Takes a boolean argument. If true, turns on IPv4 and IPv6 network traffic accounting for packets sent
or received by the unit. When this option is turned on, all IPv4 and IPv6 sockets created by any process of
the unit are accounted for.

When this option is used in socket units, it applies to all IPv4 and IPv6 sockets
associated with it (including both listening and connection sockets where this applies). Note that for
socket-activated services, this configuration setting and the accounting data of the service unit and the
socket unit are kept separate, and displayed separately. No propagation of the setting and the collected
statistics is done, in either direction. Moreover, any traffic sent or received on any of the socket unit's
sockets is accounted to the socket unit — and never to the service unit it might have activated, even if the
socket is used by it.

The system default for this setting may be controlled with C<DefaultIPAccounting> in
L<systemd-system.conf(5)>.

Note that this functionality is currently only available for system services, not for
per-user services. I< Optional. Type boolean.  > 

=head2 IPAddressAllow

Turn on network traffic filtering for IP packets sent and received over
C<AF_INET> and C<AF_INET6> sockets. Both directives take a
space separated list of IPv4 or IPv6 addresses, each optionally suffixed with an address prefix
length in bits after a C</> character. If the suffix is omitted, the address is
considered a host address, i.e. the filter covers the whole address (32 bits for IPv4, 128 bits for
IPv6).

The access lists configured with this option are applied to all sockets created by processes
of this unit (or in the case of socket units, associated with it). The lists are implicitly
combined with any lists configured for any of the parent slice units this unit might be a member
of. By default, both access lists are empty. Both ingress and egress traffic is filtered by these
settings. In case of ingress traffic the source IP address is checked against these access lists,
in case of egress traffic the destination IP address is checked. The following rules are applied in
turn:

In order to implement an allow-listing IP firewall, it is recommended to use a
C<IPAddressDeny>=C<any> setting on an upper-level slice unit
(such as the root slice C<-.slice> or the slice containing all system services
C<system.slice> – see
L<systemd.special(7)>
for details on these slice units), plus individual per-service C<IPAddressAllow>
lines permitting network access to relevant services, and only them.

Note that for socket-activated services, the IP access list configured on the socket unit
applies to all sockets associated with it directly, but not to any sockets created by the
ultimately activated services for it. Conversely, the IP access list configured for the service is
not applied to any sockets passed into the service via socket activation. Thus, it is usually a
good idea to replicate the IP access lists on both the socket and the service unit. Nevertheless,
it may make sense to maintain one list more open and the other one more restricted, depending on
the use case.

If these settings are used multiple times in the same unit the specified lists are combined. If an
empty string is assigned to these settings the specific access list is reset and all previous settings undone.

In place of explicit IPv4 or IPv6 address and prefix length specifications a small set of symbolic
names may be used. The following names are defined:

Note that these settings might not be supported on some systems (for example if eBPF control group
support is not enabled in the underlying kernel or container manager). These settings will have no effect in
that case. If compatibility with such systems is desired it is hence recommended to not exclusively rely on
them for IP security. I< Optional. Type uniline.  > 

=head2 IPAddressDeny

Turn on network traffic filtering for IP packets sent and received over
C<AF_INET> and C<AF_INET6> sockets. Both directives take a
space separated list of IPv4 or IPv6 addresses, each optionally suffixed with an address prefix
length in bits after a C</> character. If the suffix is omitted, the address is
considered a host address, i.e. the filter covers the whole address (32 bits for IPv4, 128 bits for
IPv6).

The access lists configured with this option are applied to all sockets created by processes
of this unit (or in the case of socket units, associated with it). The lists are implicitly
combined with any lists configured for any of the parent slice units this unit might be a member
of. By default, both access lists are empty. Both ingress and egress traffic is filtered by these
settings. In case of ingress traffic the source IP address is checked against these access lists,
in case of egress traffic the destination IP address is checked. The following rules are applied in
turn:

In order to implement an allow-listing IP firewall, it is recommended to use a
C<IPAddressDeny>=C<any> setting on an upper-level slice unit
(such as the root slice C<-.slice> or the slice containing all system services
C<system.slice> – see
L<systemd.special(7)>
for details on these slice units), plus individual per-service C<IPAddressAllow>
lines permitting network access to relevant services, and only them.

Note that for socket-activated services, the IP access list configured on the socket unit
applies to all sockets associated with it directly, but not to any sockets created by the
ultimately activated services for it. Conversely, the IP access list configured for the service is
not applied to any sockets passed into the service via socket activation. Thus, it is usually a
good idea to replicate the IP access lists on both the socket and the service unit. Nevertheless,
it may make sense to maintain one list more open and the other one more restricted, depending on
the use case.

If these settings are used multiple times in the same unit the specified lists are combined. If an
empty string is assigned to these settings the specific access list is reset and all previous settings undone.

In place of explicit IPv4 or IPv6 address and prefix length specifications a small set of symbolic
names may be used. The following names are defined:

Note that these settings might not be supported on some systems (for example if eBPF control group
support is not enabled in the underlying kernel or container manager). These settings will have no effect in
that case. If compatibility with such systems is desired it is hence recommended to not exclusively rely on
them for IP security. I< Optional. Type uniline.  > 

=head2 SocketBindAllow

Configures restrictions on the ability of unit processes to invoke L<bind(2)> on a
socket. Both allow and deny rules to be defined that restrict which addresses a socket may be bound
to.

bind-rule describes socket properties such as address-family,
transport-protocol and ip-ports.

bind-rule :=
{ [address-familyC<:>][transport-protocolC<:>][ip-ports] | C<any> }

address-family := { C<ipv4> | C<ipv6> }

transport-protocol := { C<tcp> | C<udp> }

ip-ports := { ip-port | ip-port-range }

An optional address-family expects C<ipv4> or C<ipv6> values.
If not specified, a rule will be matched for both IPv4 and IPv6 addresses and applied depending on other socket fields,
e.g. transport-protocol,
ip-port.

An optional transport-protocol expects C<tcp> or C<udp> transport protocol names.
If not specified, a rule will be matched for any transport protocol.

An optional ip-port value must lie within 1…65535 interval inclusively, i.e.
dynamic port C<0> is not allowed. A range of sequential ports is described by
ip-port-range := ip-port-lowC<->ip-port-high,
where ip-port-low is smaller than or equal to ip-port-high
and both are within 1…65535 inclusively.

A special value C<any> can be used to apply a rule to any address family, transport protocol and any port with a
positive value.

To allow multiple rules assign C<SocketBindAllow> or C<SocketBindDeny> multiple times.
To clear the existing assignments pass an empty C<SocketBindAllow> or C<SocketBindDeny>
assignment.

For each of C<SocketBindAllow> and C<SocketBindDeny>, maximum allowed number of assignments is
C<128>.

The feature is implemented with C<cgroup/bind4> and C<cgroup/bind6> cgroup-bpf hooks.

Note that these settings apply to any L<bind(2)>
system call invocation by the unit processes, regardless in which network namespace they are
placed. Or in other words: changing the network namespace is not a suitable mechanism for escaping
these restrictions on bind().

Examples:
    …
    # Allow binding IPv6 socket addresses with a port greater than or equal to 10000.
    [Service]
    SocketBindAllow=ipv6:10000-65535
    SocketBindDeny=any
    …
    # Allow binding IPv4 and IPv6 socket addresses with 1234 and 4321 ports.
    [Service]
    SocketBindAllow=1234
    SocketBindAllow=4321
    SocketBindDeny=any
    …
    # Deny binding IPv6 socket addresses.
    [Service]
    SocketBindDeny=ipv6
    …
    # Deny binding IPv4 and IPv6 socket addresses.
    [Service]
    SocketBindDeny=any
    …
    # Allow binding only over TCP
    [Service]
    SocketBindAllow=tcp
    SocketBindDeny=any
    …
    # Allow binding only over IPv6/TCP
    [Service]
    SocketBindAllow=ipv6:tcp
    SocketBindDeny=any
    …
    # Allow binding ports within 10000-65535 range over IPv4/UDP.
    [Service]
    SocketBindAllow=ipv4:udp:10000-65535
    SocketBindDeny=any
    …
I< Optional. Type uniline.  > 

=head2 SocketBindDeny

Configures restrictions on the ability of unit processes to invoke L<bind(2)> on a
socket. Both allow and deny rules to be defined that restrict which addresses a socket may be bound
to.

bind-rule describes socket properties such as address-family,
transport-protocol and ip-ports.

bind-rule :=
{ [address-familyC<:>][transport-protocolC<:>][ip-ports] | C<any> }

address-family := { C<ipv4> | C<ipv6> }

transport-protocol := { C<tcp> | C<udp> }

ip-ports := { ip-port | ip-port-range }

An optional address-family expects C<ipv4> or C<ipv6> values.
If not specified, a rule will be matched for both IPv4 and IPv6 addresses and applied depending on other socket fields,
e.g. transport-protocol,
ip-port.

An optional transport-protocol expects C<tcp> or C<udp> transport protocol names.
If not specified, a rule will be matched for any transport protocol.

An optional ip-port value must lie within 1…65535 interval inclusively, i.e.
dynamic port C<0> is not allowed. A range of sequential ports is described by
ip-port-range := ip-port-lowC<->ip-port-high,
where ip-port-low is smaller than or equal to ip-port-high
and both are within 1…65535 inclusively.

A special value C<any> can be used to apply a rule to any address family, transport protocol and any port with a
positive value.

To allow multiple rules assign C<SocketBindAllow> or C<SocketBindDeny> multiple times.
To clear the existing assignments pass an empty C<SocketBindAllow> or C<SocketBindDeny>
assignment.

For each of C<SocketBindAllow> and C<SocketBindDeny>, maximum allowed number of assignments is
C<128>.

The feature is implemented with C<cgroup/bind4> and C<cgroup/bind6> cgroup-bpf hooks.

Note that these settings apply to any L<bind(2)>
system call invocation by the unit processes, regardless in which network namespace they are
placed. Or in other words: changing the network namespace is not a suitable mechanism for escaping
these restrictions on bind().

Examples:
    …
    # Allow binding IPv6 socket addresses with a port greater than or equal to 10000.
    [Service]
    SocketBindAllow=ipv6:10000-65535
    SocketBindDeny=any
    …
    # Allow binding IPv4 and IPv6 socket addresses with 1234 and 4321 ports.
    [Service]
    SocketBindAllow=1234
    SocketBindAllow=4321
    SocketBindDeny=any
    …
    # Deny binding IPv6 socket addresses.
    [Service]
    SocketBindDeny=ipv6
    …
    # Deny binding IPv4 and IPv6 socket addresses.
    [Service]
    SocketBindDeny=any
    …
    # Allow binding only over TCP
    [Service]
    SocketBindAllow=tcp
    SocketBindDeny=any
    …
    # Allow binding only over IPv6/TCP
    [Service]
    SocketBindAllow=ipv6:tcp
    SocketBindDeny=any
    …
    # Allow binding ports within 10000-65535 range over IPv4/UDP.
    [Service]
    SocketBindAllow=ipv4:udp:10000-65535
    SocketBindDeny=any
    …
I< Optional. Type uniline.  > 

=head2 RestrictNetworkInterfaces

Takes a list of space-separated network interface names. This option restricts the network
interfaces that processes of this unit can use. By default, processes can only use the network interfaces
listed (allow-list). If the first character of the rule is C<~>, the effect is inverted:
the processes can only use network interfaces not listed (deny-list).

This option can appear multiple times, in which case the network interface names are merged. If the
empty string is assigned the set is reset, all prior assignments will have not effect.

If you specify both types of this option (i.e. allow-listing and deny-listing), the first encountered
will take precedence and will dictate the default action (allow vs deny). Then the next occurrences of this
option will add or delete the listed network interface names from the set, depending of its type and the
default action.

The loopback interface ("lo") is not treated in any special way, you have to configure it explicitly
in the unit file.

Example 1: allow-list


    RestrictNetworkInterfaces=eth1
    RestrictNetworkInterfaces=eth2

Programs in the unit will be only able to use the eth1 and eth2 network
interfaces.

Example 2: deny-list


    RestrictNetworkInterfaces=~eth1 eth2

Programs in the unit will be able to use any network interface but eth1 and eth2.

Example 3: mixed


    RestrictNetworkInterfaces=eth1 eth2
    RestrictNetworkInterfaces=~eth1

Programs in the unit will be only able to use the eth2 network interface.
I< Optional. Type uniline.  > 

=head2 NFTSet

This setting provides a method for integrating dynamic cgroup, user and group IDs into
firewall rules with L<NFT|https://netfilter.org/projects/nftables/index.html>
sets. The benefit of using this setting is to be able to use the IDs as selectors in firewall rules
easily and this in turn allows more fine grained filtering. NFT rules for cgroup matching use
numeric cgroup IDs, which change every time a service is restarted, making them hard to use in
systemd environment otherwise. Dynamic and random IDs used by C<DynamicUser> can
be also integrated with this setting.

This option expects a whitespace separated list of NFT set definitions. Each definition
consists of a colon-separated tuple of source type (one of C<cgroup>,
C<user> or C<group>), NFT address family (one of
C<arp>, C<bridge>, C<inet>, C<ip>,
C<ip6>, or C<netdev>), table name and set name. The names of tables
and sets must conform to lexical restrictions of NFT table names. The type of the element used in
the NFT filter must match the type implied by the directive (C<cgroup>,
C<user> or C<group>) as shown in the table below. When a control
group or a unit is realized, the corresponding ID will be appended to the NFT sets and it will be
be removed when the control group or unit is removed. systemd only inserts
elements to (or removes from) the sets, so the related NFT rules, tables and sets must be prepared
elsewhere in advance. Failures to manage the sets will be ignored.

If the firewall rules are reinstalled so that the contents of NFT sets are destroyed, command
systemctl daemon-reload can be used to refill the sets.

Example:

    [Unit]
    NFTSet=cgroup:inet:filter:my_service user:inet:filter:serviceuser


Corresponding NFT rules:

    table inet filter {
    set my_service {
    type cgroupsv2
    }
    set serviceuser {
    typeof meta skuid
    }
    chain x {
    socket cgroupv2 level 2 @my_service accept
    drop
    }
    chain y {
    meta skuid @serviceuser accept
    drop
    }
    }
I< Optional. Type uniline.  > 

=head2 IPIngressFilterPath

Add custom network traffic filters implemented as BPF programs, applying to all IP packets
sent and received over C<AF_INET> and C<AF_INET6> sockets.
Takes an absolute path to a pinned BPF program in the BPF virtual filesystem (C</sys/fs/bpf/>).

The filters configured with this option are applied to all sockets created by processes
of this unit (or in the case of socket units, associated with it). The filters are loaded in addition
to filters any of the parent slice units this unit might be a member of as well as any
C<IPAddressAllow> and C<IPAddressDeny> filters in any of these units.
By default, there are no filters specified.

If these settings are used multiple times in the same unit all the specified programs are attached. If an
empty string is assigned to these settings the program list is reset and all previous specified programs ignored.

If the path BPF_FS_PROGRAM_PATH in C<IPIngressFilterPath> assignment
is already being handled by C<BPFProgram> ingress hook, e.g.
C<BPFProgram>=C<ingress>:BPF_FS_PROGRAM_PATH,
the assignment will be still considered valid and the program will be attached to a cgroup. Same for
C<IPEgressFilterPath> path and C<egress> hook.

Note that for socket-activated services, the IP filter programs configured on the socket unit apply to
all sockets associated with it directly, but not to any sockets created by the ultimately activated services
for it. Conversely, the IP filter programs configured for the service are not applied to any sockets passed into
the service via socket activation. Thus, it is usually a good idea, to replicate the IP filter programs on both
the socket and the service unit, however it often makes sense to maintain one configuration more open and the other
one more restricted, depending on the use case.

Note that these settings might not be supported on some systems (for example if eBPF control group
support is not enabled in the underlying kernel or container manager). These settings will fail the service in
that case. If compatibility with such systems is desired it is hence recommended to attach your filter manually
(requires C<Delegate>=C<yes>) instead of using this setting. I< Optional. Type uniline.  > 

=head2 IPEgressFilterPath

Add custom network traffic filters implemented as BPF programs, applying to all IP packets
sent and received over C<AF_INET> and C<AF_INET6> sockets.
Takes an absolute path to a pinned BPF program in the BPF virtual filesystem (C</sys/fs/bpf/>).

The filters configured with this option are applied to all sockets created by processes
of this unit (or in the case of socket units, associated with it). The filters are loaded in addition
to filters any of the parent slice units this unit might be a member of as well as any
C<IPAddressAllow> and C<IPAddressDeny> filters in any of these units.
By default, there are no filters specified.

If these settings are used multiple times in the same unit all the specified programs are attached. If an
empty string is assigned to these settings the program list is reset and all previous specified programs ignored.

If the path BPF_FS_PROGRAM_PATH in C<IPIngressFilterPath> assignment
is already being handled by C<BPFProgram> ingress hook, e.g.
C<BPFProgram>=C<ingress>:BPF_FS_PROGRAM_PATH,
the assignment will be still considered valid and the program will be attached to a cgroup. Same for
C<IPEgressFilterPath> path and C<egress> hook.

Note that for socket-activated services, the IP filter programs configured on the socket unit apply to
all sockets associated with it directly, but not to any sockets created by the ultimately activated services
for it. Conversely, the IP filter programs configured for the service are not applied to any sockets passed into
the service via socket activation. Thus, it is usually a good idea, to replicate the IP filter programs on both
the socket and the service unit, however it often makes sense to maintain one configuration more open and the other
one more restricted, depending on the use case.

Note that these settings might not be supported on some systems (for example if eBPF control group
support is not enabled in the underlying kernel or container manager). These settings will fail the service in
that case. If compatibility with such systems is desired it is hence recommended to attach your filter manually
(requires C<Delegate>=C<yes>) instead of using this setting. I< Optional. Type uniline.  > 

=head2 BPFProgram

C<BPFProgram> allows attaching custom BPF programs to the cgroup of a
unit. (This generalizes the functionality exposed via C<IPEgressFilterPath> and
C<IPIngressFilterPath> for other hooks.)  Cgroup-bpf hooks in the form of BPF
programs loaded to the BPF filesystem are attached with cgroup-bpf attach flags determined by the
unit. For details about attachment types and flags see
L<C<bpf.h>|https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/plain/include/uapi/linux/bpf.h>. Also
refer to the general L<BPF documentation|https://docs.kernel.org/bpf/>.

The specification of BPF program consists of a pair of BPF program type and program path in
the file system, with C<:> as the separator:
type:program-path.

The BPF program type is equivalent to the BPF attach type used in
L<bpftool(8)>
It may be one of
C<egress>,
C<ingress>,
C<sock_create>,
C<sock_ops>,
C<device>,
C<bind4>,
C<bind6>,
C<connect4>,
C<connect6>,
C<post_bind4>,
C<post_bind6>,
C<sendmsg4>,
C<sendmsg6>,
C<sysctl>,
C<recvmsg4>,
C<recvmsg6>,
C<getsockopt>,
or C<setsockopt>.

The specified program path must be an absolute path referencing a BPF program inode in the
bpffs file system (which generally means it must begin with C</sys/fs/bpf/>). If
a specified program does not exist (i.e. has not been uploaded to the BPF subsystem of the kernel
yet), it will not be installed but unit activation will continue (a warning will be printed to the
logs).

Setting C<BPFProgram> to an empty value makes previous assignments
ineffective.

Multiple assignments of the same program type/path pair have the same effect as a single
assignment: the program will be attached just once.

If BPF C<egress> pinned to program-path path is already being
handled by C<IPEgressFilterPath>, C<BPFProgram>
assignment will be considered valid and C<BPFProgram> will be attached to a cgroup.
Similarly for C<ingress> hook and C<IPIngressFilterPath> assignment.

BPF programs passed with C<BPFProgram> are attached to the cgroup of a unit
with BPF attach flag C<multi>, that allows further attachments of the same
type within cgroup hierarchy topped by the unit cgroup.

Examples:
    BPFProgram=egress:/sys/fs/bpf/egress-hook
    BPFProgram=bind6:/sys/fs/bpf/sock-addr-hook
. I< Optional. Type uniline.  > 

=head2 DeviceAllow

Control access to specific device nodes by the executed processes. Takes two space-separated
strings: a device node specifier followed by a combination of C<r>,
C<w>, C<m> to control reading,
writing, or creation of the specific device nodes by the unit
(mknod), respectively. This functionality is implemented using eBPF
filtering.

When access to all physical devices should be disallowed,
C<PrivateDevices> may be used instead. See
L<systemd.exec(5)>.

The device node specifier is either a path to a device node in the file system, starting with
C</dev/>, or a string starting with either C<char-> or
C<block-> followed by a device group name, as listed in
C</proc/devices>. The latter is useful to allow-list all current and future
devices belonging to a specific device group at once. The device group is matched according to
filename globbing rules, you may hence use the C<*> and C<?>
wildcards. (Note that such globbing wildcards are not available for device node path
specifications!) In order to match device nodes by numeric major/minor, use device node paths in
the C</dev/char/> and C</dev/block/> directories. However,
matching devices by major/minor is generally not recommended as assignments are neither stable nor
portable between systems or different kernel versions.

Examples: C</dev/sda5> is a path to a device node, referring to an ATA or
SCSI block device. C<char-pts> and C<char-alsa> are specifiers for
all pseudo TTYs and all ALSA sound devices, respectively. C<char-cpu/*> is a
specifier matching all CPU related device groups.

Note that allow lists defined this way should only reference device groups which are
resolvable at the time the unit is started. Any device groups not resolvable then are not added to
the device allow list. In order to work around this limitation, consider extending service units
with a pair of After=modprobe@xyz.service and
Wants=modprobe@xyz.service lines that load the necessary kernel module
implementing the device group if missing.
Example:
    …
    [Unit]
    Wants=modprobe@loop.service
    After=modprobe@loop.service
    [Service]
    DeviceAllow=block-loop
    DeviceAllow=/dev/loop-control
    …
I< Optional. Type list of uniline.  > 

=head2 DevicePolicy


Control the policy for allowing device access:
I< Optional. Type enum. choice: 'auto', 'closed', 'strict'.  > 

=head2 Slice

The name of the slice unit to place the unit
in. Defaults to C<system.slice> for all
non-instantiated units of all unit types (except for slice
units themselves see below). Instance units are by default
placed in a subslice of C<system.slice>
that is named after the template name.

This option may be used to arrange systemd units in a
hierarchy of slices each of which might have resource
settings applied.

For units of type slice, the only accepted value for
this setting is the parent slice. Since the name of a slice
unit implies the parent slice, it is hence redundant to ever
set this parameter directly for slice units.

Special care should be taken when relying on the default slice assignment in templated service units
that have C<DefaultDependencies=no> set, see
L<systemd.service(5)>, section
"Default Dependencies" for details. I< Optional. Type uniline.  > 

=head2 Delegate

Turns on delegation of further resource control partitioning to processes of the unit. Units
where this is enabled may create and manage their own private subhierarchy of control groups below
the control group of the unit itself. For unprivileged services (i.e. those using the
C<User> setting) the unit's control group will be made accessible to the relevant
user.

When enabled the service manager will refrain from manipulating control groups or moving
processes below the unit's control group, so that a clear concept of ownership is established: the
control group tree at the level of the unit's control group and above (i.e. towards the root
control group) is owned and managed by the service manager of the host, while the control group
tree below the unit's control group is owned and managed by the unit itself.

Takes either a boolean argument or a (possibly empty) list of control group controller names.
If true, delegation is turned on, and all supported controllers are enabled for the unit, making
them available to the unit's processes for management. If false, delegation is turned off entirely
(and no additional controllers are enabled). If set to a list of controllers, delegation is turned
on, and the specified controllers are enabled for the unit. Assigning the empty string will enable
delegation, but reset the list of controllers, and all assignments prior to this will have no
effect. Note that additional controllers other than the ones specified might be made available as
well, depending on configuration of the containing slice unit or other units contained in it.
Defaults to false.

Note that controller delegation to less privileged code is only safe on the unified control
group hierarchy. Accordingly, access to the specified controllers will not be granted to
unprivileged services on the legacy hierarchy, even when requested.

Not all of these controllers are available on all kernels however, and some are specific to
the unified hierarchy while others are specific to the legacy hierarchy. Also note that the kernel
might support further controllers, which are not covered here yet, as delegation is either not
supported at all for them or not defined cleanly.

Note that because of the hierarchical nature of cgroup hierarchy, any controllers that are
delegated will be enabled for the parent and sibling units of the unit with delegation.

For further details on the delegation model consult L<Control Group APIs and
Delegation|https://systemd.io/CGROUP_DELEGATION>. I< Optional. Type uniline.  > 

=head2 DelegateSubgroup

Place unit processes in the specified subgroup of the unit's control group. Takes a valid
control group name (not a path!) as parameter, or an empty string to turn this feature
off. Defaults to off. The control group name must be usable as filename and avoid conflicts with
the kernel's control group attribute files (i.e. C<cgroup.procs> is not an
acceptable name, since the kernel exposes a native control group attribute file by that name). This
option has no effect unless control group delegation is turned on via C<Delegate>,
see above. Note that this setting only applies to "main" processes of a unit, i.e. for services to
C<ExecStart>, but not for C<ExecReload> and similar. If
delegation is enabled, the latter are always placed inside a subgroup named
C<.control>. The specified subgroup is automatically created (and potentially
ownership is passed to the unit's configured user/group) when a process is started in it.

This option is useful to avoid manually moving the invoked process into a subgroup after it
has been started. Since no processes should live in inner nodes of the control group tree it is
almost always necessary to run the main ("supervising") process of a unit that has delegation
turned on in a subgroup. I< Optional. Type uniline.  > 

=head2 DisableControllers

Disables controllers from being enabled for a unit's children. If a controller listed is
already in use in its subtree, the controller will be removed from the subtree. This can be used to
avoid configuration in child units from being able to implicitly or explicitly enable a controller.
Defaults to empty.

Multiple controllers may be specified, separated by spaces. You may also pass
C<DisableControllers> multiple times, in which case each new instance adds another controller
to disable. Passing C<DisableControllers> by itself with no controller name present resets
the disabled controller list.

It may not be possible to disable a controller after units have been started, if the unit or
any child of the unit in question delegates controllers to its children, as any delegated subtree
of the cgroup hierarchy is unmanaged by systemd. I< Optional. Type uniline.  > 

=head2 ManagedOOMSwap

Specifies how
L<systemd-oomd.service(8)>
will act on this unit's cgroups. Defaults to C<auto>.

When set to C<kill>, the unit becomes a candidate for monitoring by
systemd-oomd. If the cgroup passes the limits set by
L<oomd.conf(5)> or
the unit configuration, systemd-oomd will select a descendant cgroup and send
C<SIGKILL> to all of the processes under it. You can find more details on
candidates and kill behavior at
L<systemd-oomd.service(8)>
and
L<oomd.conf(5)>.

Setting either of these properties to C<kill> will also result in
C<After> and C<Wants> dependencies on
C<systemd-oomd.service> unless C<DefaultDependencies=no>.

When set to C<auto>, systemd-oomd will not actively use this
cgroup's data for monitoring and detection. However, if an ancestor cgroup has one of these
properties set to C<kill>, a unit with C<auto> can still be a candidate
for systemd-oomd to terminate. I< Optional. Type enum. choice: 'auto', 'kill'.  > 

=head2 ManagedOOMMemoryPressure

Specifies how
L<systemd-oomd.service(8)>
will act on this unit's cgroups. Defaults to C<auto>.

When set to C<kill>, the unit becomes a candidate for monitoring by
systemd-oomd. If the cgroup passes the limits set by
L<oomd.conf(5)> or
the unit configuration, systemd-oomd will select a descendant cgroup and send
C<SIGKILL> to all of the processes under it. You can find more details on
candidates and kill behavior at
L<systemd-oomd.service(8)>
and
L<oomd.conf(5)>.

Setting either of these properties to C<kill> will also result in
C<After> and C<Wants> dependencies on
C<systemd-oomd.service> unless C<DefaultDependencies=no>.

When set to C<auto>, systemd-oomd will not actively use this
cgroup's data for monitoring and detection. However, if an ancestor cgroup has one of these
properties set to C<kill>, a unit with C<auto> can still be a candidate
for systemd-oomd to terminate. I< Optional. Type enum. choice: 'auto', 'kill'.  > 

=head2 ManagedOOMMemoryPressureLimit

Overrides the default memory pressure limit set by
L<oomd.conf(5)> for
the cgroup of this unit. Takes a percentage value between 0% and 100%, inclusive. Defaults to 0%,
which means to use the default set by
L<oomd.conf(5)>.
This property is ignored unless C<ManagedOOMMemoryPressure>=C<kill>.
I< Optional. Type uniline.  > 

=head2 ManagedOOMMemoryPressureDurationSec

Overrides the default memory pressure duration set by
L<oomd.conf(5)> for
the cgroup of this unit. The specified value supports a time unit such as C<ms> or
C<μs>, see
L<systemd.time(7)>
for details on the permitted syntax. Must be set to either empty or a value of at least 1s. Defaults
to empty, which means to use the default set by
L<oomd.conf(5)>.
This property is ignored unless C<ManagedOOMMemoryPressure>=C<kill>.
I< Optional. Type uniline.  > 

=head2 ManagedOOMPreference

Allows deprioritizing or omitting this unit's cgroup as a candidate when
systemd-oomd needs to act. Requires support for extended attributes (see
L<xattr(7)>)
in order to use C<avoid> or C<omit>.

When calculating candidates to relieve swap usage, systemd-oomd will
only respect these extended attributes if the unit's cgroup is owned by root.

When calculating candidates to relieve memory pressure, systemd-oomd
will only respect these extended attributes if the unit's cgroup is owned by root, or if the
unit's cgroup owner, and the owner of the monitored ancestor cgroup are the same. For example,
if systemd-oomd is calculating candidates for C<-.slice>,
then extended attributes set on descendants of C</user.slice/user-1000.slice/user@1000.service/>
will be ignored because the descendants are owned by UID 1000, and C<-.slice>
is owned by UID 0. But, if calculating candidates for
C</user.slice/user-1000.slice/user@1000.service/>, then extended attributes set
on the descendants would be respected.

If this property is set to C<avoid>, the service manager will convey this to
systemd-oomd, which will only select this cgroup if there are no other viable
candidates.

If this property is set to C<omit>, the service manager will convey this to
systemd-oomd, which will ignore this cgroup as a candidate and will not perform
any actions on it.

It is recommended to use C<avoid> and C<omit> sparingly, as it
can adversely affect systemd-oomd's kill behavior. Also note that these extended
attributes are not applied recursively to cgroups under this unit's cgroup.

Defaults to C<none> which means systemd-oomd will rank this
unit's cgroup as defined in
L<systemd-oomd.service(8)>
and L<oomd.conf(5)>.
I< Optional. Type enum. choice: 'avoid', 'none', 'omit'.  > 

=head2 MemoryPressureWatch

Controls memory pressure monitoring for invoked processes. Takes a boolean or one of
C<auto> and C<skip>. If C<no>, tells the service not
to watch for memory pressure events, by setting the C<$MEMORY_PRESSURE_WATCH>
environment variable to the literal string C</dev/null>. If C<yes>,
tells the service to watch for memory pressure events. This enables memory accounting for the
service, and ensures the C<memory.pressure> cgroup attribute file is accessible for
reading and writing by the service's user. It then sets the C<$MEMORY_PRESSURE_WATCH>
environment variable for processes invoked by the unit to the file system path to this file. The
threshold information configured with C<MemoryPressureThresholdSec> is encoded in
the C<$MEMORY_PRESSURE_WRITE> environment variable. If the C<auto>
value is set the protocol is enabled if memory accounting is anyway enabled for the unit, and
disabled otherwise. If set to C<skip> the logic is neither enabled, nor disabled and
the two environment variables are not set.

Note that services are free to use the two environment variables, but it is unproblematic if
they ignore them. Memory pressure handling must be implemented individually in each service, and
usually means different things for different software. For further details on memory pressure
handling see L<Memory Pressure Handling in
systemd|https://systemd.io/MEMORY_PRESSURE>.

Services implemented using
L<sd-event(3)> may use
L<sd_event_add_memory_pressure(3)>
to watch for and handle memory pressure events.

If not explicit set, defaults to the C<DefaultMemoryPressureWatch> setting in
L<systemd-system.conf(5)>. I< Optional. Type enum. choice: 'auto', 'no', 'skip', 'yes'.  > 

=head2 MemoryPressureThresholdSec

Sets the memory pressure threshold time for memory pressure monitor as configured via
C<MemoryPressureWatch>. Specifies the maximum allocation latency before a memory
pressure event is signalled to the service, per 2s window. If not specified, defaults to the
C<DefaultMemoryPressureThresholdSec> setting in
L<systemd-system.conf(5)>
(which in turn defaults to 200ms). The specified value expects a time unit such as
C<ms> or C<μs>, see
L<systemd.time(7)> for
details on the permitted syntax. I< Optional. Type uniline.  > 

=head2 CoredumpReceive

Takes a boolean argument. This setting is used to enable coredump forwarding for containers
that belong to this unit's cgroup. Units with C<CoredumpReceive=yes> must also be configured
with C<Delegate=yes>. Defaults to false.

When systemd-coredump is handling a coredump for a process from a container,
if the container's leader process is a descendant of a cgroup with C<CoredumpReceive=yes>
and C<Delegate=yes>, then systemd-coredump will attempt to forward
the coredump to systemd-coredump within the container. See also
L<systemd-coredump(8)>. I< Optional. Type boolean.  > 

=over 4

=item upstream_default value :

no

=back



=head2 ExecSearchPath

Takes a colon separated list of absolute paths relative to which the executable
used by the C<Exec*=> (e.g. C<ExecStart>,
C<ExecStop>, etc.) properties can be found. C<ExecSearchPath>
overrides C<$PATH> if C<$PATH> is not supplied by the user through
C<Environment>, C<EnvironmentFile> or
C<PassEnvironment>. Assigning an empty string removes previous assignments
and setting C<ExecSearchPath> to a value multiple times will append
to the previous setting.
I< Optional. Type list of uniline.  > 

=head2 WorkingDirectory

Takes a directory path relative to the service's root directory specified by
C<RootDirectory>, or the special value C<~>. Sets the working directory for
executed processes. If set to C<~>, the home directory of the user specified in
C<User> is used. If not set, defaults to the root directory when systemd is running as a
system instance and the respective user's home directory if run as user. If the setting is prefixed with the
C<-> character, a missing working directory is not considered fatal. If
C<RootDirectory>/C<RootImage> is not set, then
C<WorkingDirectory> is relative to the root of the system running the service manager. Note
that setting this parameter might result in additional dependencies to be added to the unit (see
above). I< Optional. Type uniline.  > 

=head2 RootDirectory

Takes a directory path relative to the host's root directory (i.e. the root of the system
running the service manager). Sets the root directory for executed processes, with the L<pivot_root(2)>
or L<chroot(2)>
system call. If this is used, it must be ensured that the process binary and all its auxiliary files
are available in the new root. Note that setting this parameter might result in additional
dependencies to be added to the unit (see above).

The C<MountAPIVFS> and C<PrivateUsers> settings are particularly useful
in conjunction with C<RootDirectory>. For details, see below.

If C<RootDirectory>/C<RootImage> are used together with
C<NotifyAccess> the notification socket is automatically mounted from the host into
the root environment, to ensure the notification interface can work correctly.

Note that services using C<RootDirectory>/C<RootImage> will
not be able to log via the syslog or journal protocols to the host logging infrastructure, unless the
relevant sockets are mounted from the host, specifically:

The host's
L<os-release(5)>
file will be made available for the service (read-only) as
C</run/host/os-release>.
It will be updated automatically on soft reboot (see:
L<systemd-soft-reboot.service(8)>),
in case the service is configured to survive it. I< Optional. Type uniline.  > 

=head2 RootImage

Takes a path to a block device node or regular file as argument. This call is similar
to C<RootDirectory> however mounts a file system hierarchy from a block device node
or loopback file instead of a directory. The device node or file system image file needs to contain a
file system without a partition table, or a file system within an MBR/MS-DOS or GPT partition table
with only a single Linux-compatible partition, or a set of file systems within a GPT partition table
that follows the
L<Discoverable Partitions
Specification|https://uapi-group.org/specifications/specs/discoverable_partitions_specification>.

When C<DevicePolicy> is set to C<closed> or
C<strict>, or set to C<auto> and C<DeviceAllow> is
set, then this setting adds C</dev/loop-control> with C<rw> mode,
C<block-loop> and C<block-blkext> with C<rwm> mode
to C<DeviceAllow>. See
L<systemd.resource-control(5)>
for the details about C<DevicePolicy> or C<DeviceAllow>. Also, see
C<PrivateDevices> below, as it may change the setting of
C<DevicePolicy>.

Units making use of C<RootImage> automatically gain an
C<After> dependency on C<systemd-udevd.service>.

The host's
L<os-release(5)>
file will be made available for the service (read-only) as
C</run/host/os-release>.
It will be updated automatically on soft reboot (see:
L<systemd-soft-reboot.service(8)>),
in case the service is configured to survive it. I< Optional. Type uniline.  > 

=head2 RootImageOptions

Takes a comma-separated list of mount options that will be used on disk images specified by
C<RootImage>. Optionally a partition name can be prefixed, followed by colon, in
case the image has multiple partitions, otherwise partition name C<root> is implied.
Options for multiple partitions can be specified in a single line with space separators. Assigning an empty
string removes previous assignments. Duplicated options are ignored. For a list of valid mount options, please
refer to
L<mount(8)>.

Valid partition names follow the
L<Discoverable Partitions
Specification|https://uapi-group.org/specifications/specs/discoverable_partitions_specification>:
C<root>, C<usr>, C<home>, C<srv>,
C<esp>, C<xbootldr>, C<tmp>,
C<var>. I< Optional. Type uniline.  > 

=head2 RootEphemeral

Takes a boolean argument. If enabled, executed processes will run in an ephemeral
copy of the root directory or root image. The ephemeral copy is placed in
C</var/lib/systemd/ephemeral-trees/> while the service is active and is cleaned up
when the service is stopped or restarted. If C<RootDirectory> is used and the root
directory is a subvolume, the ephemeral copy will be created by making a snapshot of the subvolume.

To make sure making ephemeral copies can be made efficiently, the root directory or root image
should be located on the same filesystem as C</var/lib/systemd/ephemeral-trees/>.
When using C<RootEphemeral> with root directories,
L<btrfs(5)>
should be used as the filesystem and the root directory should ideally be a subvolume which
systemd can snapshot to make the ephemeral copy. For root images, a filesystem
with support for reflinks should be used to ensure an efficient ephemeral copy. I< Optional. Type boolean.  > 

=head2 RootHash

Takes a data integrity (dm-verity) root hash specified in hexadecimal, or the path to a file
containing a root hash in ASCII hexadecimal format. This option enables data integrity checks using dm-verity,
if the used image contains the appropriate integrity data (see above) or if C<RootVerity> is used.
The specified hash must match the root hash of integrity data, and is usually at least 256 bits (and hence 64
formatted hexadecimal characters) long (in case of SHA256 for example). If this option is not specified, but
the image file carries the C<user.verity.roothash> extended file attribute (see L<xattr(7)>), then the root
hash is read from it, also as formatted hexadecimal characters. If the extended file attribute is not found (or
is not supported by the underlying file system), but a file with the C<.roothash> suffix is
found next to the image file, bearing otherwise the same name (except if the image has the
C<.raw> suffix, in which case the root hash file must not have it in its name), the root hash
is read from it and automatically used, also as formatted hexadecimal characters.

If the disk image contains a separate C</usr/> partition it may also be
Verity protected, in which case the root hash may configured via an extended attribute
C<user.verity.usrhash> or a C<.usrhash> file adjacent to the disk
image. There's currently no option to configure the root hash for the C</usr/> file
system via the unit file directly. I< Optional. Type uniline.  > 

=head2 RootHashSignature

Takes a PKCS7 signature of the C<RootHash> option as a path to a
DER-encoded signature file, or as an ASCII base64 string encoding of a DER-encoded signature prefixed
by C<base64:>. The dm-verity volume will only be opened if the signature of the root
hash is valid and signed by a public key present in the kernel keyring. If this option is not
specified, but a file with the C<.roothash.p7s> suffix is found next to the image
file, bearing otherwise the same name (except if the image has the C<.raw> suffix,
in which case the signature file must not have it in its name), the signature is read from it and
automatically used.

If the disk image contains a separate C</usr/> partition it may also be
Verity protected, in which case the signature for the root hash may configured via a
C<.usrhash.p7s> file adjacent to the disk image. There's currently no option to
configure the root hash signature for the C</usr/> via the unit file
directly. I< Optional. Type uniline.  > 

=head2 RootVerity

Takes the path to a data integrity (dm-verity) file. This option enables data integrity checks
using dm-verity, if C<RootImage> is used and a root-hash is passed and if the used image itself
does not contain the integrity data. The integrity data must be matched by the root hash. If this option is not
specified, but a file with the C<.verity> suffix is found next to the image file, bearing otherwise
the same name (except if the image has the C<.raw> suffix, in which case the verity data file must
not have it in its name), the verity data is read from it and automatically used.

This option is supported only for disk images that contain a single file system, without an
enveloping partition table. Images that contain a GPT partition table should instead include both
root file system and matching Verity data in the same image, implementing the
L<Discoverable Partitions
Specification|https://uapi-group.org/specifications/specs/discoverable_partitions_specification>. I< Optional. Type uniline.  > 

=head2 RootImagePolicy

Takes an image policy string as per
L<systemd.image-policy(7)>
to use when mounting the disk images (DDI) specified in C<RootImage>,
C<MountImage>, C<ExtensionImage>, respectively. If not specified
the following policy string is the default for C<RootImagePolicy> and C<MountImagePolicy>:

    root=verity+signed+encrypted+unprotected+absent: \
    usr=verity+signed+encrypted+unprotected+absent: \
    home=encrypted+unprotected+absent: \
    srv=encrypted+unprotected+absent: \
    tmp=encrypted+unprotected+absent: \
    var=encrypted+unprotected+absent

The default policy for C<ExtensionImagePolicy> is:

    root=verity+signed+encrypted+unprotected+absent: \
    usr=verity+signed+encrypted+unprotected+absent
. I< Optional. Type uniline.  > 

=head2 MountImagePolicy

Takes an image policy string as per
L<systemd.image-policy(7)>
to use when mounting the disk images (DDI) specified in C<RootImage>,
C<MountImage>, C<ExtensionImage>, respectively. If not specified
the following policy string is the default for C<RootImagePolicy> and C<MountImagePolicy>:

    root=verity+signed+encrypted+unprotected+absent: \
    usr=verity+signed+encrypted+unprotected+absent: \
    home=encrypted+unprotected+absent: \
    srv=encrypted+unprotected+absent: \
    tmp=encrypted+unprotected+absent: \
    var=encrypted+unprotected+absent

The default policy for C<ExtensionImagePolicy> is:

    root=verity+signed+encrypted+unprotected+absent: \
    usr=verity+signed+encrypted+unprotected+absent
. I< Optional. Type uniline.  > 

=head2 ExtensionImagePolicy

Takes an image policy string as per
L<systemd.image-policy(7)>
to use when mounting the disk images (DDI) specified in C<RootImage>,
C<MountImage>, C<ExtensionImage>, respectively. If not specified
the following policy string is the default for C<RootImagePolicy> and C<MountImagePolicy>:

    root=verity+signed+encrypted+unprotected+absent: \
    usr=verity+signed+encrypted+unprotected+absent: \
    home=encrypted+unprotected+absent: \
    srv=encrypted+unprotected+absent: \
    tmp=encrypted+unprotected+absent: \
    var=encrypted+unprotected+absent

The default policy for C<ExtensionImagePolicy> is:

    root=verity+signed+encrypted+unprotected+absent: \
    usr=verity+signed+encrypted+unprotected+absent
. I< Optional. Type uniline.  > 

=head2 MountAPIVFS

Takes a boolean argument. If on, a private mount namespace for the unit's processes is created
and the API file systems C</proc/>, C</sys/>, C</dev/> and
C</run/> (as an empty C<tmpfs>) are mounted inside of it, unless they are
already mounted. Note that this option has no effect unless used in conjunction with
C<RootDirectory>/C<RootImage> as these four mounts are
generally mounted in the host anyway, and unless the root directory is changed, the private mount namespace
will be a 1:1 copy of the host's, and include these four mounts. Note that the C</dev/> file
system of the host is bind mounted if this option is used without C<PrivateDevices>. To run
the service with a private, minimal version of C</dev/>, combine this option with
C<PrivateDevices>.

In order to allow propagating mounts at runtime in a safe manner, C</run/systemd/propagate/>
on the host will be used to set up new mounts, and C</run/host/incoming/> in the private namespace
will be used as an intermediate step to store them before being moved to the final mount point. I< Optional. Type boolean.  > 

=head2 BindLogSockets

Takes a boolean argument. If true, sockets from L<systemd-journald.socket(8)>
will be bind mounted into the mount namespace. This is particularly useful when a different instance
of C</run/> is employed, to make sure processes running in the namespace
can still make use of L<sd-journal(3)>.

This option is implied when C<LogNamespace> is used,
when C<MountAPIVFS=yes>, or when C<PrivateDevices=yes> is used
in conjunction with either C<RootDirectory> or C<RootImage>. I< Optional. Type boolean.  > 

=head2 ProtectProc

Takes one of C<noaccess>, C<invisible>,
C<ptraceable> or C<default> (which it defaults to). When set, this
controls the C<hidepid=> mount option of the C<procfs> instance for
the unit that controls which directories with process metainformation
(C</proc/PID>) are visible and accessible: when set to
C<noaccess> the ability to access most of other users' process metadata in
C</proc/> is taken away for processes of the service. When set to
C<invisible> processes owned by other users are hidden from
C</proc/>. If C<ptraceable> all processes that cannot be
ptrace()'ed by a process are hidden to it. If C<default> no
restrictions on C</proc/> access or visibility are made. For further details see
L<The /proc
Filesystem|https://docs.kernel.org/filesystems/proc.html#mount-options>. It is generally recommended to run most system
services with this option set to
C<invisible>. This option is implemented via file system namespacing, and thus cannot
be used with services that shall be able to install mount points in the host file system
hierarchy. Note that the root user is unaffected by this option, so to be effective it has to be used
together with C<User> or C<DynamicUser=yes>, and also without the
C<CAP_SYS_PTRACE> capability, which also allows a process to bypass this feature. It
cannot be used for services that need to access metainformation about other users' processes. This
option implies C<MountAPIVFS>.

If the kernel does not support per-mount point C<hidepid=> mount options this
setting remains without effect, and the unit's processes will be able to access and see other process
as if the option was not used. I< Optional. Type enum. choice: 'default', 'invisible', 'noaccess', 'ptraceable'.  > 

=head2 ProcSubset

Takes one of C<all> (the default) and C<pid>. If
C<pid>, all files and directories not directly associated with process management and
introspection are made invisible in the C</proc/> file system configured for the
unit's processes. This controls the C<subset=> mount option of the
C<procfs> instance for the unit. For further details see L<The /proc
Filesystem|https://docs.kernel.org/filesystems/proc.html#mount-options>. Note that Linux exposes various kernel APIs
via C</proc/>,
which are made unavailable with this setting. Since these APIs are used frequently this option is
useful only in a few, specific cases, and is not suitable for most non-trivial programs.

Much like C<ProtectProc> above, this is implemented via file system mount
namespacing, and hence the same restrictions apply: it is only available to system services, it
disables mount propagation to the host mount table, and it implies
C<MountAPIVFS>. Also, like C<ProtectProc> this setting is gracefully
disabled if the used kernel does not support the C<subset=> mount option of
C<procfs>. I< Optional. Type enum. choice: 'all', 'pid'.  > 

=head2 BindPaths

Configures unit-specific bind mounts. A bind mount makes a particular file or directory
available at an additional place in the unit's view of the file system. Any bind mounts created with this
option are specific to the unit, and are not visible in the host's mount table. This option expects a
whitespace separated list of bind mount definitions. Each definition consists of a colon-separated triple of
source path, destination path and option string, where the latter two are optional. If only a source path is
specified the source and destination is taken to be the same. The option string may be either
C<rbind> or C<norbind> for configuring a recursive or non-recursive bind
mount. If the destination path is omitted, the option string must be omitted too.
Each bind mount definition may be prefixed with C<->, in which case it will be ignored
when its source path does not exist.

C<BindPaths> creates regular writable bind mounts (unless the source file system mount
is already marked read-only), while C<BindReadOnlyPaths> creates read-only bind mounts. These
settings may be used more than once, each usage appends to the unit's list of bind mounts. If the empty string
is assigned to either of these two options the entire list of bind mounts defined prior to this is reset. Note
that, in this case, both read-only and regular bind mounts are reset, regardless which of the two settings is
used.

Using this option implies that a mount namespace is allocated for the unit, i.e. it implies the
effect of C<PrivateMounts> (see below).

This option is particularly useful when C<RootDirectory>/C<RootImage>
is used. In this case, the source path refers to a path on the host file system, while the destination path
refers to a path below the root directory of the unit.

Note that the destination directory must exist or systemd must be able to create it. Thus, it
is not possible to use those options for mount points nested underneath paths specified in
C<InaccessiblePaths>, or under C</home/> and other protected
directories if C<ProtectHome=yes> is
specified. C<TemporaryFileSystem> with C<:ro> or
C<ProtectHome=tmpfs> should be used instead. I< Optional. Type list of uniline.  > 

=head2 BindReadOnlyPaths

Configures unit-specific bind mounts. A bind mount makes a particular file or directory
available at an additional place in the unit's view of the file system. Any bind mounts created with this
option are specific to the unit, and are not visible in the host's mount table. This option expects a
whitespace separated list of bind mount definitions. Each definition consists of a colon-separated triple of
source path, destination path and option string, where the latter two are optional. If only a source path is
specified the source and destination is taken to be the same. The option string may be either
C<rbind> or C<norbind> for configuring a recursive or non-recursive bind
mount. If the destination path is omitted, the option string must be omitted too.
Each bind mount definition may be prefixed with C<->, in which case it will be ignored
when its source path does not exist.

C<BindPaths> creates regular writable bind mounts (unless the source file system mount
is already marked read-only), while C<BindReadOnlyPaths> creates read-only bind mounts. These
settings may be used more than once, each usage appends to the unit's list of bind mounts. If the empty string
is assigned to either of these two options the entire list of bind mounts defined prior to this is reset. Note
that, in this case, both read-only and regular bind mounts are reset, regardless which of the two settings is
used.

Using this option implies that a mount namespace is allocated for the unit, i.e. it implies the
effect of C<PrivateMounts> (see below).

This option is particularly useful when C<RootDirectory>/C<RootImage>
is used. In this case, the source path refers to a path on the host file system, while the destination path
refers to a path below the root directory of the unit.

Note that the destination directory must exist or systemd must be able to create it. Thus, it
is not possible to use those options for mount points nested underneath paths specified in
C<InaccessiblePaths>, or under C</home/> and other protected
directories if C<ProtectHome=yes> is
specified. C<TemporaryFileSystem> with C<:ro> or
C<ProtectHome=tmpfs> should be used instead. I< Optional. Type list of uniline.  > 

=head2 MountImages

This setting is similar to C<RootImage> in that it mounts a file
system hierarchy from a block device node or loopback file, but the destination directory can be
specified as well as mount options. This option expects a whitespace separated list of mount
definitions. Each definition consists of a colon-separated tuple of source path and destination
definitions, optionally followed by another colon and a list of mount options.

Mount options may be defined as a single comma-separated list of options, in which case they
will be implicitly applied to the root partition on the image, or a series of colon-separated tuples
of partition name and mount options. Valid partition names and mount options are the same as for
C<RootImageOptions> setting described above.

Each mount definition may be prefixed with C<->, in which case it will be
ignored when its source path does not exist. The source argument is a path to a block device node or
regular file. If source or destination contain a C<:>, it needs to be escaped as
C<\:>. The device node or file system image file needs to follow the same rules as
specified for C<RootImage>. Any mounts created with this option are specific to the
unit, and are not visible in the host's mount table.

These settings may be used more than once, each usage appends to the unit's list of mount
paths. If the empty string is assigned, the entire list of mount paths defined prior to this is
reset.

Note that the destination directory must exist or systemd must be able to create it. Thus, it
is not possible to use those options for mount points nested underneath paths specified in
C<InaccessiblePaths>, or under C</home/> and other protected
directories if C<ProtectHome=yes> is specified.

When C<DevicePolicy> is set to C<closed> or
C<strict>, or set to C<auto> and C<DeviceAllow> is
set, then this setting adds C</dev/loop-control> with C<rw> mode,
C<block-loop> and C<block-blkext> with C<rwm> mode
to C<DeviceAllow>. See
L<systemd.resource-control(5)>
for the details about C<DevicePolicy> or C<DeviceAllow>. Also, see
C<PrivateDevices> below, as it may change the setting of
C<DevicePolicy>. I< Optional. Type list of uniline.  > 

=head2 ExtensionImages

This setting is similar to C<MountImages> in that it mounts a file
system hierarchy from a block device node or loopback file, but instead of providing a destination
path, an overlay will be set up. This option expects a whitespace separated list of mount
definitions. Each definition consists of a source path, optionally followed by a colon and a list of
mount options.

A read-only OverlayFS will be set up on top of C</usr/> and
C</opt/> hierarchies for sysext images and C</etc/>
hierarchy for confext images. The order in which the images are listed will determine the
order in which the overlay is laid down: images specified first to last will result in overlayfs
layers bottom to top.

Mount options may be defined as a single comma-separated list of options, in which case they
will be implicitly applied to the root partition on the image, or a series of colon-separated tuples
of partition name and mount options. Valid partition names and mount options are the same as for
C<RootImageOptions> setting described above.

Each mount definition may be prefixed with C<->, in which case it will be
ignored when its source path does not exist. The source argument is a path to a block device node or
regular file. If the source path contains a C<:>, it needs to be escaped as
C<\:>. The device node or file system image file needs to follow the same rules as
specified for C<RootImage>. Any mounts created with this option are specific to the
unit, and are not visible in the host's mount table.

These settings may be used more than once, each usage appends to the unit's list of image
paths. If the empty string is assigned, the entire list of mount paths defined prior to this is
reset.

Each sysext image must carry a C</usr/lib/extension-release.d/extension-release.IMAGE>
file while each confext image must carry a C</etc/extension-release.d/extension-release.IMAGE>
file, with the appropriate metadata which matches C<RootImage>/C<RootDirectory>
or the host. See:
L<os-release(5)>.
To disable the safety check that the extension-release file name matches the image file name, the
C<x-systemd.relax-extension-release-check> mount option may be appended.

This option can be used together with a C<notify-reload> service type and
L<systemd.v(7)>
to manage configuration updates. When such a service carrying confext images is reloaded via
systemctl reload foo.service or equivalent D-Bus method, the confext itself will
be reloaded to pick up any changes. This only applies to confext extensions. Note that in case a
service has this configuration enabled at first, and then it is subsequently removed in an update
followed by a daemon-reload operation, reloading the confexts will be a no-op, and a full service
restart is required instead. See
L<systemd.service(5)>
also for details.

When C<DevicePolicy> is set to C<closed> or
C<strict>, or set to C<auto> and C<DeviceAllow> is
set, then this setting adds C</dev/loop-control> with C<rw> mode,
C<block-loop> and C<block-blkext> with C<rwm> mode
to C<DeviceAllow>. See
L<systemd.resource-control(5)>
for the details about C<DevicePolicy> or C<DeviceAllow>. Also, see
C<PrivateDevices> below, as it may change the setting of
C<DevicePolicy>. I< Optional. Type list of uniline.  > 

=head2 ExtensionDirectories

This setting is similar to C<BindReadOnlyPaths> in that it mounts a file
system hierarchy from a directory, but instead of providing a destination path, an overlay will be set
up. This option expects a whitespace separated list of source directories.

A read-only OverlayFS will be set up on top of C</usr/> and
C</opt/> hierarchies for sysext images and C</etc/>
hierarchy for confext images. The order in which the directories are listed will determine
the order in which the overlay is laid down: directories specified first to last will result in overlayfs
layers bottom to top.

Each directory listed in C<ExtensionDirectories> may be prefixed with C<->,
in which case it will be ignored when its source path does not exist. Any mounts created with this option are
specific to the unit, and are not visible in the host's mount table.

These settings may be used more than once, each usage appends to the unit's list of directories
paths. If the empty string is assigned, the entire list of mount paths defined prior to this is
reset.

Each sysext directory must contain a C</usr/lib/extension-release.d/extension-release.IMAGE>
file while each confext directory must carry a C</etc/extension-release.d/extension-release.IMAGE>
file, with the appropriate metadata which matches C<RootImage>/C<RootDirectory>
or the host. See:
L<os-release(5)>.

This option can be used together with a C<notify-reload> service type and
L<systemd.v(7)>
to manage configuration updates. When such a service carrying confext directories is reloaded via
systemctl reload foo.service or equivalent D-Bus method, the confext itself will
be reloaded to pick up any changes. This only applies to confext extensions. Note that in case a
service has this configuration enabled at first, and then it is subsequently removed in an update
followed by a daemon-reload operation, reloading the confexts will be a no-op, and a full service
restart is required instead. See
L<systemd.service(5)>
also for details.

Note that usage from user units requires overlayfs support in unprivileged user namespaces,
which was first introduced in kernel v5.11. I< Optional. Type list of uniline.  > 

=head2 User

Set the UNIX user or group that the processes are executed as, respectively. Takes a single
user or group name, or a numeric ID as argument. For system services (services run by the system service
manager, i.e. managed by PID 1) and for user services of the root user (services managed by root's instance of
systemd --user), the default is C<root>, but C<User> may be
used to specify a different user. For user services of any other user, switching user identity is not
permitted, hence the only valid setting is the same user the user's service manager is running as. If no group
is set, the default group of the user is used. This setting does not affect commands whose command line is
prefixed with C<+>.

Note that this enforces only weak restrictions on the user/group name syntax, but will generate
warnings in many cases where user/group names do not adhere to the following rules: the specified
name should consist only of the characters a-z, A-Z, 0-9, C<_> and
C<->, except for the first character which must be one of a-z, A-Z and
C<_> (i.e. digits and C<-> are not permitted as first character). The
user/group name must have at least one character, and at most 31. These restrictions are made in
order to avoid ambiguities and to ensure user/group names and unit files remain portable among Linux
systems. For further details on the names accepted and the names warned about see L<User/Group Name
Syntax|https://systemd.io/USER_NAMES>.

When used in conjunction with C<DynamicUser> the user/group name specified is
dynamically allocated at the time the service is started, and released at the time the service is
stopped — unless it is already allocated statically (see below). If C<DynamicUser>
is not used the specified user and group must have been created statically in the user database no
later than the moment the service is started, for example using the
L<sysusers.d(5)>
facility, which is applied at boot or package install time. If the user does not exist by then
program invocation will fail.

If the C<User> setting is used the supplementary group list is initialized
from the specified user's default group list, as defined in the system's user and group
database. Additional groups may be configured through the C<SupplementaryGroups>
setting (see below). I< Optional. Type uniline.  > 

=head2 Group

Set the UNIX user or group that the processes are executed as, respectively. Takes a single
user or group name, or a numeric ID as argument. For system services (services run by the system service
manager, i.e. managed by PID 1) and for user services of the root user (services managed by root's instance of
systemd --user), the default is C<root>, but C<User> may be
used to specify a different user. For user services of any other user, switching user identity is not
permitted, hence the only valid setting is the same user the user's service manager is running as. If no group
is set, the default group of the user is used. This setting does not affect commands whose command line is
prefixed with C<+>.

Note that this enforces only weak restrictions on the user/group name syntax, but will generate
warnings in many cases where user/group names do not adhere to the following rules: the specified
name should consist only of the characters a-z, A-Z, 0-9, C<_> and
C<->, except for the first character which must be one of a-z, A-Z and
C<_> (i.e. digits and C<-> are not permitted as first character). The
user/group name must have at least one character, and at most 31. These restrictions are made in
order to avoid ambiguities and to ensure user/group names and unit files remain portable among Linux
systems. For further details on the names accepted and the names warned about see L<User/Group Name
Syntax|https://systemd.io/USER_NAMES>.

When used in conjunction with C<DynamicUser> the user/group name specified is
dynamically allocated at the time the service is started, and released at the time the service is
stopped — unless it is already allocated statically (see below). If C<DynamicUser>
is not used the specified user and group must have been created statically in the user database no
later than the moment the service is started, for example using the
L<sysusers.d(5)>
facility, which is applied at boot or package install time. If the user does not exist by then
program invocation will fail.

If the C<User> setting is used the supplementary group list is initialized
from the specified user's default group list, as defined in the system's user and group
database. Additional groups may be configured through the C<SupplementaryGroups>
setting (see below). I< Optional. Type uniline.  > 

=head2 DynamicUser

Takes a boolean parameter. If set, a UNIX user and group pair is allocated
dynamically when the unit is started, and released as soon as it is stopped. The user and group will
not be added to C</etc/passwd> or C</etc/group>, but are managed
transiently during runtime. The
L<nss-systemd(8)> glibc
NSS module provides integration of these dynamic users/groups into the system's user and group
databases. The user and group name to use may be configured via C<User> and
C<Group> (see above). If these options are not used and dynamic user/group
allocation is enabled for a unit, the name of the dynamic user/group is implicitly derived from the
unit name. If the unit name without the type suffix qualifies as valid user name it is used directly,
otherwise a name incorporating a hash of it is used. If a statically allocated user or group of the
configured name already exists, it is used and no dynamic user/group is allocated. Note that if
C<User> is specified and the static group with the name exists, then it is required
that the static user with the name already exists. Similarly, if C<Group> is
specified and the static user with the name exists, then it is required that the static group with
the name already exists. Dynamic users/groups are allocated from the UID/GID range 61184…65519. It is
recommended to avoid this range for regular system or login users. At any point in time each UID/GID
from this range is only assigned to zero or one dynamically allocated users/groups in use. However,
UID/GIDs are recycled after a unit is terminated. Care should be taken that any processes running as
part of a unit for which dynamic users/groups are enabled do not leave files or directories owned by
these users/groups around, as a different unit might get the same UID/GID assigned later on, and thus
gain access to these files or directories. If C<DynamicUser> is enabled,
C<RemoveIPC> is implied (and cannot be turned off). This ensures that the lifetime
of IPC objects and temporary files created by the executed processes is bound to the runtime of the
service, and hence the lifetime of the dynamic user/group. Since C</tmp/> and
C</var/tmp/> are usually the only world-writable directories on a system, unless
C<PrivateTmp> is manually set to C<true>, C<disconnected>
would be implied. This ensures that a unit making use of dynamic user/group allocation cannot
leave files around after unit termination. Furthermore
C<NoNewPrivileges> and C<RestrictSUIDSGID> are implicitly enabled
(and cannot be disabled), to ensure that processes invoked cannot take benefit or create SUID/SGID
files or directories. Moreover, C<ProtectSystem=strict> and
C<ProtectHome=read-only> are implied, thus prohibiting the service to write to
arbitrary file system locations. In order to allow the service to write to certain directories, they
have to be allow-listed using C<ReadWritePaths>, but care must be taken so that
UID/GID recycling does not create security issues involving files created by the service. Use
C<RuntimeDirectory> (see below) in order to assign a writable runtime directory to a
service, owned by the dynamic user/group and removed automatically when the unit is terminated. Use
C<StateDirectory>, C<CacheDirectory> and
C<LogsDirectory> in order to assign a set of writable directories for specific
purposes to the service in a way that they are protected from vulnerabilities due to UID reuse (see
below). If this option is enabled, care should be taken that the unit's processes do not get access
to directories outside of these explicitly configured and managed ones. Specifically, do not use
C<BindPaths> and be careful with C<AF_UNIX> file descriptor
passing for directory file descriptors, as this would permit processes to create files or directories
owned by the dynamic user/group that are not subject to the lifecycle and access guarantees of the
service. Note that this option is currently incompatible with D-Bus policies, thus a service using
this option may currently not allocate a D-Bus service name (note that this does not affect calling
into other D-Bus services). Defaults to off. I< Optional. Type boolean.  > 

=over 4

=item upstream_default value :

no

=back



=head2 SupplementaryGroups

Sets the supplementary Unix groups the processes are executed as. This takes a space-separated
list of group names or IDs. This option may be specified more than once, in which case all listed groups are
set as supplementary groups. When the empty string is assigned, the list of supplementary groups is reset, and
all assignments prior to this one will have no effect. In any way, this option does not override, but extends
the list of supplementary groups configured in the system group database for the user. This does not affect
commands prefixed with C<+>. I< Optional. Type list of uniline.  > 

=head2 SetLoginEnvironment

Takes a boolean parameter that controls whether to set the C<$HOME>,
C<$LOGNAME>, and C<$SHELL> environment variables. If not set, this
defaults to true if C<User>, C<DynamicUser> or
C<PAMName> are set, false otherwise. If set to true, the variables will always be
set for system services, i.e. even when the default user C<root> is used. If set to
false, the mentioned variables are not set by the service manager, no matter whether
C<User>, C<DynamicUser>, or C<PAMName> are used or
not. This option normally has no effect on services of the per-user service manager, since in that
case these variables are typically inherited from user manager's own environment anyway. I< Optional. Type boolean.  > 

=head2 PAMName

Sets the PAM service name to set up a session as. If set, the executed process will be
registered as a PAM session under the specified service name. This is only useful in conjunction with the
C<User> setting, and is otherwise ignored. If not set, no PAM session will be opened for the
executed processes. See L<pam(8)> for
details.

Note that for each unit making use of this option a PAM session handler process will be maintained as
part of the unit and stays around as long as the unit is active, to ensure that appropriate actions can be
taken when the unit and hence the PAM session terminates. This process is named C<(sd-pam)> and
is an immediate child process of the unit's main process.

Note that when this option is used for a unit it is very likely (depending on PAM configuration) that the
main unit process will be migrated to its own session scope unit when it is activated. This process will hence
be associated with two units: the unit it was originally started from (and for which
C<PAMName> was configured), and the session scope unit. Any child processes of that process
will however be associated with the session scope unit only. This has implications when used in combination
with C<NotifyAccess>=C<all>, as these child processes will not be able to affect
changes in the original unit through notification messages. These messages will be considered belonging to the
session scope unit and not the original unit. It is hence not recommended to use C<PAMName> in
combination with C<NotifyAccess>=C<all>.

If a PAM module interactively requests input (a password or suchlike) it will be attempted to
be read from a service credential (as configured via C<SetCredential>,
C<ImportCredential> and related calls) under the name
C<pam.authtok.pamservice>, where
pamservice is replaced by the PAM service name as configured with
C<PAMName>. (Note that the credential remains accessible for the runtime of the
service!) If no matching credential is set, the user is prompted for it interactively via the L<Password
Agent|https://systemd.io/PASSWORD_AGENTS> logic. I< Optional. Type uniline.  > 

=head2 CapabilityBoundingSet

Controls which capabilities to include in the capability bounding set for the
executed process. See L<capabilities(7)>
for details. Takes a whitespace-separated list of capability names,
e.g. C<CAP_SYS_ADMIN>, C<CAP_DAC_OVERRIDE>,
C<CAP_SYS_PTRACE>. Capabilities listed will be included in the bounding set, all
others are removed. If the list of capabilities is prefixed with C<~>, all but the
listed capabilities will be included, the effect of the assignment inverted. Note that this option
also affects the respective capabilities in the effective, permitted and inheritable capability
sets. If this option is not used, the capability bounding set is not modified on process execution,
hence no limits on the capabilities of the process are enforced. This option may appear more than
once, in which case the bounding sets are merged by C<OR>, or by
C<AND> if the lines are prefixed with C<~> (see below). If the
empty string is assigned to this option, the bounding set is reset to the empty capability set, and
all prior settings have no effect. If set to C<~> (without any further argument),
the bounding set is reset to the full set of available capabilities, also undoing any previous
settings. This does not affect commands prefixed with C<+>.

Use
L<systemd-analyze(1)>'s
capability command to retrieve a list of capabilities defined on the local
system.

Example: if a unit has the following,

    CapabilityBoundingSet=CAP_A CAP_B
    CapabilityBoundingSet=CAP_B CAP_C

then C<CAP_A>, C<CAP_B>, and
C<CAP_C> are set. If the second line is prefixed with
C<~>, e.g.,

    CapabilityBoundingSet=CAP_A CAP_B
    CapabilityBoundingSet=~CAP_B CAP_C

then, only C<CAP_A> is set. I< Optional. Type uniline.  > 

=head2 AmbientCapabilities

Controls which capabilities to include in the ambient capability set for the executed
process. Takes a whitespace-separated list of capability names, e.g. C<CAP_SYS_ADMIN>,
C<CAP_DAC_OVERRIDE>, C<CAP_SYS_PTRACE>. This option may appear more than
once, in which case the ambient capability sets are merged (see the above examples in
C<CapabilityBoundingSet>). If the list of capabilities is prefixed with C<~>,
all but the listed capabilities will be included, the effect of the assignment inverted. If the empty string is
assigned to this option, the ambient capability set is reset to the empty capability set, and all prior
settings have no effect. If set to C<~> (without any further argument), the ambient capability
set is reset to the full set of available capabilities, also undoing any previous settings. Note that adding
capabilities to the ambient capability set adds them to the process's inherited capability set.

Ambient capability sets are useful if you want to execute a process as a non-privileged user but
still want to give it some capabilities. Note that, in this case, option C<keep-caps>
is automatically added to C<SecureBits> to retain the capabilities over the user
change. C<AmbientCapabilities> does not affect commands prefixed with
C<+>. I< Optional. Type uniline.  > 

=head2 NoNewPrivileges

Takes a boolean argument. If true, ensures that the service process and all its
children can never gain new privileges through execve() (e.g. via setuid or
setgid bits, or filesystem capabilities). This is the simplest and most effective way to ensure that
a process and its children can never elevate privileges again. Defaults to false. In case the service
will be run in a new mount namespace anyway and SELinux is disabled, all file systems are mounted with
C<MS_NOSUID> flag. Also see L<No New Privileges Flag|https://docs.kernel.org/userspace-api/no_new_privs.html>.

Note that this setting only has an effect on the unit's processes themselves (or any processes
directly or indirectly forked off them). It has no effect on processes potentially invoked on request
of them through tools such as L<at(1)>,
L<crontab(1)>,
L<systemd-run(1)>, or
arbitrary IPC services. I< Optional. Type boolean.  > 

=over 4

=item upstream_default value :

no

=back



=head2 SecureBits

Controls the secure bits set for the executed process. Takes a space-separated combination of
options from the following list: C<keep-caps>, C<keep-caps-locked>,
C<no-setuid-fixup>, C<no-setuid-fixup-locked>, C<noroot>, and
C<noroot-locked>. This option may appear more than once, in which case the secure bits are
ORed. If the empty string is assigned to this option, the bits are reset to 0. This does not affect commands
prefixed with C<+>. See L<capabilities(7)> for
details. I< Optional. Type uniline.  > 

=head2 SELinuxContext

Set the SELinux security context of the executed process. If set, this will override the
automated domain transition. However, the policy still needs to authorize the transition. This directive is
ignored if SELinux is disabled. If prefixed by C<->, failing to set the SELinux
security context will be ignored, but it is still possible that the subsequent
execve() may fail if the policy does not allow the transition for the
non-overridden context. This does not affect commands prefixed with C<+>. See
L<setexeccon(3)>
for details. I< Optional. Type uniline.  > 

=head2 AppArmorProfile

Takes a profile name as argument. The process executed by the unit will switch to
this profile when started. Profiles must already be loaded in the kernel, or the unit will fail. If
prefixed by C<->, all errors will be ignored. This setting has no effect if AppArmor
is not enabled. This setting does not affect commands prefixed with C<+>. I< Optional. Type uniline.  > 

=head2 SmackProcessLabel

Takes a C<SMACK64> security label as argument. The process executed by the unit
will be started under this label and SMACK will decide whether the process is allowed to run or not, based on
it. The process will continue to run under the label specified here unless the executable has its own
C<SMACK64EXEC> label, in which case the process will transition to run under that label. When not
specified, the label that systemd is running under is used. This directive is ignored if SMACK is
disabled.

The value may be prefixed by C<->, in which case all errors will be ignored. An empty
value may be specified to unset previous assignments. This does not affect commands prefixed with
C<+>. I< Optional. Type uniline.  > 

=head2 LimitCPU

Set soft and hard limits on various resources for executed processes. See
L<setrlimit(2)> for
details on the process resource limit concept. Process resource limits may be specified in two formats:
either as single value to set a specific soft and hard limit to the same value, or as colon-separated
pair C<soft:hard> to set both limits individually
(e.g. C<LimitAS=4G:16G>).  Use the string C<infinity> to configure no
limit on a specific resource. The multiplicative suffixes K, M, G, T, P and E (to the base 1024) may
be used for resource limits measured in bytes (e.g. C<LimitAS=16G>). For the limits
referring to time values, the usual time units ms, s, min, h and so on may be used (see
L<systemd.time(7)> for
details). Note that if no time unit is specified for C<LimitCPU> the default unit of
seconds is implied, while for C<LimitRTTIME> the default unit of microseconds is
implied. Also, note that the effective granularity of the limits might influence their
enforcement. For example, time limits specified for C<LimitCPU> will be rounded up
implicitly to multiples of 1s. For C<LimitNICE> the value may be specified in two
syntaxes: if prefixed with C<+> or C<->, the value is understood as
regular Linux nice value in the range -20…19. If not prefixed like this the value is understood as
raw resource limit parameter in the range 0…40 (with 0 being equivalent to 1).

Note that most process resource limits configured with these options are per-process, and
processes may fork in order to acquire a new set of resources that are accounted independently of the
original process, and may thus escape limits set. Also note that C<LimitRSS> is not
implemented on Linux, and setting it has no effect. Often it is advisable to prefer the resource
controls listed in
L<systemd.resource-control(5)>
over these per-process limits, as they apply to services as a whole, may be altered dynamically at
runtime, and are generally more expressive. For example, C<MemoryMax> is a more
powerful (and working) replacement for C<LimitRSS>.

Note that C<LimitNPROC> will limit the number of processes from one (real) UID and
not the number of processes started (forked) by the service. Therefore the limit is cumulative for all
processes running under the same UID. Please also note that the C<LimitNPROC> will not be
enforced if the service is running as root (and not dropping privileges). Due to these limitations,
C<TasksMax> (see L<systemd.resource-control(5)>) is typically a better choice than C<LimitNPROC>.

Resource limits not configured explicitly for a unit default to the value configured in the various
C<DefaultLimitCPU>, C<DefaultLimitFSIZE>, … options available in
L<systemd-system.conf(5)>, and –
if not configured there – the kernel or per-user defaults, as defined by the OS (the latter only for user
services, see below).

For system units these resource limits may be chosen freely. When these settings are configured
in a user service (i.e. a service run by the per-user instance of the service manager) they cannot be
used to raise the limits above those set for the user manager itself when it was first invoked, as
the user's service manager generally lacks the privileges to do so. In user context these
configuration options are hence only useful to lower the limits passed in or to raise the soft limit
to the maximum of the hard limit as configured for the user. To raise the user's limits further, the
available configuration mechanisms differ between operating systems, but typically require
privileges. In most cases it is possible to configure higher per-user resource limits via PAM or by
setting limits on the system service encapsulating the user's service manager, i.e. the user's
instance of C<user@.service>. After making such changes, make sure to restart the
user's service manager. I< Optional. Type uniline.  > 

=head2 LimitFSIZE

Set soft and hard limits on various resources for executed processes. See
L<setrlimit(2)> for
details on the process resource limit concept. Process resource limits may be specified in two formats:
either as single value to set a specific soft and hard limit to the same value, or as colon-separated
pair C<soft:hard> to set both limits individually
(e.g. C<LimitAS=4G:16G>).  Use the string C<infinity> to configure no
limit on a specific resource. The multiplicative suffixes K, M, G, T, P and E (to the base 1024) may
be used for resource limits measured in bytes (e.g. C<LimitAS=16G>). For the limits
referring to time values, the usual time units ms, s, min, h and so on may be used (see
L<systemd.time(7)> for
details). Note that if no time unit is specified for C<LimitCPU> the default unit of
seconds is implied, while for C<LimitRTTIME> the default unit of microseconds is
implied. Also, note that the effective granularity of the limits might influence their
enforcement. For example, time limits specified for C<LimitCPU> will be rounded up
implicitly to multiples of 1s. For C<LimitNICE> the value may be specified in two
syntaxes: if prefixed with C<+> or C<->, the value is understood as
regular Linux nice value in the range -20…19. If not prefixed like this the value is understood as
raw resource limit parameter in the range 0…40 (with 0 being equivalent to 1).

Note that most process resource limits configured with these options are per-process, and
processes may fork in order to acquire a new set of resources that are accounted independently of the
original process, and may thus escape limits set. Also note that C<LimitRSS> is not
implemented on Linux, and setting it has no effect. Often it is advisable to prefer the resource
controls listed in
L<systemd.resource-control(5)>
over these per-process limits, as they apply to services as a whole, may be altered dynamically at
runtime, and are generally more expressive. For example, C<MemoryMax> is a more
powerful (and working) replacement for C<LimitRSS>.

Note that C<LimitNPROC> will limit the number of processes from one (real) UID and
not the number of processes started (forked) by the service. Therefore the limit is cumulative for all
processes running under the same UID. Please also note that the C<LimitNPROC> will not be
enforced if the service is running as root (and not dropping privileges). Due to these limitations,
C<TasksMax> (see L<systemd.resource-control(5)>) is typically a better choice than C<LimitNPROC>.

Resource limits not configured explicitly for a unit default to the value configured in the various
C<DefaultLimitCPU>, C<DefaultLimitFSIZE>, … options available in
L<systemd-system.conf(5)>, and –
if not configured there – the kernel or per-user defaults, as defined by the OS (the latter only for user
services, see below).

For system units these resource limits may be chosen freely. When these settings are configured
in a user service (i.e. a service run by the per-user instance of the service manager) they cannot be
used to raise the limits above those set for the user manager itself when it was first invoked, as
the user's service manager generally lacks the privileges to do so. In user context these
configuration options are hence only useful to lower the limits passed in or to raise the soft limit
to the maximum of the hard limit as configured for the user. To raise the user's limits further, the
available configuration mechanisms differ between operating systems, but typically require
privileges. In most cases it is possible to configure higher per-user resource limits via PAM or by
setting limits on the system service encapsulating the user's service manager, i.e. the user's
instance of C<user@.service>. After making such changes, make sure to restart the
user's service manager. I< Optional. Type uniline.  > 

=head2 LimitDATA

Set soft and hard limits on various resources for executed processes. See
L<setrlimit(2)> for
details on the process resource limit concept. Process resource limits may be specified in two formats:
either as single value to set a specific soft and hard limit to the same value, or as colon-separated
pair C<soft:hard> to set both limits individually
(e.g. C<LimitAS=4G:16G>).  Use the string C<infinity> to configure no
limit on a specific resource. The multiplicative suffixes K, M, G, T, P and E (to the base 1024) may
be used for resource limits measured in bytes (e.g. C<LimitAS=16G>). For the limits
referring to time values, the usual time units ms, s, min, h and so on may be used (see
L<systemd.time(7)> for
details). Note that if no time unit is specified for C<LimitCPU> the default unit of
seconds is implied, while for C<LimitRTTIME> the default unit of microseconds is
implied. Also, note that the effective granularity of the limits might influence their
enforcement. For example, time limits specified for C<LimitCPU> will be rounded up
implicitly to multiples of 1s. For C<LimitNICE> the value may be specified in two
syntaxes: if prefixed with C<+> or C<->, the value is understood as
regular Linux nice value in the range -20…19. If not prefixed like this the value is understood as
raw resource limit parameter in the range 0…40 (with 0 being equivalent to 1).

Note that most process resource limits configured with these options are per-process, and
processes may fork in order to acquire a new set of resources that are accounted independently of the
original process, and may thus escape limits set. Also note that C<LimitRSS> is not
implemented on Linux, and setting it has no effect. Often it is advisable to prefer the resource
controls listed in
L<systemd.resource-control(5)>
over these per-process limits, as they apply to services as a whole, may be altered dynamically at
runtime, and are generally more expressive. For example, C<MemoryMax> is a more
powerful (and working) replacement for C<LimitRSS>.

Note that C<LimitNPROC> will limit the number of processes from one (real) UID and
not the number of processes started (forked) by the service. Therefore the limit is cumulative for all
processes running under the same UID. Please also note that the C<LimitNPROC> will not be
enforced if the service is running as root (and not dropping privileges). Due to these limitations,
C<TasksMax> (see L<systemd.resource-control(5)>) is typically a better choice than C<LimitNPROC>.

Resource limits not configured explicitly for a unit default to the value configured in the various
C<DefaultLimitCPU>, C<DefaultLimitFSIZE>, … options available in
L<systemd-system.conf(5)>, and –
if not configured there – the kernel or per-user defaults, as defined by the OS (the latter only for user
services, see below).

For system units these resource limits may be chosen freely. When these settings are configured
in a user service (i.e. a service run by the per-user instance of the service manager) they cannot be
used to raise the limits above those set for the user manager itself when it was first invoked, as
the user's service manager generally lacks the privileges to do so. In user context these
configuration options are hence only useful to lower the limits passed in or to raise the soft limit
to the maximum of the hard limit as configured for the user. To raise the user's limits further, the
available configuration mechanisms differ between operating systems, but typically require
privileges. In most cases it is possible to configure higher per-user resource limits via PAM or by
setting limits on the system service encapsulating the user's service manager, i.e. the user's
instance of C<user@.service>. After making such changes, make sure to restart the
user's service manager. I< Optional. Type uniline.  > 

=head2 LimitSTACK

Set soft and hard limits on various resources for executed processes. See
L<setrlimit(2)> for
details on the process resource limit concept. Process resource limits may be specified in two formats:
either as single value to set a specific soft and hard limit to the same value, or as colon-separated
pair C<soft:hard> to set both limits individually
(e.g. C<LimitAS=4G:16G>).  Use the string C<infinity> to configure no
limit on a specific resource. The multiplicative suffixes K, M, G, T, P and E (to the base 1024) may
be used for resource limits measured in bytes (e.g. C<LimitAS=16G>). For the limits
referring to time values, the usual time units ms, s, min, h and so on may be used (see
L<systemd.time(7)> for
details). Note that if no time unit is specified for C<LimitCPU> the default unit of
seconds is implied, while for C<LimitRTTIME> the default unit of microseconds is
implied. Also, note that the effective granularity of the limits might influence their
enforcement. For example, time limits specified for C<LimitCPU> will be rounded up
implicitly to multiples of 1s. For C<LimitNICE> the value may be specified in two
syntaxes: if prefixed with C<+> or C<->, the value is understood as
regular Linux nice value in the range -20…19. If not prefixed like this the value is understood as
raw resource limit parameter in the range 0…40 (with 0 being equivalent to 1).

Note that most process resource limits configured with these options are per-process, and
processes may fork in order to acquire a new set of resources that are accounted independently of the
original process, and may thus escape limits set. Also note that C<LimitRSS> is not
implemented on Linux, and setting it has no effect. Often it is advisable to prefer the resource
controls listed in
L<systemd.resource-control(5)>
over these per-process limits, as they apply to services as a whole, may be altered dynamically at
runtime, and are generally more expressive. For example, C<MemoryMax> is a more
powerful (and working) replacement for C<LimitRSS>.

Note that C<LimitNPROC> will limit the number of processes from one (real) UID and
not the number of processes started (forked) by the service. Therefore the limit is cumulative for all
processes running under the same UID. Please also note that the C<LimitNPROC> will not be
enforced if the service is running as root (and not dropping privileges). Due to these limitations,
C<TasksMax> (see L<systemd.resource-control(5)>) is typically a better choice than C<LimitNPROC>.

Resource limits not configured explicitly for a unit default to the value configured in the various
C<DefaultLimitCPU>, C<DefaultLimitFSIZE>, … options available in
L<systemd-system.conf(5)>, and –
if not configured there – the kernel or per-user defaults, as defined by the OS (the latter only for user
services, see below).

For system units these resource limits may be chosen freely. When these settings are configured
in a user service (i.e. a service run by the per-user instance of the service manager) they cannot be
used to raise the limits above those set for the user manager itself when it was first invoked, as
the user's service manager generally lacks the privileges to do so. In user context these
configuration options are hence only useful to lower the limits passed in or to raise the soft limit
to the maximum of the hard limit as configured for the user. To raise the user's limits further, the
available configuration mechanisms differ between operating systems, but typically require
privileges. In most cases it is possible to configure higher per-user resource limits via PAM or by
setting limits on the system service encapsulating the user's service manager, i.e. the user's
instance of C<user@.service>. After making such changes, make sure to restart the
user's service manager. I< Optional. Type uniline.  > 

=head2 LimitCORE

Set soft and hard limits on various resources for executed processes. See
L<setrlimit(2)> for
details on the process resource limit concept. Process resource limits may be specified in two formats:
either as single value to set a specific soft and hard limit to the same value, or as colon-separated
pair C<soft:hard> to set both limits individually
(e.g. C<LimitAS=4G:16G>).  Use the string C<infinity> to configure no
limit on a specific resource. The multiplicative suffixes K, M, G, T, P and E (to the base 1024) may
be used for resource limits measured in bytes (e.g. C<LimitAS=16G>). For the limits
referring to time values, the usual time units ms, s, min, h and so on may be used (see
L<systemd.time(7)> for
details). Note that if no time unit is specified for C<LimitCPU> the default unit of
seconds is implied, while for C<LimitRTTIME> the default unit of microseconds is
implied. Also, note that the effective granularity of the limits might influence their
enforcement. For example, time limits specified for C<LimitCPU> will be rounded up
implicitly to multiples of 1s. For C<LimitNICE> the value may be specified in two
syntaxes: if prefixed with C<+> or C<->, the value is understood as
regular Linux nice value in the range -20…19. If not prefixed like this the value is understood as
raw resource limit parameter in the range 0…40 (with 0 being equivalent to 1).

Note that most process resource limits configured with these options are per-process, and
processes may fork in order to acquire a new set of resources that are accounted independently of the
original process, and may thus escape limits set. Also note that C<LimitRSS> is not
implemented on Linux, and setting it has no effect. Often it is advisable to prefer the resource
controls listed in
L<systemd.resource-control(5)>
over these per-process limits, as they apply to services as a whole, may be altered dynamically at
runtime, and are generally more expressive. For example, C<MemoryMax> is a more
powerful (and working) replacement for C<LimitRSS>.

Note that C<LimitNPROC> will limit the number of processes from one (real) UID and
not the number of processes started (forked) by the service. Therefore the limit is cumulative for all
processes running under the same UID. Please also note that the C<LimitNPROC> will not be
enforced if the service is running as root (and not dropping privileges). Due to these limitations,
C<TasksMax> (see L<systemd.resource-control(5)>) is typically a better choice than C<LimitNPROC>.

Resource limits not configured explicitly for a unit default to the value configured in the various
C<DefaultLimitCPU>, C<DefaultLimitFSIZE>, … options available in
L<systemd-system.conf(5)>, and –
if not configured there – the kernel or per-user defaults, as defined by the OS (the latter only for user
services, see below).

For system units these resource limits may be chosen freely. When these settings are configured
in a user service (i.e. a service run by the per-user instance of the service manager) they cannot be
used to raise the limits above those set for the user manager itself when it was first invoked, as
the user's service manager generally lacks the privileges to do so. In user context these
configuration options are hence only useful to lower the limits passed in or to raise the soft limit
to the maximum of the hard limit as configured for the user. To raise the user's limits further, the
available configuration mechanisms differ between operating systems, but typically require
privileges. In most cases it is possible to configure higher per-user resource limits via PAM or by
setting limits on the system service encapsulating the user's service manager, i.e. the user's
instance of C<user@.service>. After making such changes, make sure to restart the
user's service manager. I< Optional. Type uniline.  > 

=head2 LimitRSS

Set soft and hard limits on various resources for executed processes. See
L<setrlimit(2)> for
details on the process resource limit concept. Process resource limits may be specified in two formats:
either as single value to set a specific soft and hard limit to the same value, or as colon-separated
pair C<soft:hard> to set both limits individually
(e.g. C<LimitAS=4G:16G>).  Use the string C<infinity> to configure no
limit on a specific resource. The multiplicative suffixes K, M, G, T, P and E (to the base 1024) may
be used for resource limits measured in bytes (e.g. C<LimitAS=16G>). For the limits
referring to time values, the usual time units ms, s, min, h and so on may be used (see
L<systemd.time(7)> for
details). Note that if no time unit is specified for C<LimitCPU> the default unit of
seconds is implied, while for C<LimitRTTIME> the default unit of microseconds is
implied. Also, note that the effective granularity of the limits might influence their
enforcement. For example, time limits specified for C<LimitCPU> will be rounded up
implicitly to multiples of 1s. For C<LimitNICE> the value may be specified in two
syntaxes: if prefixed with C<+> or C<->, the value is understood as
regular Linux nice value in the range -20…19. If not prefixed like this the value is understood as
raw resource limit parameter in the range 0…40 (with 0 being equivalent to 1).

Note that most process resource limits configured with these options are per-process, and
processes may fork in order to acquire a new set of resources that are accounted independently of the
original process, and may thus escape limits set. Also note that C<LimitRSS> is not
implemented on Linux, and setting it has no effect. Often it is advisable to prefer the resource
controls listed in
L<systemd.resource-control(5)>
over these per-process limits, as they apply to services as a whole, may be altered dynamically at
runtime, and are generally more expressive. For example, C<MemoryMax> is a more
powerful (and working) replacement for C<LimitRSS>.

Note that C<LimitNPROC> will limit the number of processes from one (real) UID and
not the number of processes started (forked) by the service. Therefore the limit is cumulative for all
processes running under the same UID. Please also note that the C<LimitNPROC> will not be
enforced if the service is running as root (and not dropping privileges). Due to these limitations,
C<TasksMax> (see L<systemd.resource-control(5)>) is typically a better choice than C<LimitNPROC>.

Resource limits not configured explicitly for a unit default to the value configured in the various
C<DefaultLimitCPU>, C<DefaultLimitFSIZE>, … options available in
L<systemd-system.conf(5)>, and –
if not configured there – the kernel or per-user defaults, as defined by the OS (the latter only for user
services, see below).

For system units these resource limits may be chosen freely. When these settings are configured
in a user service (i.e. a service run by the per-user instance of the service manager) they cannot be
used to raise the limits above those set for the user manager itself when it was first invoked, as
the user's service manager generally lacks the privileges to do so. In user context these
configuration options are hence only useful to lower the limits passed in or to raise the soft limit
to the maximum of the hard limit as configured for the user. To raise the user's limits further, the
available configuration mechanisms differ between operating systems, but typically require
privileges. In most cases it is possible to configure higher per-user resource limits via PAM or by
setting limits on the system service encapsulating the user's service manager, i.e. the user's
instance of C<user@.service>. After making such changes, make sure to restart the
user's service manager. I< Optional. Type uniline.  > 

=head2 LimitNOFILE

Set soft and hard limits on various resources for executed processes. See
L<setrlimit(2)> for
details on the process resource limit concept. Process resource limits may be specified in two formats:
either as single value to set a specific soft and hard limit to the same value, or as colon-separated
pair C<soft:hard> to set both limits individually
(e.g. C<LimitAS=4G:16G>).  Use the string C<infinity> to configure no
limit on a specific resource. The multiplicative suffixes K, M, G, T, P and E (to the base 1024) may
be used for resource limits measured in bytes (e.g. C<LimitAS=16G>). For the limits
referring to time values, the usual time units ms, s, min, h and so on may be used (see
L<systemd.time(7)> for
details). Note that if no time unit is specified for C<LimitCPU> the default unit of
seconds is implied, while for C<LimitRTTIME> the default unit of microseconds is
implied. Also, note that the effective granularity of the limits might influence their
enforcement. For example, time limits specified for C<LimitCPU> will be rounded up
implicitly to multiples of 1s. For C<LimitNICE> the value may be specified in two
syntaxes: if prefixed with C<+> or C<->, the value is understood as
regular Linux nice value in the range -20…19. If not prefixed like this the value is understood as
raw resource limit parameter in the range 0…40 (with 0 being equivalent to 1).

Note that most process resource limits configured with these options are per-process, and
processes may fork in order to acquire a new set of resources that are accounted independently of the
original process, and may thus escape limits set. Also note that C<LimitRSS> is not
implemented on Linux, and setting it has no effect. Often it is advisable to prefer the resource
controls listed in
L<systemd.resource-control(5)>
over these per-process limits, as they apply to services as a whole, may be altered dynamically at
runtime, and are generally more expressive. For example, C<MemoryMax> is a more
powerful (and working) replacement for C<LimitRSS>.

Note that C<LimitNPROC> will limit the number of processes from one (real) UID and
not the number of processes started (forked) by the service. Therefore the limit is cumulative for all
processes running under the same UID. Please also note that the C<LimitNPROC> will not be
enforced if the service is running as root (and not dropping privileges). Due to these limitations,
C<TasksMax> (see L<systemd.resource-control(5)>) is typically a better choice than C<LimitNPROC>.

Resource limits not configured explicitly for a unit default to the value configured in the various
C<DefaultLimitCPU>, C<DefaultLimitFSIZE>, … options available in
L<systemd-system.conf(5)>, and –
if not configured there – the kernel or per-user defaults, as defined by the OS (the latter only for user
services, see below).

For system units these resource limits may be chosen freely. When these settings are configured
in a user service (i.e. a service run by the per-user instance of the service manager) they cannot be
used to raise the limits above those set for the user manager itself when it was first invoked, as
the user's service manager generally lacks the privileges to do so. In user context these
configuration options are hence only useful to lower the limits passed in or to raise the soft limit
to the maximum of the hard limit as configured for the user. To raise the user's limits further, the
available configuration mechanisms differ between operating systems, but typically require
privileges. In most cases it is possible to configure higher per-user resource limits via PAM or by
setting limits on the system service encapsulating the user's service manager, i.e. the user's
instance of C<user@.service>. After making such changes, make sure to restart the
user's service manager. I< Optional. Type uniline.  > 

=head2 LimitAS

Set soft and hard limits on various resources for executed processes. See
L<setrlimit(2)> for
details on the process resource limit concept. Process resource limits may be specified in two formats:
either as single value to set a specific soft and hard limit to the same value, or as colon-separated
pair C<soft:hard> to set both limits individually
(e.g. C<LimitAS=4G:16G>).  Use the string C<infinity> to configure no
limit on a specific resource. The multiplicative suffixes K, M, G, T, P and E (to the base 1024) may
be used for resource limits measured in bytes (e.g. C<LimitAS=16G>). For the limits
referring to time values, the usual time units ms, s, min, h and so on may be used (see
L<systemd.time(7)> for
details). Note that if no time unit is specified for C<LimitCPU> the default unit of
seconds is implied, while for C<LimitRTTIME> the default unit of microseconds is
implied. Also, note that the effective granularity of the limits might influence their
enforcement. For example, time limits specified for C<LimitCPU> will be rounded up
implicitly to multiples of 1s. For C<LimitNICE> the value may be specified in two
syntaxes: if prefixed with C<+> or C<->, the value is understood as
regular Linux nice value in the range -20…19. If not prefixed like this the value is understood as
raw resource limit parameter in the range 0…40 (with 0 being equivalent to 1).

Note that most process resource limits configured with these options are per-process, and
processes may fork in order to acquire a new set of resources that are accounted independently of the
original process, and may thus escape limits set. Also note that C<LimitRSS> is not
implemented on Linux, and setting it has no effect. Often it is advisable to prefer the resource
controls listed in
L<systemd.resource-control(5)>
over these per-process limits, as they apply to services as a whole, may be altered dynamically at
runtime, and are generally more expressive. For example, C<MemoryMax> is a more
powerful (and working) replacement for C<LimitRSS>.

Note that C<LimitNPROC> will limit the number of processes from one (real) UID and
not the number of processes started (forked) by the service. Therefore the limit is cumulative for all
processes running under the same UID. Please also note that the C<LimitNPROC> will not be
enforced if the service is running as root (and not dropping privileges). Due to these limitations,
C<TasksMax> (see L<systemd.resource-control(5)>) is typically a better choice than C<LimitNPROC>.

Resource limits not configured explicitly for a unit default to the value configured in the various
C<DefaultLimitCPU>, C<DefaultLimitFSIZE>, … options available in
L<systemd-system.conf(5)>, and –
if not configured there – the kernel or per-user defaults, as defined by the OS (the latter only for user
services, see below).

For system units these resource limits may be chosen freely. When these settings are configured
in a user service (i.e. a service run by the per-user instance of the service manager) they cannot be
used to raise the limits above those set for the user manager itself when it was first invoked, as
the user's service manager generally lacks the privileges to do so. In user context these
configuration options are hence only useful to lower the limits passed in or to raise the soft limit
to the maximum of the hard limit as configured for the user. To raise the user's limits further, the
available configuration mechanisms differ between operating systems, but typically require
privileges. In most cases it is possible to configure higher per-user resource limits via PAM or by
setting limits on the system service encapsulating the user's service manager, i.e. the user's
instance of C<user@.service>. After making such changes, make sure to restart the
user's service manager. I< Optional. Type uniline.  > 

=head2 LimitNPROC

Set soft and hard limits on various resources for executed processes. See
L<setrlimit(2)> for
details on the process resource limit concept. Process resource limits may be specified in two formats:
either as single value to set a specific soft and hard limit to the same value, or as colon-separated
pair C<soft:hard> to set both limits individually
(e.g. C<LimitAS=4G:16G>).  Use the string C<infinity> to configure no
limit on a specific resource. The multiplicative suffixes K, M, G, T, P and E (to the base 1024) may
be used for resource limits measured in bytes (e.g. C<LimitAS=16G>). For the limits
referring to time values, the usual time units ms, s, min, h and so on may be used (see
L<systemd.time(7)> for
details). Note that if no time unit is specified for C<LimitCPU> the default unit of
seconds is implied, while for C<LimitRTTIME> the default unit of microseconds is
implied. Also, note that the effective granularity of the limits might influence their
enforcement. For example, time limits specified for C<LimitCPU> will be rounded up
implicitly to multiples of 1s. For C<LimitNICE> the value may be specified in two
syntaxes: if prefixed with C<+> or C<->, the value is understood as
regular Linux nice value in the range -20…19. If not prefixed like this the value is understood as
raw resource limit parameter in the range 0…40 (with 0 being equivalent to 1).

Note that most process resource limits configured with these options are per-process, and
processes may fork in order to acquire a new set of resources that are accounted independently of the
original process, and may thus escape limits set. Also note that C<LimitRSS> is not
implemented on Linux, and setting it has no effect. Often it is advisable to prefer the resource
controls listed in
L<systemd.resource-control(5)>
over these per-process limits, as they apply to services as a whole, may be altered dynamically at
runtime, and are generally more expressive. For example, C<MemoryMax> is a more
powerful (and working) replacement for C<LimitRSS>.

Note that C<LimitNPROC> will limit the number of processes from one (real) UID and
not the number of processes started (forked) by the service. Therefore the limit is cumulative for all
processes running under the same UID. Please also note that the C<LimitNPROC> will not be
enforced if the service is running as root (and not dropping privileges). Due to these limitations,
C<TasksMax> (see L<systemd.resource-control(5)>) is typically a better choice than C<LimitNPROC>.

Resource limits not configured explicitly for a unit default to the value configured in the various
C<DefaultLimitCPU>, C<DefaultLimitFSIZE>, … options available in
L<systemd-system.conf(5)>, and –
if not configured there – the kernel or per-user defaults, as defined by the OS (the latter only for user
services, see below).

For system units these resource limits may be chosen freely. When these settings are configured
in a user service (i.e. a service run by the per-user instance of the service manager) they cannot be
used to raise the limits above those set for the user manager itself when it was first invoked, as
the user's service manager generally lacks the privileges to do so. In user context these
configuration options are hence only useful to lower the limits passed in or to raise the soft limit
to the maximum of the hard limit as configured for the user. To raise the user's limits further, the
available configuration mechanisms differ between operating systems, but typically require
privileges. In most cases it is possible to configure higher per-user resource limits via PAM or by
setting limits on the system service encapsulating the user's service manager, i.e. the user's
instance of C<user@.service>. After making such changes, make sure to restart the
user's service manager. I< Optional. Type uniline.  > 

=head2 LimitMEMLOCK

Set soft and hard limits on various resources for executed processes. See
L<setrlimit(2)> for
details on the process resource limit concept. Process resource limits may be specified in two formats:
either as single value to set a specific soft and hard limit to the same value, or as colon-separated
pair C<soft:hard> to set both limits individually
(e.g. C<LimitAS=4G:16G>).  Use the string C<infinity> to configure no
limit on a specific resource. The multiplicative suffixes K, M, G, T, P and E (to the base 1024) may
be used for resource limits measured in bytes (e.g. C<LimitAS=16G>). For the limits
referring to time values, the usual time units ms, s, min, h and so on may be used (see
L<systemd.time(7)> for
details). Note that if no time unit is specified for C<LimitCPU> the default unit of
seconds is implied, while for C<LimitRTTIME> the default unit of microseconds is
implied. Also, note that the effective granularity of the limits might influence their
enforcement. For example, time limits specified for C<LimitCPU> will be rounded up
implicitly to multiples of 1s. For C<LimitNICE> the value may be specified in two
syntaxes: if prefixed with C<+> or C<->, the value is understood as
regular Linux nice value in the range -20…19. If not prefixed like this the value is understood as
raw resource limit parameter in the range 0…40 (with 0 being equivalent to 1).

Note that most process resource limits configured with these options are per-process, and
processes may fork in order to acquire a new set of resources that are accounted independently of the
original process, and may thus escape limits set. Also note that C<LimitRSS> is not
implemented on Linux, and setting it has no effect. Often it is advisable to prefer the resource
controls listed in
L<systemd.resource-control(5)>
over these per-process limits, as they apply to services as a whole, may be altered dynamically at
runtime, and are generally more expressive. For example, C<MemoryMax> is a more
powerful (and working) replacement for C<LimitRSS>.

Note that C<LimitNPROC> will limit the number of processes from one (real) UID and
not the number of processes started (forked) by the service. Therefore the limit is cumulative for all
processes running under the same UID. Please also note that the C<LimitNPROC> will not be
enforced if the service is running as root (and not dropping privileges). Due to these limitations,
C<TasksMax> (see L<systemd.resource-control(5)>) is typically a better choice than C<LimitNPROC>.

Resource limits not configured explicitly for a unit default to the value configured in the various
C<DefaultLimitCPU>, C<DefaultLimitFSIZE>, … options available in
L<systemd-system.conf(5)>, and –
if not configured there – the kernel or per-user defaults, as defined by the OS (the latter only for user
services, see below).

For system units these resource limits may be chosen freely. When these settings are configured
in a user service (i.e. a service run by the per-user instance of the service manager) they cannot be
used to raise the limits above those set for the user manager itself when it was first invoked, as
the user's service manager generally lacks the privileges to do so. In user context these
configuration options are hence only useful to lower the limits passed in or to raise the soft limit
to the maximum of the hard limit as configured for the user. To raise the user's limits further, the
available configuration mechanisms differ between operating systems, but typically require
privileges. In most cases it is possible to configure higher per-user resource limits via PAM or by
setting limits on the system service encapsulating the user's service manager, i.e. the user's
instance of C<user@.service>. After making such changes, make sure to restart the
user's service manager. I< Optional. Type uniline.  > 

=head2 LimitLOCKS

Set soft and hard limits on various resources for executed processes. See
L<setrlimit(2)> for
details on the process resource limit concept. Process resource limits may be specified in two formats:
either as single value to set a specific soft and hard limit to the same value, or as colon-separated
pair C<soft:hard> to set both limits individually
(e.g. C<LimitAS=4G:16G>).  Use the string C<infinity> to configure no
limit on a specific resource. The multiplicative suffixes K, M, G, T, P and E (to the base 1024) may
be used for resource limits measured in bytes (e.g. C<LimitAS=16G>). For the limits
referring to time values, the usual time units ms, s, min, h and so on may be used (see
L<systemd.time(7)> for
details). Note that if no time unit is specified for C<LimitCPU> the default unit of
seconds is implied, while for C<LimitRTTIME> the default unit of microseconds is
implied. Also, note that the effective granularity of the limits might influence their
enforcement. For example, time limits specified for C<LimitCPU> will be rounded up
implicitly to multiples of 1s. For C<LimitNICE> the value may be specified in two
syntaxes: if prefixed with C<+> or C<->, the value is understood as
regular Linux nice value in the range -20…19. If not prefixed like this the value is understood as
raw resource limit parameter in the range 0…40 (with 0 being equivalent to 1).

Note that most process resource limits configured with these options are per-process, and
processes may fork in order to acquire a new set of resources that are accounted independently of the
original process, and may thus escape limits set. Also note that C<LimitRSS> is not
implemented on Linux, and setting it has no effect. Often it is advisable to prefer the resource
controls listed in
L<systemd.resource-control(5)>
over these per-process limits, as they apply to services as a whole, may be altered dynamically at
runtime, and are generally more expressive. For example, C<MemoryMax> is a more
powerful (and working) replacement for C<LimitRSS>.

Note that C<LimitNPROC> will limit the number of processes from one (real) UID and
not the number of processes started (forked) by the service. Therefore the limit is cumulative for all
processes running under the same UID. Please also note that the C<LimitNPROC> will not be
enforced if the service is running as root (and not dropping privileges). Due to these limitations,
C<TasksMax> (see L<systemd.resource-control(5)>) is typically a better choice than C<LimitNPROC>.

Resource limits not configured explicitly for a unit default to the value configured in the various
C<DefaultLimitCPU>, C<DefaultLimitFSIZE>, … options available in
L<systemd-system.conf(5)>, and –
if not configured there – the kernel or per-user defaults, as defined by the OS (the latter only for user
services, see below).

For system units these resource limits may be chosen freely. When these settings are configured
in a user service (i.e. a service run by the per-user instance of the service manager) they cannot be
used to raise the limits above those set for the user manager itself when it was first invoked, as
the user's service manager generally lacks the privileges to do so. In user context these
configuration options are hence only useful to lower the limits passed in or to raise the soft limit
to the maximum of the hard limit as configured for the user. To raise the user's limits further, the
available configuration mechanisms differ between operating systems, but typically require
privileges. In most cases it is possible to configure higher per-user resource limits via PAM or by
setting limits on the system service encapsulating the user's service manager, i.e. the user's
instance of C<user@.service>. After making such changes, make sure to restart the
user's service manager. I< Optional. Type uniline.  > 

=head2 LimitSIGPENDING

Set soft and hard limits on various resources for executed processes. See
L<setrlimit(2)> for
details on the process resource limit concept. Process resource limits may be specified in two formats:
either as single value to set a specific soft and hard limit to the same value, or as colon-separated
pair C<soft:hard> to set both limits individually
(e.g. C<LimitAS=4G:16G>).  Use the string C<infinity> to configure no
limit on a specific resource. The multiplicative suffixes K, M, G, T, P and E (to the base 1024) may
be used for resource limits measured in bytes (e.g. C<LimitAS=16G>). For the limits
referring to time values, the usual time units ms, s, min, h and so on may be used (see
L<systemd.time(7)> for
details). Note that if no time unit is specified for C<LimitCPU> the default unit of
seconds is implied, while for C<LimitRTTIME> the default unit of microseconds is
implied. Also, note that the effective granularity of the limits might influence their
enforcement. For example, time limits specified for C<LimitCPU> will be rounded up
implicitly to multiples of 1s. For C<LimitNICE> the value may be specified in two
syntaxes: if prefixed with C<+> or C<->, the value is understood as
regular Linux nice value in the range -20…19. If not prefixed like this the value is understood as
raw resource limit parameter in the range 0…40 (with 0 being equivalent to 1).

Note that most process resource limits configured with these options are per-process, and
processes may fork in order to acquire a new set of resources that are accounted independently of the
original process, and may thus escape limits set. Also note that C<LimitRSS> is not
implemented on Linux, and setting it has no effect. Often it is advisable to prefer the resource
controls listed in
L<systemd.resource-control(5)>
over these per-process limits, as they apply to services as a whole, may be altered dynamically at
runtime, and are generally more expressive. For example, C<MemoryMax> is a more
powerful (and working) replacement for C<LimitRSS>.

Note that C<LimitNPROC> will limit the number of processes from one (real) UID and
not the number of processes started (forked) by the service. Therefore the limit is cumulative for all
processes running under the same UID. Please also note that the C<LimitNPROC> will not be
enforced if the service is running as root (and not dropping privileges). Due to these limitations,
C<TasksMax> (see L<systemd.resource-control(5)>) is typically a better choice than C<LimitNPROC>.

Resource limits not configured explicitly for a unit default to the value configured in the various
C<DefaultLimitCPU>, C<DefaultLimitFSIZE>, … options available in
L<systemd-system.conf(5)>, and –
if not configured there – the kernel or per-user defaults, as defined by the OS (the latter only for user
services, see below).

For system units these resource limits may be chosen freely. When these settings are configured
in a user service (i.e. a service run by the per-user instance of the service manager) they cannot be
used to raise the limits above those set for the user manager itself when it was first invoked, as
the user's service manager generally lacks the privileges to do so. In user context these
configuration options are hence only useful to lower the limits passed in or to raise the soft limit
to the maximum of the hard limit as configured for the user. To raise the user's limits further, the
available configuration mechanisms differ between operating systems, but typically require
privileges. In most cases it is possible to configure higher per-user resource limits via PAM or by
setting limits on the system service encapsulating the user's service manager, i.e. the user's
instance of C<user@.service>. After making such changes, make sure to restart the
user's service manager. I< Optional. Type uniline.  > 

=head2 LimitMSGQUEUE

Set soft and hard limits on various resources for executed processes. See
L<setrlimit(2)> for
details on the process resource limit concept. Process resource limits may be specified in two formats:
either as single value to set a specific soft and hard limit to the same value, or as colon-separated
pair C<soft:hard> to set both limits individually
(e.g. C<LimitAS=4G:16G>).  Use the string C<infinity> to configure no
limit on a specific resource. The multiplicative suffixes K, M, G, T, P and E (to the base 1024) may
be used for resource limits measured in bytes (e.g. C<LimitAS=16G>). For the limits
referring to time values, the usual time units ms, s, min, h and so on may be used (see
L<systemd.time(7)> for
details). Note that if no time unit is specified for C<LimitCPU> the default unit of
seconds is implied, while for C<LimitRTTIME> the default unit of microseconds is
implied. Also, note that the effective granularity of the limits might influence their
enforcement. For example, time limits specified for C<LimitCPU> will be rounded up
implicitly to multiples of 1s. For C<LimitNICE> the value may be specified in two
syntaxes: if prefixed with C<+> or C<->, the value is understood as
regular Linux nice value in the range -20…19. If not prefixed like this the value is understood as
raw resource limit parameter in the range 0…40 (with 0 being equivalent to 1).

Note that most process resource limits configured with these options are per-process, and
processes may fork in order to acquire a new set of resources that are accounted independently of the
original process, and may thus escape limits set. Also note that C<LimitRSS> is not
implemented on Linux, and setting it has no effect. Often it is advisable to prefer the resource
controls listed in
L<systemd.resource-control(5)>
over these per-process limits, as they apply to services as a whole, may be altered dynamically at
runtime, and are generally more expressive. For example, C<MemoryMax> is a more
powerful (and working) replacement for C<LimitRSS>.

Note that C<LimitNPROC> will limit the number of processes from one (real) UID and
not the number of processes started (forked) by the service. Therefore the limit is cumulative for all
processes running under the same UID. Please also note that the C<LimitNPROC> will not be
enforced if the service is running as root (and not dropping privileges). Due to these limitations,
C<TasksMax> (see L<systemd.resource-control(5)>) is typically a better choice than C<LimitNPROC>.

Resource limits not configured explicitly for a unit default to the value configured in the various
C<DefaultLimitCPU>, C<DefaultLimitFSIZE>, … options available in
L<systemd-system.conf(5)>, and –
if not configured there – the kernel or per-user defaults, as defined by the OS (the latter only for user
services, see below).

For system units these resource limits may be chosen freely. When these settings are configured
in a user service (i.e. a service run by the per-user instance of the service manager) they cannot be
used to raise the limits above those set for the user manager itself when it was first invoked, as
the user's service manager generally lacks the privileges to do so. In user context these
configuration options are hence only useful to lower the limits passed in or to raise the soft limit
to the maximum of the hard limit as configured for the user. To raise the user's limits further, the
available configuration mechanisms differ between operating systems, but typically require
privileges. In most cases it is possible to configure higher per-user resource limits via PAM or by
setting limits on the system service encapsulating the user's service manager, i.e. the user's
instance of C<user@.service>. After making such changes, make sure to restart the
user's service manager. I< Optional. Type uniline.  > 

=head2 LimitNICE

Set soft and hard limits on various resources for executed processes. See
L<setrlimit(2)> for
details on the process resource limit concept. Process resource limits may be specified in two formats:
either as single value to set a specific soft and hard limit to the same value, or as colon-separated
pair C<soft:hard> to set both limits individually
(e.g. C<LimitAS=4G:16G>).  Use the string C<infinity> to configure no
limit on a specific resource. The multiplicative suffixes K, M, G, T, P and E (to the base 1024) may
be used for resource limits measured in bytes (e.g. C<LimitAS=16G>). For the limits
referring to time values, the usual time units ms, s, min, h and so on may be used (see
L<systemd.time(7)> for
details). Note that if no time unit is specified for C<LimitCPU> the default unit of
seconds is implied, while for C<LimitRTTIME> the default unit of microseconds is
implied. Also, note that the effective granularity of the limits might influence their
enforcement. For example, time limits specified for C<LimitCPU> will be rounded up
implicitly to multiples of 1s. For C<LimitNICE> the value may be specified in two
syntaxes: if prefixed with C<+> or C<->, the value is understood as
regular Linux nice value in the range -20…19. If not prefixed like this the value is understood as
raw resource limit parameter in the range 0…40 (with 0 being equivalent to 1).

Note that most process resource limits configured with these options are per-process, and
processes may fork in order to acquire a new set of resources that are accounted independently of the
original process, and may thus escape limits set. Also note that C<LimitRSS> is not
implemented on Linux, and setting it has no effect. Often it is advisable to prefer the resource
controls listed in
L<systemd.resource-control(5)>
over these per-process limits, as they apply to services as a whole, may be altered dynamically at
runtime, and are generally more expressive. For example, C<MemoryMax> is a more
powerful (and working) replacement for C<LimitRSS>.

Note that C<LimitNPROC> will limit the number of processes from one (real) UID and
not the number of processes started (forked) by the service. Therefore the limit is cumulative for all
processes running under the same UID. Please also note that the C<LimitNPROC> will not be
enforced if the service is running as root (and not dropping privileges). Due to these limitations,
C<TasksMax> (see L<systemd.resource-control(5)>) is typically a better choice than C<LimitNPROC>.

Resource limits not configured explicitly for a unit default to the value configured in the various
C<DefaultLimitCPU>, C<DefaultLimitFSIZE>, … options available in
L<systemd-system.conf(5)>, and –
if not configured there – the kernel or per-user defaults, as defined by the OS (the latter only for user
services, see below).

For system units these resource limits may be chosen freely. When these settings are configured
in a user service (i.e. a service run by the per-user instance of the service manager) they cannot be
used to raise the limits above those set for the user manager itself when it was first invoked, as
the user's service manager generally lacks the privileges to do so. In user context these
configuration options are hence only useful to lower the limits passed in or to raise the soft limit
to the maximum of the hard limit as configured for the user. To raise the user's limits further, the
available configuration mechanisms differ between operating systems, but typically require
privileges. In most cases it is possible to configure higher per-user resource limits via PAM or by
setting limits on the system service encapsulating the user's service manager, i.e. the user's
instance of C<user@.service>. After making such changes, make sure to restart the
user's service manager. I< Optional. Type uniline.  > 

=head2 LimitRTPRIO

Set soft and hard limits on various resources for executed processes. See
L<setrlimit(2)> for
details on the process resource limit concept. Process resource limits may be specified in two formats:
either as single value to set a specific soft and hard limit to the same value, or as colon-separated
pair C<soft:hard> to set both limits individually
(e.g. C<LimitAS=4G:16G>).  Use the string C<infinity> to configure no
limit on a specific resource. The multiplicative suffixes K, M, G, T, P and E (to the base 1024) may
be used for resource limits measured in bytes (e.g. C<LimitAS=16G>). For the limits
referring to time values, the usual time units ms, s, min, h and so on may be used (see
L<systemd.time(7)> for
details). Note that if no time unit is specified for C<LimitCPU> the default unit of
seconds is implied, while for C<LimitRTTIME> the default unit of microseconds is
implied. Also, note that the effective granularity of the limits might influence their
enforcement. For example, time limits specified for C<LimitCPU> will be rounded up
implicitly to multiples of 1s. For C<LimitNICE> the value may be specified in two
syntaxes: if prefixed with C<+> or C<->, the value is understood as
regular Linux nice value in the range -20…19. If not prefixed like this the value is understood as
raw resource limit parameter in the range 0…40 (with 0 being equivalent to 1).

Note that most process resource limits configured with these options are per-process, and
processes may fork in order to acquire a new set of resources that are accounted independently of the
original process, and may thus escape limits set. Also note that C<LimitRSS> is not
implemented on Linux, and setting it has no effect. Often it is advisable to prefer the resource
controls listed in
L<systemd.resource-control(5)>
over these per-process limits, as they apply to services as a whole, may be altered dynamically at
runtime, and are generally more expressive. For example, C<MemoryMax> is a more
powerful (and working) replacement for C<LimitRSS>.

Note that C<LimitNPROC> will limit the number of processes from one (real) UID and
not the number of processes started (forked) by the service. Therefore the limit is cumulative for all
processes running under the same UID. Please also note that the C<LimitNPROC> will not be
enforced if the service is running as root (and not dropping privileges). Due to these limitations,
C<TasksMax> (see L<systemd.resource-control(5)>) is typically a better choice than C<LimitNPROC>.

Resource limits not configured explicitly for a unit default to the value configured in the various
C<DefaultLimitCPU>, C<DefaultLimitFSIZE>, … options available in
L<systemd-system.conf(5)>, and –
if not configured there – the kernel or per-user defaults, as defined by the OS (the latter only for user
services, see below).

For system units these resource limits may be chosen freely. When these settings are configured
in a user service (i.e. a service run by the per-user instance of the service manager) they cannot be
used to raise the limits above those set for the user manager itself when it was first invoked, as
the user's service manager generally lacks the privileges to do so. In user context these
configuration options are hence only useful to lower the limits passed in or to raise the soft limit
to the maximum of the hard limit as configured for the user. To raise the user's limits further, the
available configuration mechanisms differ between operating systems, but typically require
privileges. In most cases it is possible to configure higher per-user resource limits via PAM or by
setting limits on the system service encapsulating the user's service manager, i.e. the user's
instance of C<user@.service>. After making such changes, make sure to restart the
user's service manager. I< Optional. Type uniline.  > 

=head2 LimitRTTIME

Set soft and hard limits on various resources for executed processes. See
L<setrlimit(2)> for
details on the process resource limit concept. Process resource limits may be specified in two formats:
either as single value to set a specific soft and hard limit to the same value, or as colon-separated
pair C<soft:hard> to set both limits individually
(e.g. C<LimitAS=4G:16G>).  Use the string C<infinity> to configure no
limit on a specific resource. The multiplicative suffixes K, M, G, T, P and E (to the base 1024) may
be used for resource limits measured in bytes (e.g. C<LimitAS=16G>). For the limits
referring to time values, the usual time units ms, s, min, h and so on may be used (see
L<systemd.time(7)> for
details). Note that if no time unit is specified for C<LimitCPU> the default unit of
seconds is implied, while for C<LimitRTTIME> the default unit of microseconds is
implied. Also, note that the effective granularity of the limits might influence their
enforcement. For example, time limits specified for C<LimitCPU> will be rounded up
implicitly to multiples of 1s. For C<LimitNICE> the value may be specified in two
syntaxes: if prefixed with C<+> or C<->, the value is understood as
regular Linux nice value in the range -20…19. If not prefixed like this the value is understood as
raw resource limit parameter in the range 0…40 (with 0 being equivalent to 1).

Note that most process resource limits configured with these options are per-process, and
processes may fork in order to acquire a new set of resources that are accounted independently of the
original process, and may thus escape limits set. Also note that C<LimitRSS> is not
implemented on Linux, and setting it has no effect. Often it is advisable to prefer the resource
controls listed in
L<systemd.resource-control(5)>
over these per-process limits, as they apply to services as a whole, may be altered dynamically at
runtime, and are generally more expressive. For example, C<MemoryMax> is a more
powerful (and working) replacement for C<LimitRSS>.

Note that C<LimitNPROC> will limit the number of processes from one (real) UID and
not the number of processes started (forked) by the service. Therefore the limit is cumulative for all
processes running under the same UID. Please also note that the C<LimitNPROC> will not be
enforced if the service is running as root (and not dropping privileges). Due to these limitations,
C<TasksMax> (see L<systemd.resource-control(5)>) is typically a better choice than C<LimitNPROC>.

Resource limits not configured explicitly for a unit default to the value configured in the various
C<DefaultLimitCPU>, C<DefaultLimitFSIZE>, … options available in
L<systemd-system.conf(5)>, and –
if not configured there – the kernel or per-user defaults, as defined by the OS (the latter only for user
services, see below).

For system units these resource limits may be chosen freely. When these settings are configured
in a user service (i.e. a service run by the per-user instance of the service manager) they cannot be
used to raise the limits above those set for the user manager itself when it was first invoked, as
the user's service manager generally lacks the privileges to do so. In user context these
configuration options are hence only useful to lower the limits passed in or to raise the soft limit
to the maximum of the hard limit as configured for the user. To raise the user's limits further, the
available configuration mechanisms differ between operating systems, but typically require
privileges. In most cases it is possible to configure higher per-user resource limits via PAM or by
setting limits on the system service encapsulating the user's service manager, i.e. the user's
instance of C<user@.service>. After making such changes, make sure to restart the
user's service manager. I< Optional. Type uniline.  > 

=head2 UMask

Controls the file mode creation mask. Takes an access mode in octal notation. See
L<umask(2)> for
details. Defaults to 0022 for system units. For user units the default value is inherited from the
per-user service manager (whose default is in turn inherited from the system service manager, and
thus typically also is 0022 — unless overridden by a PAM module). In order to change the per-user mask
for all user services, consider setting the C<UMask> setting of the user's
C<user@.service> system service instance. The per-user umask may also be set via
the C<umask> field of a user's L<JSON User
Record|https://systemd.io/USER_RECORD> (for users managed by
L<systemd-homed.service(8)>
this field may be controlled via homectl --umask=). It may also be set via a PAM
module, such as L<pam_umask(8)>. I< Optional. Type uniline.  > 

=head2 CoredumpFilter

Controls which types of memory mappings will be saved if the process dumps core
(using the C</proc/pid/coredump_filter> file). Takes a
whitespace-separated combination of mapping type names or numbers (with the default base 16). Mapping
type names are C<private-anonymous>, C<shared-anonymous>,
C<private-file-backed>, C<shared-file-backed>,
C<elf-headers>, C<private-huge>,
C<shared-huge>, C<private-dax>, C<shared-dax>,
and the special values C<all> (all types) and C<default> (the
kernel default of C<private-anonymous>C<shared-anonymous> C<elf-headers>C<private-huge>). See
L<core(5)>
for the meaning of the mapping types. When specified multiple times, all specified masks are
ORed. When not set, or if the empty value is assigned, the inherited value is not changed. I< Optional. Type uniline.  > 

=head2 KeyringMode

Controls how the kernel session keyring is set up for the service (see L<session-keyring(7)> for
details on the session keyring). Takes one of C<inherit>, C<private>,
C<shared>. If set to C<inherit> no special keyring setup is done, and the kernel's
default behaviour is applied. If C<private> is used a new session keyring is allocated when a
service process is invoked, and it is not linked up with any user keyring. This is the recommended setting for
system services, as this ensures that multiple services running under the same system user ID (in particular
the root user) do not share their key material among each other. If C<shared> is used a new
session keyring is allocated as for C<private>, but the user keyring of the user configured with
C<User> is linked into it, so that keys assigned to the user may be requested by the unit's
processes. In this mode multiple units running processes under the same user ID may share key material. Unless
C<inherit> is selected the unique invocation ID for the unit (see below) is added as a protected
key by the name C<invocation_id> to the newly created session keyring. Defaults to
C<private> for services of the system service manager and to C<inherit> for
non-service units and for services of the user service manager. I< Optional. Type enum. choice: 'inherit', 'private', 'shared'.  > 

=head2 OOMScoreAdjust

Sets the adjustment value for the Linux kernel's Out-Of-Memory (OOM) killer score for
executed processes. Takes an integer between -1000 (to disable OOM killing of processes of this unit)
and 1000 (to make killing of processes of this unit under memory pressure very likely). See L<The /proc
Filesystem|https://docs.kernel.org/filesystems/proc.html> for
details. If not specified, defaults to the OOM score adjustment level of the service manager itself,
which is normally at 0.

Use the C<OOMPolicy> setting of service units to configure how the service
manager shall react to the kernel OOM killer or systemd-oomd terminating a process of the service. See
L<systemd.service(5)>
for details. I< Optional. Type integer.  > 

=head2 TimerSlackNSec

Sets the timer slack in nanoseconds for the executed processes. The timer slack controls the
accuracy of wake-ups triggered by timers. See
L<prctl(2)> for more
information. Note that in contrast to most other time span definitions this parameter takes an integer value in
nano-seconds if no unit is specified. The usual time units are understood too. I< Optional. Type uniline.  > 

=head2 Personality

Controls which kernel architecture L<uname(2)> shall
report, when invoked by unit processes. Takes one of the architecture identifiers
C<arm64>, C<arm64-be>, C<arm>,
C<arm-be>, C<x86>, C<x86-64>,
C<ppc>, C<ppc-le>, C<ppc64>,
C<ppc64-le>, C<s390> or C<s390x>. Which
personality architectures are supported depends on the kernel's native architecture. Usually the
64-bit versions of the various system architectures support their immediate 32-bit personality
architecture counterpart, but no others. For example, C<x86-64> systems support the
C<x86-64> and C<x86> personalities but no others. The personality
feature is useful when running 32-bit services on a 64-bit host system. If not specified, the
personality is left unmodified and thus reflects the personality of the host system's kernel. This
option is not useful on architectures for which only one native word width was ever available, such
as C<m68k> (32-bit only) or C<alpha> (64-bit only). I< Optional. Type enum. choice: 'arm', 'arm-be', 'arm64', 'arm64-be', 'ppc', 'ppc-le', 'ppc64', 'ppc64-le', 's390', 's390x', 'x86', 'x86-64'.  > 

=head2 IgnoreSIGPIPE

Takes a boolean argument. If true, C<SIGPIPE> is ignored in the
executed process. Defaults to true since C<SIGPIPE> is generally only useful in
shell pipelines. I< Optional. Type boolean.  > 

=head2 Nice

Sets the default nice level (scheduling priority) for executed processes. Takes an
integer between -20 (highest priority) and 19 (lowest priority). In case of resource contention,
smaller values mean more resources will be made available to the unit's processes, larger values mean
less resources will be made available. See
L<setpriority(2)> for
details. I< Optional. Type integer.  > 

=head2 CPUSchedulingPolicy

Sets the CPU scheduling policy for executed processes. Takes one of C<other>,
C<batch>, C<idle>, C<fifo> or C<rr>. See
L<sched_setscheduler(2)> for
details. I< Optional. Type enum. choice: 'batch', 'fifo', 'idle', 'other', 'rr'.  > 

=head2 CPUSchedulingPriority

Sets the CPU scheduling priority for executed processes. The available priority range
depends on the selected CPU scheduling policy (see above). For real-time scheduling policies an
integer between 1 (lowest priority) and 99 (highest priority) can be used. In case of CPU resource
contention, smaller values mean less CPU time is made available to the service, larger values mean
more. See L<sched_setscheduler(2)>
for details. I< Optional. Type uniline.  > 

=head2 CPUSchedulingResetOnFork

Takes a boolean argument. If true, elevated CPU scheduling priorities and policies
will be reset when the executed processes call
L<fork(2)>,
and can hence not leak into child processes. See
L<sched_setscheduler(2)>
for details. Defaults to false. I< Optional. Type boolean.  > 

=over 4

=item upstream_default value :

no

=back



=head2 CPUAffinity

Controls the CPU affinity of the executed processes. Takes a list of CPU indices or ranges
separated by either whitespace or commas. Alternatively, takes a special "numa" value in which case systemd
automatically derives allowed CPU range based on the value of C<NUMAMask> option. CPU ranges
are specified by the lower and upper CPU indices separated by a dash. This option may be specified more than
once, in which case the specified CPU affinity masks are merged. If the empty string is assigned, the mask
is reset, all assignments prior to this will have no effect. See
L<sched_setaffinity(2)> for
details. I< Optional. Type list of uniline.  > 

=head2 NUMAPolicy

Controls the NUMA memory policy of the executed processes. Takes a policy type, one of:
C<default>, C<preferred>, C<bind>, C<interleave> and
C<local>. A list of NUMA nodes that should be associated with the policy must be specified
in C<NUMAMask>. For more details on each policy please see,
L<set_mempolicy(2)>. For overall
overview of NUMA support in Linux see,
L<numa(7)>.
I< Optional. Type uniline.  > 

=head2 NUMAMask

Controls the NUMA node list which will be applied alongside with selected NUMA policy.
Takes a list of NUMA nodes and has the same syntax as a list of CPUs for C<CPUAffinity>
option or special "all" value which will include all available NUMA nodes in the mask. Note that the list
of NUMA nodes is not required for C<default> and C<local>
policies and for C<preferred> policy we expect a single NUMA node. I< Optional. Type uniline.  > 

=head2 IOSchedulingClass

Sets the I/O scheduling class for executed processes. Takes one of the strings
C<realtime>, C<best-effort> or C<idle>. The kernel's
default scheduling class is C<best-effort> at a priority of 4. If the empty string is
assigned to this option, all prior assignments to both C<IOSchedulingClass> and
C<IOSchedulingPriority> have no effect. See
L<ioprio_set(2)> for
details. I< Optional. Type enum. choice: '0', '1', '2', '3', 'none', 'realtime', 'best-effort', 'idle'.  > 

=head2 IOSchedulingPriority

Sets the I/O scheduling priority for executed processes. Takes an integer between 0
(highest priority) and 7 (lowest priority). In case of I/O contention, smaller values mean more I/O
bandwidth is made available to the unit's processes, larger values mean less bandwidth. The available
priorities depend on the selected I/O scheduling class (see above). If the empty string is assigned
to this option, all prior assignments to both C<IOSchedulingClass> and
C<IOSchedulingPriority> have no effect. For the kernel's default scheduling class
(C<best-effort>) this defaults to 4. See
L<ioprio_set(2)> for
details. I< Optional. Type integer.  > 

=over 4

=item upstream_default value :

4

=back



=head2 ProtectSystem

Takes a boolean argument or the special values C<full> or
C<strict>. If true, mounts the C</usr/> and the boot loader
directories (C</boot> and C</efi>) read-only for processes
invoked by this unit. If set to C<full>, the C</etc/> directory is
mounted read-only, too. If set to C<strict> the entire file system hierarchy is
mounted read-only, except for the API file system subtrees C</dev/>,
C</proc/> and C</sys/> (protect these directories using
C<PrivateDevices>, C<ProtectKernelTunables>,
C<ProtectControlGroups>). This setting ensures that any modification of the
vendor-supplied operating system (and optionally its configuration, and local mounts) is prohibited
for the service. It is recommended to enable this setting for all long-running services, unless they
are involved with system updates or need to modify the operating system in other ways. If this option
is used, C<ReadWritePaths> may be used to exclude specific directories from being
made read-only. Similar, C<StateDirectory>, C<LogsDirectory>, … and
related directory settings (see below) also exclude the specific directories from the effect of
C<ProtectSystem>. This setting is implied if C<DynamicUser> is
set. This setting cannot ensure protection in all cases. In general it has the same limitations as
C<ReadOnlyPaths>, see below. Defaults to off.

Note that if C<ProtectSystem> is set to C<strict> and
C<PrivateTmp> is enabled, then C</tmp/> and
C</var/tmp/> will be writable. I< Optional. Type enum. choice: 'full', 'no', 'strict', 'yes'.  > 

=over 4

=item upstream_default value :

no

=back



=head2 ProtectHome

Takes a boolean argument or the special values C<read-only> or
C<tmpfs>. If true, the directories C</home/>,
C</root>, and C</run/user> are made inaccessible and empty for
processes invoked by this unit. If set to C<read-only>, the three directories are
made read-only instead. If set to C<tmpfs>, temporary file systems are mounted on the
three directories in read-only mode. The value C<tmpfs> is useful to hide home
directories not relevant to the processes invoked by the unit, while still allowing necessary
directories to be made visible when listed in C<BindPaths> or
C<BindReadOnlyPaths>.

Setting this to C<yes> is mostly equivalent to setting the three directories in
C<InaccessiblePaths>. Similarly, C<read-only> is mostly equivalent to
C<ReadOnlyPaths>, and C<tmpfs> is mostly equivalent to
C<TemporaryFileSystem> with C<:ro>.

It is recommended to enable this setting for all long-running services (in particular
network-facing ones), to ensure they cannot get access to private user data, unless the services
actually require access to the user's private data. This setting is implied if
C<DynamicUser> is set. This setting cannot ensure protection in all cases. In
general it has the same limitations as C<ReadOnlyPaths>, see below. I< Optional. Type enum. choice: 'no', 'read-only', 'tmpfs', 'yes'.  > 

=head2 RuntimeDirectory

These options take a whitespace-separated list of directory names. The specified
directory names must be relative, and may not include C<..>. If set, when the unit is
started, one or more directories by the specified names will be created (including their parents)
below the locations defined in the following table. Also, the corresponding environment variable will
be defined with the full paths of the directories. If multiple directories are set, then in the
environment variable the paths are concatenated with colon (C<:>).

If C<DynamicUser> is used, and if the kernel version supports
L<id-mapped mounts|https://lwn.net/Articles/896255/>, the specified directories will
be owned by "nobody" in the host namespace and will be mapped to (and will be owned by) the service's
UID/GID in its own namespace. For backward compatibility, existing directories created without id-mapped
mounts will be kept untouched.

In case of C<RuntimeDirectory> the innermost subdirectories are removed when
the unit is stopped. It is possible to preserve the specified directories in this case if
C<RuntimeDirectoryPreserve> is configured to C<restart> or
C<yes> (see below). The directories specified with C<StateDirectory>,
C<CacheDirectory>, C<LogsDirectory>,
C<ConfigurationDirectory> are not removed when the unit is stopped.

Except in case of C<ConfigurationDirectory>, the innermost specified directories will be
owned by the user and group specified in C<User> and C<Group>. If the
specified directories already exist and their owning user or group do not match the configured ones, all files
and directories below the specified directories as well as the directories themselves will have their file
ownership recursively changed to match what is configured. As an optimization, if the specified directories are
already owned by the right user and group, files and directories below of them are left as-is, even if they do
not match what is requested. The innermost specified directories will have their access mode adjusted to the
what is specified in C<RuntimeDirectoryMode>, C<StateDirectoryMode>,
C<CacheDirectoryMode>, C<LogsDirectoryMode> and
C<ConfigurationDirectoryMode>.

These options imply C<BindPaths> for the specified paths. When combined with
C<RootDirectory> or C<RootImage> these paths always reside on the host and
are mounted from there into the unit's file system namespace.

If C<DynamicUser> is used, the logic for C<CacheDirectory>,
C<LogsDirectory> and C<StateDirectory> is slightly altered: the directories are created below
C</var/cache/private>, C</var/log/private> and C</var/lib/private>,
respectively, which are host directories made inaccessible to
unprivileged users, which ensures that access to these directories cannot be gained through dynamic
user ID recycling. Symbolic links are created to hide this difference in behaviour. Both from
perspective of the host and from inside the unit, the relevant directories hence always appear
directly below C</var/cache>, C</var/log> and
C</var/lib>.

Use C<RuntimeDirectory> to manage one or more runtime directories for the unit and bind
their lifetime to the daemon runtime. This is particularly useful for unprivileged daemons that cannot create
runtime directories in C</run/> due to lack of privileges, and to make sure the runtime
directory is cleaned up automatically after use. For runtime directories that require more complex or different
configuration or lifetime guarantees, please consider using
L<tmpfiles.d(5)>.

C<RuntimeDirectory>, C<StateDirectory>,
C<CacheDirectory> and C<LogsDirectory>	optionally support two
more parameters, separated by C<:>. The second parameter will be interpreted as a
destination path that will be created as a symlink to the directory. The symlinks will be created
after any C<BindPaths> or C<TemporaryFileSystem> options have been
set up, to make ephemeral symlinking possible. The same source can have multiple symlinks, by using
the same first parameter, but a different second parameter. The third parameter is a flags field,
and since v257 can take a value of C<ro> to make the directory read only for the
service. This is also supported for C<ConfigurationDirectory>. If multiple symlinks
are set up, the directory will be read only if at least one is configured to be read only. To pass a
flag without a destination symlink, the second parameter can be empty, for example:

    ConfigurationDirectory=foo::ro

The directories defined by these options are always created under the standard paths used by systemd
(C</var/>, C</run/>, C</etc/>, …). If the service needs
directories in a different location, a different mechanism has to be used to create them.

L<tmpfiles.d(5)> provides
functionality that overlaps with these options. Using these options is recommended, because the lifetime of
the directories is tied directly to the lifetime of the unit, and it is not necessary to ensure that the
C<tmpfiles.d> configuration is executed before the unit is started.

To remove any of the directories created by these settings, use the systemctl clean
… command on the relevant units, see
L<systemctl(1)> for
details.

Example: if a system service unit has the following,

    RuntimeDirectory=foo/bar baz

the service manager creates C</run/foo> (if it does not exist),
C</run/foo/bar>, and C</run/baz>. The
directories C</run/foo/bar> and
C</run/baz> except C</run/foo> are
owned by the user and group specified in C<User> and C<Group>, and removed
when the service is stopped.

Example: if a system service unit has the following,

    RuntimeDirectory=foo/bar
    StateDirectory=aaa/bbb ccc

then the environment variable C<RUNTIME_DIRECTORY> is set with C</run/foo/bar>, and
C<STATE_DIRECTORY> is set with C</var/lib/aaa/bbb:/var/lib/ccc>.

Example: if a system service unit has the following,

    RuntimeDirectory=foo:bar foo:baz

the service manager creates C</run/foo> (if it does not exist), and
C</run/bar> plus C</run/baz> as symlinks to
C</run/foo>. I< Optional. Type uniline.  > 

=head2 StateDirectory

These options take a whitespace-separated list of directory names. The specified
directory names must be relative, and may not include C<..>. If set, when the unit is
started, one or more directories by the specified names will be created (including their parents)
below the locations defined in the following table. Also, the corresponding environment variable will
be defined with the full paths of the directories. If multiple directories are set, then in the
environment variable the paths are concatenated with colon (C<:>).

If C<DynamicUser> is used, and if the kernel version supports
L<id-mapped mounts|https://lwn.net/Articles/896255/>, the specified directories will
be owned by "nobody" in the host namespace and will be mapped to (and will be owned by) the service's
UID/GID in its own namespace. For backward compatibility, existing directories created without id-mapped
mounts will be kept untouched.

In case of C<RuntimeDirectory> the innermost subdirectories are removed when
the unit is stopped. It is possible to preserve the specified directories in this case if
C<RuntimeDirectoryPreserve> is configured to C<restart> or
C<yes> (see below). The directories specified with C<StateDirectory>,
C<CacheDirectory>, C<LogsDirectory>,
C<ConfigurationDirectory> are not removed when the unit is stopped.

Except in case of C<ConfigurationDirectory>, the innermost specified directories will be
owned by the user and group specified in C<User> and C<Group>. If the
specified directories already exist and their owning user or group do not match the configured ones, all files
and directories below the specified directories as well as the directories themselves will have their file
ownership recursively changed to match what is configured. As an optimization, if the specified directories are
already owned by the right user and group, files and directories below of them are left as-is, even if they do
not match what is requested. The innermost specified directories will have their access mode adjusted to the
what is specified in C<RuntimeDirectoryMode>, C<StateDirectoryMode>,
C<CacheDirectoryMode>, C<LogsDirectoryMode> and
C<ConfigurationDirectoryMode>.

These options imply C<BindPaths> for the specified paths. When combined with
C<RootDirectory> or C<RootImage> these paths always reside on the host and
are mounted from there into the unit's file system namespace.

If C<DynamicUser> is used, the logic for C<CacheDirectory>,
C<LogsDirectory> and C<StateDirectory> is slightly altered: the directories are created below
C</var/cache/private>, C</var/log/private> and C</var/lib/private>,
respectively, which are host directories made inaccessible to
unprivileged users, which ensures that access to these directories cannot be gained through dynamic
user ID recycling. Symbolic links are created to hide this difference in behaviour. Both from
perspective of the host and from inside the unit, the relevant directories hence always appear
directly below C</var/cache>, C</var/log> and
C</var/lib>.

Use C<RuntimeDirectory> to manage one or more runtime directories for the unit and bind
their lifetime to the daemon runtime. This is particularly useful for unprivileged daemons that cannot create
runtime directories in C</run/> due to lack of privileges, and to make sure the runtime
directory is cleaned up automatically after use. For runtime directories that require more complex or different
configuration or lifetime guarantees, please consider using
L<tmpfiles.d(5)>.

C<RuntimeDirectory>, C<StateDirectory>,
C<CacheDirectory> and C<LogsDirectory>	optionally support two
more parameters, separated by C<:>. The second parameter will be interpreted as a
destination path that will be created as a symlink to the directory. The symlinks will be created
after any C<BindPaths> or C<TemporaryFileSystem> options have been
set up, to make ephemeral symlinking possible. The same source can have multiple symlinks, by using
the same first parameter, but a different second parameter. The third parameter is a flags field,
and since v257 can take a value of C<ro> to make the directory read only for the
service. This is also supported for C<ConfigurationDirectory>. If multiple symlinks
are set up, the directory will be read only if at least one is configured to be read only. To pass a
flag without a destination symlink, the second parameter can be empty, for example:

    ConfigurationDirectory=foo::ro

The directories defined by these options are always created under the standard paths used by systemd
(C</var/>, C</run/>, C</etc/>, …). If the service needs
directories in a different location, a different mechanism has to be used to create them.

L<tmpfiles.d(5)> provides
functionality that overlaps with these options. Using these options is recommended, because the lifetime of
the directories is tied directly to the lifetime of the unit, and it is not necessary to ensure that the
C<tmpfiles.d> configuration is executed before the unit is started.

To remove any of the directories created by these settings, use the systemctl clean
… command on the relevant units, see
L<systemctl(1)> for
details.

Example: if a system service unit has the following,

    RuntimeDirectory=foo/bar baz

the service manager creates C</run/foo> (if it does not exist),
C</run/foo/bar>, and C</run/baz>. The
directories C</run/foo/bar> and
C</run/baz> except C</run/foo> are
owned by the user and group specified in C<User> and C<Group>, and removed
when the service is stopped.

Example: if a system service unit has the following,

    RuntimeDirectory=foo/bar
    StateDirectory=aaa/bbb ccc

then the environment variable C<RUNTIME_DIRECTORY> is set with C</run/foo/bar>, and
C<STATE_DIRECTORY> is set with C</var/lib/aaa/bbb:/var/lib/ccc>.

Example: if a system service unit has the following,

    RuntimeDirectory=foo:bar foo:baz

the service manager creates C</run/foo> (if it does not exist), and
C</run/bar> plus C</run/baz> as symlinks to
C</run/foo>. I< Optional. Type uniline.  > 

=head2 CacheDirectory

These options take a whitespace-separated list of directory names. The specified
directory names must be relative, and may not include C<..>. If set, when the unit is
started, one or more directories by the specified names will be created (including their parents)
below the locations defined in the following table. Also, the corresponding environment variable will
be defined with the full paths of the directories. If multiple directories are set, then in the
environment variable the paths are concatenated with colon (C<:>).

If C<DynamicUser> is used, and if the kernel version supports
L<id-mapped mounts|https://lwn.net/Articles/896255/>, the specified directories will
be owned by "nobody" in the host namespace and will be mapped to (and will be owned by) the service's
UID/GID in its own namespace. For backward compatibility, existing directories created without id-mapped
mounts will be kept untouched.

In case of C<RuntimeDirectory> the innermost subdirectories are removed when
the unit is stopped. It is possible to preserve the specified directories in this case if
C<RuntimeDirectoryPreserve> is configured to C<restart> or
C<yes> (see below). The directories specified with C<StateDirectory>,
C<CacheDirectory>, C<LogsDirectory>,
C<ConfigurationDirectory> are not removed when the unit is stopped.

Except in case of C<ConfigurationDirectory>, the innermost specified directories will be
owned by the user and group specified in C<User> and C<Group>. If the
specified directories already exist and their owning user or group do not match the configured ones, all files
and directories below the specified directories as well as the directories themselves will have their file
ownership recursively changed to match what is configured. As an optimization, if the specified directories are
already owned by the right user and group, files and directories below of them are left as-is, even if they do
not match what is requested. The innermost specified directories will have their access mode adjusted to the
what is specified in C<RuntimeDirectoryMode>, C<StateDirectoryMode>,
C<CacheDirectoryMode>, C<LogsDirectoryMode> and
C<ConfigurationDirectoryMode>.

These options imply C<BindPaths> for the specified paths. When combined with
C<RootDirectory> or C<RootImage> these paths always reside on the host and
are mounted from there into the unit's file system namespace.

If C<DynamicUser> is used, the logic for C<CacheDirectory>,
C<LogsDirectory> and C<StateDirectory> is slightly altered: the directories are created below
C</var/cache/private>, C</var/log/private> and C</var/lib/private>,
respectively, which are host directories made inaccessible to
unprivileged users, which ensures that access to these directories cannot be gained through dynamic
user ID recycling. Symbolic links are created to hide this difference in behaviour. Both from
perspective of the host and from inside the unit, the relevant directories hence always appear
directly below C</var/cache>, C</var/log> and
C</var/lib>.

Use C<RuntimeDirectory> to manage one or more runtime directories for the unit and bind
their lifetime to the daemon runtime. This is particularly useful for unprivileged daemons that cannot create
runtime directories in C</run/> due to lack of privileges, and to make sure the runtime
directory is cleaned up automatically after use. For runtime directories that require more complex or different
configuration or lifetime guarantees, please consider using
L<tmpfiles.d(5)>.

C<RuntimeDirectory>, C<StateDirectory>,
C<CacheDirectory> and C<LogsDirectory>	optionally support two
more parameters, separated by C<:>. The second parameter will be interpreted as a
destination path that will be created as a symlink to the directory. The symlinks will be created
after any C<BindPaths> or C<TemporaryFileSystem> options have been
set up, to make ephemeral symlinking possible. The same source can have multiple symlinks, by using
the same first parameter, but a different second parameter. The third parameter is a flags field,
and since v257 can take a value of C<ro> to make the directory read only for the
service. This is also supported for C<ConfigurationDirectory>. If multiple symlinks
are set up, the directory will be read only if at least one is configured to be read only. To pass a
flag without a destination symlink, the second parameter can be empty, for example:

    ConfigurationDirectory=foo::ro

The directories defined by these options are always created under the standard paths used by systemd
(C</var/>, C</run/>, C</etc/>, …). If the service needs
directories in a different location, a different mechanism has to be used to create them.

L<tmpfiles.d(5)> provides
functionality that overlaps with these options. Using these options is recommended, because the lifetime of
the directories is tied directly to the lifetime of the unit, and it is not necessary to ensure that the
C<tmpfiles.d> configuration is executed before the unit is started.

To remove any of the directories created by these settings, use the systemctl clean
… command on the relevant units, see
L<systemctl(1)> for
details.

Example: if a system service unit has the following,

    RuntimeDirectory=foo/bar baz

the service manager creates C</run/foo> (if it does not exist),
C</run/foo/bar>, and C</run/baz>. The
directories C</run/foo/bar> and
C</run/baz> except C</run/foo> are
owned by the user and group specified in C<User> and C<Group>, and removed
when the service is stopped.

Example: if a system service unit has the following,

    RuntimeDirectory=foo/bar
    StateDirectory=aaa/bbb ccc

then the environment variable C<RUNTIME_DIRECTORY> is set with C</run/foo/bar>, and
C<STATE_DIRECTORY> is set with C</var/lib/aaa/bbb:/var/lib/ccc>.

Example: if a system service unit has the following,

    RuntimeDirectory=foo:bar foo:baz

the service manager creates C</run/foo> (if it does not exist), and
C</run/bar> plus C</run/baz> as symlinks to
C</run/foo>. I< Optional. Type uniline.  > 

=head2 LogsDirectory

These options take a whitespace-separated list of directory names. The specified
directory names must be relative, and may not include C<..>. If set, when the unit is
started, one or more directories by the specified names will be created (including their parents)
below the locations defined in the following table. Also, the corresponding environment variable will
be defined with the full paths of the directories. If multiple directories are set, then in the
environment variable the paths are concatenated with colon (C<:>).

If C<DynamicUser> is used, and if the kernel version supports
L<id-mapped mounts|https://lwn.net/Articles/896255/>, the specified directories will
be owned by "nobody" in the host namespace and will be mapped to (and will be owned by) the service's
UID/GID in its own namespace. For backward compatibility, existing directories created without id-mapped
mounts will be kept untouched.

In case of C<RuntimeDirectory> the innermost subdirectories are removed when
the unit is stopped. It is possible to preserve the specified directories in this case if
C<RuntimeDirectoryPreserve> is configured to C<restart> or
C<yes> (see below). The directories specified with C<StateDirectory>,
C<CacheDirectory>, C<LogsDirectory>,
C<ConfigurationDirectory> are not removed when the unit is stopped.

Except in case of C<ConfigurationDirectory>, the innermost specified directories will be
owned by the user and group specified in C<User> and C<Group>. If the
specified directories already exist and their owning user or group do not match the configured ones, all files
and directories below the specified directories as well as the directories themselves will have their file
ownership recursively changed to match what is configured. As an optimization, if the specified directories are
already owned by the right user and group, files and directories below of them are left as-is, even if they do
not match what is requested. The innermost specified directories will have their access mode adjusted to the
what is specified in C<RuntimeDirectoryMode>, C<StateDirectoryMode>,
C<CacheDirectoryMode>, C<LogsDirectoryMode> and
C<ConfigurationDirectoryMode>.

These options imply C<BindPaths> for the specified paths. When combined with
C<RootDirectory> or C<RootImage> these paths always reside on the host and
are mounted from there into the unit's file system namespace.

If C<DynamicUser> is used, the logic for C<CacheDirectory>,
C<LogsDirectory> and C<StateDirectory> is slightly altered: the directories are created below
C</var/cache/private>, C</var/log/private> and C</var/lib/private>,
respectively, which are host directories made inaccessible to
unprivileged users, which ensures that access to these directories cannot be gained through dynamic
user ID recycling. Symbolic links are created to hide this difference in behaviour. Both from
perspective of the host and from inside the unit, the relevant directories hence always appear
directly below C</var/cache>, C</var/log> and
C</var/lib>.

Use C<RuntimeDirectory> to manage one or more runtime directories for the unit and bind
their lifetime to the daemon runtime. This is particularly useful for unprivileged daemons that cannot create
runtime directories in C</run/> due to lack of privileges, and to make sure the runtime
directory is cleaned up automatically after use. For runtime directories that require more complex or different
configuration or lifetime guarantees, please consider using
L<tmpfiles.d(5)>.

C<RuntimeDirectory>, C<StateDirectory>,
C<CacheDirectory> and C<LogsDirectory>	optionally support two
more parameters, separated by C<:>. The second parameter will be interpreted as a
destination path that will be created as a symlink to the directory. The symlinks will be created
after any C<BindPaths> or C<TemporaryFileSystem> options have been
set up, to make ephemeral symlinking possible. The same source can have multiple symlinks, by using
the same first parameter, but a different second parameter. The third parameter is a flags field,
and since v257 can take a value of C<ro> to make the directory read only for the
service. This is also supported for C<ConfigurationDirectory>. If multiple symlinks
are set up, the directory will be read only if at least one is configured to be read only. To pass a
flag without a destination symlink, the second parameter can be empty, for example:

    ConfigurationDirectory=foo::ro

The directories defined by these options are always created under the standard paths used by systemd
(C</var/>, C</run/>, C</etc/>, …). If the service needs
directories in a different location, a different mechanism has to be used to create them.

L<tmpfiles.d(5)> provides
functionality that overlaps with these options. Using these options is recommended, because the lifetime of
the directories is tied directly to the lifetime of the unit, and it is not necessary to ensure that the
C<tmpfiles.d> configuration is executed before the unit is started.

To remove any of the directories created by these settings, use the systemctl clean
… command on the relevant units, see
L<systemctl(1)> for
details.

Example: if a system service unit has the following,

    RuntimeDirectory=foo/bar baz

the service manager creates C</run/foo> (if it does not exist),
C</run/foo/bar>, and C</run/baz>. The
directories C</run/foo/bar> and
C</run/baz> except C</run/foo> are
owned by the user and group specified in C<User> and C<Group>, and removed
when the service is stopped.

Example: if a system service unit has the following,

    RuntimeDirectory=foo/bar
    StateDirectory=aaa/bbb ccc

then the environment variable C<RUNTIME_DIRECTORY> is set with C</run/foo/bar>, and
C<STATE_DIRECTORY> is set with C</var/lib/aaa/bbb:/var/lib/ccc>.

Example: if a system service unit has the following,

    RuntimeDirectory=foo:bar foo:baz

the service manager creates C</run/foo> (if it does not exist), and
C</run/bar> plus C</run/baz> as symlinks to
C</run/foo>. I< Optional. Type uniline.  > 

=head2 ConfigurationDirectory

These options take a whitespace-separated list of directory names. The specified
directory names must be relative, and may not include C<..>. If set, when the unit is
started, one or more directories by the specified names will be created (including their parents)
below the locations defined in the following table. Also, the corresponding environment variable will
be defined with the full paths of the directories. If multiple directories are set, then in the
environment variable the paths are concatenated with colon (C<:>).

If C<DynamicUser> is used, and if the kernel version supports
L<id-mapped mounts|https://lwn.net/Articles/896255/>, the specified directories will
be owned by "nobody" in the host namespace and will be mapped to (and will be owned by) the service's
UID/GID in its own namespace. For backward compatibility, existing directories created without id-mapped
mounts will be kept untouched.

In case of C<RuntimeDirectory> the innermost subdirectories are removed when
the unit is stopped. It is possible to preserve the specified directories in this case if
C<RuntimeDirectoryPreserve> is configured to C<restart> or
C<yes> (see below). The directories specified with C<StateDirectory>,
C<CacheDirectory>, C<LogsDirectory>,
C<ConfigurationDirectory> are not removed when the unit is stopped.

Except in case of C<ConfigurationDirectory>, the innermost specified directories will be
owned by the user and group specified in C<User> and C<Group>. If the
specified directories already exist and their owning user or group do not match the configured ones, all files
and directories below the specified directories as well as the directories themselves will have their file
ownership recursively changed to match what is configured. As an optimization, if the specified directories are
already owned by the right user and group, files and directories below of them are left as-is, even if they do
not match what is requested. The innermost specified directories will have their access mode adjusted to the
what is specified in C<RuntimeDirectoryMode>, C<StateDirectoryMode>,
C<CacheDirectoryMode>, C<LogsDirectoryMode> and
C<ConfigurationDirectoryMode>.

These options imply C<BindPaths> for the specified paths. When combined with
C<RootDirectory> or C<RootImage> these paths always reside on the host and
are mounted from there into the unit's file system namespace.

If C<DynamicUser> is used, the logic for C<CacheDirectory>,
C<LogsDirectory> and C<StateDirectory> is slightly altered: the directories are created below
C</var/cache/private>, C</var/log/private> and C</var/lib/private>,
respectively, which are host directories made inaccessible to
unprivileged users, which ensures that access to these directories cannot be gained through dynamic
user ID recycling. Symbolic links are created to hide this difference in behaviour. Both from
perspective of the host and from inside the unit, the relevant directories hence always appear
directly below C</var/cache>, C</var/log> and
C</var/lib>.

Use C<RuntimeDirectory> to manage one or more runtime directories for the unit and bind
their lifetime to the daemon runtime. This is particularly useful for unprivileged daemons that cannot create
runtime directories in C</run/> due to lack of privileges, and to make sure the runtime
directory is cleaned up automatically after use. For runtime directories that require more complex or different
configuration or lifetime guarantees, please consider using
L<tmpfiles.d(5)>.

C<RuntimeDirectory>, C<StateDirectory>,
C<CacheDirectory> and C<LogsDirectory>	optionally support two
more parameters, separated by C<:>. The second parameter will be interpreted as a
destination path that will be created as a symlink to the directory. The symlinks will be created
after any C<BindPaths> or C<TemporaryFileSystem> options have been
set up, to make ephemeral symlinking possible. The same source can have multiple symlinks, by using
the same first parameter, but a different second parameter. The third parameter is a flags field,
and since v257 can take a value of C<ro> to make the directory read only for the
service. This is also supported for C<ConfigurationDirectory>. If multiple symlinks
are set up, the directory will be read only if at least one is configured to be read only. To pass a
flag without a destination symlink, the second parameter can be empty, for example:

    ConfigurationDirectory=foo::ro

The directories defined by these options are always created under the standard paths used by systemd
(C</var/>, C</run/>, C</etc/>, …). If the service needs
directories in a different location, a different mechanism has to be used to create them.

L<tmpfiles.d(5)> provides
functionality that overlaps with these options. Using these options is recommended, because the lifetime of
the directories is tied directly to the lifetime of the unit, and it is not necessary to ensure that the
C<tmpfiles.d> configuration is executed before the unit is started.

To remove any of the directories created by these settings, use the systemctl clean
… command on the relevant units, see
L<systemctl(1)> for
details.

Example: if a system service unit has the following,

    RuntimeDirectory=foo/bar baz

the service manager creates C</run/foo> (if it does not exist),
C</run/foo/bar>, and C</run/baz>. The
directories C</run/foo/bar> and
C</run/baz> except C</run/foo> are
owned by the user and group specified in C<User> and C<Group>, and removed
when the service is stopped.

Example: if a system service unit has the following,

    RuntimeDirectory=foo/bar
    StateDirectory=aaa/bbb ccc

then the environment variable C<RUNTIME_DIRECTORY> is set with C</run/foo/bar>, and
C<STATE_DIRECTORY> is set with C</var/lib/aaa/bbb:/var/lib/ccc>.

Example: if a system service unit has the following,

    RuntimeDirectory=foo:bar foo:baz

the service manager creates C</run/foo> (if it does not exist), and
C</run/bar> plus C</run/baz> as symlinks to
C</run/foo>. I< Optional. Type uniline.  > 

=head2 RuntimeDirectoryMode

Specifies the access mode of the directories specified in C<RuntimeDirectory>,
C<StateDirectory>, C<CacheDirectory>, C<LogsDirectory>, or
C<ConfigurationDirectory>, respectively, as an octal number. Defaults to
C<0755>. See "Permissions" in L<path_resolution(7)> for a
discussion of the meaning of permission bits. I< Optional. Type uniline.  > 

=head2 StateDirectoryMode

Specifies the access mode of the directories specified in C<RuntimeDirectory>,
C<StateDirectory>, C<CacheDirectory>, C<LogsDirectory>, or
C<ConfigurationDirectory>, respectively, as an octal number. Defaults to
C<0755>. See "Permissions" in L<path_resolution(7)> for a
discussion of the meaning of permission bits. I< Optional. Type uniline.  > 

=head2 CacheDirectoryMode

Specifies the access mode of the directories specified in C<RuntimeDirectory>,
C<StateDirectory>, C<CacheDirectory>, C<LogsDirectory>, or
C<ConfigurationDirectory>, respectively, as an octal number. Defaults to
C<0755>. See "Permissions" in L<path_resolution(7)> for a
discussion of the meaning of permission bits. I< Optional. Type uniline.  > 

=head2 LogsDirectoryMode

Specifies the access mode of the directories specified in C<RuntimeDirectory>,
C<StateDirectory>, C<CacheDirectory>, C<LogsDirectory>, or
C<ConfigurationDirectory>, respectively, as an octal number. Defaults to
C<0755>. See "Permissions" in L<path_resolution(7)> for a
discussion of the meaning of permission bits. I< Optional. Type uniline.  > 

=head2 ConfigurationDirectoryMode

Specifies the access mode of the directories specified in C<RuntimeDirectory>,
C<StateDirectory>, C<CacheDirectory>, C<LogsDirectory>, or
C<ConfigurationDirectory>, respectively, as an octal number. Defaults to
C<0755>. See "Permissions" in L<path_resolution(7)> for a
discussion of the meaning of permission bits. I< Optional. Type uniline.  > 

=head2 StateDirectoryQuota

Specifies the storage limits for the directories specified in C<StateDirectory>,
C<CacheDirectory>, or C<LogsDirectory> respectively.

The storage quota is defined in terms of disk blocks and inodes, as per
L<quotactl|https://man7.org/linux/man-pages/man2/quotactl.2.html>. Takes an absolute size limit
in bytes. If the value is suffixed with K, M, G or T, the specified size is parsed as Kilobytes, Megabytes, Gigabytes,
or Terabytes (with the base 1024), respectively. If an absolute size limit is specified, only the block quota is set
(rounded up to the nearest block). Alternatively, a percentage value may be specified, which applies the same percent
quota to both blocks and inodes. Defaults to C<off>, in which case no storage limits will be set.

Only hard limits are set, not soft limits. If the underlying filesystem for the specified directories does not
support project quotas, the specified storage limits will not be set. In addition to enabling per-unit quotas with
these settings, it is necessary to enable C<prjquota> on the file system level as well
(i.e. tune2fs -Q prjquota). Quotas must also be turned on with
L<quotaon.|https://linux.die.net/man/8/quotaon> I< Optional. Type uniline.  > 

=head2 CacheDirectoryQuota

Specifies the storage limits for the directories specified in C<StateDirectory>,
C<CacheDirectory>, or C<LogsDirectory> respectively.

The storage quota is defined in terms of disk blocks and inodes, as per
L<quotactl|https://man7.org/linux/man-pages/man2/quotactl.2.html>. Takes an absolute size limit
in bytes. If the value is suffixed with K, M, G or T, the specified size is parsed as Kilobytes, Megabytes, Gigabytes,
or Terabytes (with the base 1024), respectively. If an absolute size limit is specified, only the block quota is set
(rounded up to the nearest block). Alternatively, a percentage value may be specified, which applies the same percent
quota to both blocks and inodes. Defaults to C<off>, in which case no storage limits will be set.

Only hard limits are set, not soft limits. If the underlying filesystem for the specified directories does not
support project quotas, the specified storage limits will not be set. In addition to enabling per-unit quotas with
these settings, it is necessary to enable C<prjquota> on the file system level as well
(i.e. tune2fs -Q prjquota). Quotas must also be turned on with
L<quotaon.|https://linux.die.net/man/8/quotaon> I< Optional. Type uniline.  > 

=head2 LogsDirectoryQuota

Specifies the storage limits for the directories specified in C<StateDirectory>,
C<CacheDirectory>, or C<LogsDirectory> respectively.

The storage quota is defined in terms of disk blocks and inodes, as per
L<quotactl|https://man7.org/linux/man-pages/man2/quotactl.2.html>. Takes an absolute size limit
in bytes. If the value is suffixed with K, M, G or T, the specified size is parsed as Kilobytes, Megabytes, Gigabytes,
or Terabytes (with the base 1024), respectively. If an absolute size limit is specified, only the block quota is set
(rounded up to the nearest block). Alternatively, a percentage value may be specified, which applies the same percent
quota to both blocks and inodes. Defaults to C<off>, in which case no storage limits will be set.

Only hard limits are set, not soft limits. If the underlying filesystem for the specified directories does not
support project quotas, the specified storage limits will not be set. In addition to enabling per-unit quotas with
these settings, it is necessary to enable C<prjquota> on the file system level as well
(i.e. tune2fs -Q prjquota). Quotas must also be turned on with
L<quotaon.|https://linux.die.net/man/8/quotaon> I< Optional. Type uniline.  > 

=head2 StateDirectoryAccounting

Takes a boolean argument. If true, a project ID is assigned to the directories specified in
C<StateDirectory>, C<CacheDirectory>, or C<LogsDirectory>
respectively, which is used for tracking disk usage when disk quotas are turned on
(see L<repquota|https://man7.org/linux/man-pages/man8/repquota.8.html>). Defaults to false.

To set and enforce disk quotas, C<StateDirectoryQuota>, C<CacheDirectoryQuota>,
or C<LogsDirectoryQuota> must be specified. I< Optional. Type boolean.  > 

=over 4

=item upstream_default value :

no

=back



=head2 CacheDirectoryAccounting

Takes a boolean argument. If true, a project ID is assigned to the directories specified in
C<StateDirectory>, C<CacheDirectory>, or C<LogsDirectory>
respectively, which is used for tracking disk usage when disk quotas are turned on
(see L<repquota|https://man7.org/linux/man-pages/man8/repquota.8.html>). Defaults to false.

To set and enforce disk quotas, C<StateDirectoryQuota>, C<CacheDirectoryQuota>,
or C<LogsDirectoryQuota> must be specified. I< Optional. Type boolean.  > 

=over 4

=item upstream_default value :

no

=back



=head2 LogsDirectoryAccounting

Takes a boolean argument. If true, a project ID is assigned to the directories specified in
C<StateDirectory>, C<CacheDirectory>, or C<LogsDirectory>
respectively, which is used for tracking disk usage when disk quotas are turned on
(see L<repquota|https://man7.org/linux/man-pages/man8/repquota.8.html>). Defaults to false.

To set and enforce disk quotas, C<StateDirectoryQuota>, C<CacheDirectoryQuota>,
or C<LogsDirectoryQuota> must be specified. I< Optional. Type boolean.  > 

=over 4

=item upstream_default value :

no

=back



=head2 RuntimeDirectoryPreserve

Takes a boolean argument or C<restart>. If set to C<no> (the
default), the directories specified in C<RuntimeDirectory> are always removed when the service
stops. If set to C<restart> the directories are preserved when the service is both automatically
and manually restarted. Here, the automatic restart means the operation specified in
C<Restart>, and manual restart means the one triggered by systemctl restart
foo.service. If set to C<yes>, then the directories are not removed when the service is
stopped. Note that since the runtime directory C</run/> is a mount point of
C<tmpfs>, then for system services the directories specified in
C<RuntimeDirectory> are removed when the system is rebooted. I< Optional. Type enum. choice: 'no', 'restart', 'yes'.  > 

=head2 TimeoutCleanSec

Configures a timeout on the clean-up operation requested through systemctl
clean …, see
L<systemctl(1)> for
details. Takes the usual time values and defaults to C<infinity>, i.e. by default
no timeout is applied. If a timeout is configured the clean operation will be aborted forcibly when
the timeout is reached, potentially leaving resources on disk. I< Optional. Type uniline.  > 

=head2 ReadWritePaths

Sets up a new file system namespace for executed processes. These options may be used
to limit access a process has to the file system. Each setting takes a space-separated list of paths
relative to the host's root directory (i.e. the system running the service manager). Note that if
paths contain symlinks, they are resolved relative to the root directory set with
C<RootDirectory>/C<RootImage>.

Paths listed in C<ReadWritePaths> are accessible from within the namespace
with the same access modes as from outside of it. Paths listed in C<ReadOnlyPaths>
are accessible for reading only, writing will be refused even if the usual file access controls would
permit this. Nest C<ReadWritePaths> inside of C<ReadOnlyPaths> in
order to provide writable subdirectories within read-only directories. Use
C<ReadWritePaths> in order to allow-list specific paths for write access if
C<ProtectSystem=strict> is used. Note that C<ReadWritePaths> cannot
be used to gain write access to a file system whose superblock is mounted read-only. On Linux, for
each mount point write access is granted only if the mount point itself and the
file system superblock backing it are not marked read-only. C<ReadWritePaths> only
controls the former, not the latter, hence a read-only file system superblock remains
protected.

Paths listed in C<InaccessiblePaths> will be made inaccessible for processes inside
the namespace along with everything below them in the file system hierarchy. This may be more restrictive than
desired, because it is not possible to nest C<ReadWritePaths>, C<ReadOnlyPaths>,
C<BindPaths>, or C<BindReadOnlyPaths> inside it. For a more flexible option,
see C<TemporaryFileSystem>.

Content in paths listed in C<NoExecPaths> are not executable even if the usual
file access controls would permit this. Nest C<ExecPaths> inside of
C<NoExecPaths> in order to provide executable content within non-executable
directories.

Non-directory paths may be specified as well. These options may be specified more than once,
in which case all paths listed will have limited access from within the namespace. If the empty string is
assigned to this option, the specific list is reset, and all prior assignments have no effect.

Paths in C<ReadWritePaths>, C<ReadOnlyPaths>,
C<InaccessiblePaths>, C<ExecPaths> and
C<NoExecPaths> may be prefixed with C<->, in which case they will be
ignored when they do not exist. If prefixed with C<+> the paths are taken relative to the root
directory of the unit, as configured with C<RootDirectory>/C<RootImage>,
instead of relative to the root directory of the host (see above). When combining C<-> and
C<+> on the same path make sure to specify C<-> first, and C<+>
second.

Note that these settings will disconnect propagation of mounts from the unit's processes to the
host. This means that this setting may not be used for services which shall be able to install mount points in
the main mount namespace. For C<ReadWritePaths> and C<ReadOnlyPaths>,
propagation in the other direction is not affected, i.e. mounts created on the host generally appear in the
unit processes' namespace, and mounts removed on the host also disappear there too. In particular, note that
mount propagation from host to unit will result in unmodified mounts to be created in the unit's namespace,
i.e. writable mounts appearing on the host will be writable in the unit's namespace too, even when propagated
below a path marked with C<ReadOnlyPaths>! Restricting access with these options hence does
not extend to submounts of a directory that are created later on. This means the lock-down offered by that
setting is not complete, and does not offer full protection.

Note that the effect of these settings may be undone by privileged processes. In order to set up an
effective sandboxed environment for a unit it is thus recommended to combine these settings with either
C<CapabilityBoundingSet=~CAP_SYS_ADMIN> or C<SystemCallFilter=~@mount>.

Please be extra careful when applying these options to API file systems (a list of them could be
found in C<MountAPIVPS>), since they may be required for basic system functionalities.
Moreover, C</run/> needs to be writable for setting up mount namespace and propagation.

Simple allow-list example using these directives:

    [Service]
    ReadOnlyPaths=/
    ReadWritePaths=/var /run
    InaccessiblePaths=-/lost+found
    NoExecPaths=/
    ExecPaths=/usr/sbin/my_daemon /usr/lib /usr/lib64
. I< Optional. Type list of uniline.  > 

=head2 ReadOnlyPaths

Sets up a new file system namespace for executed processes. These options may be used
to limit access a process has to the file system. Each setting takes a space-separated list of paths
relative to the host's root directory (i.e. the system running the service manager). Note that if
paths contain symlinks, they are resolved relative to the root directory set with
C<RootDirectory>/C<RootImage>.

Paths listed in C<ReadWritePaths> are accessible from within the namespace
with the same access modes as from outside of it. Paths listed in C<ReadOnlyPaths>
are accessible for reading only, writing will be refused even if the usual file access controls would
permit this. Nest C<ReadWritePaths> inside of C<ReadOnlyPaths> in
order to provide writable subdirectories within read-only directories. Use
C<ReadWritePaths> in order to allow-list specific paths for write access if
C<ProtectSystem=strict> is used. Note that C<ReadWritePaths> cannot
be used to gain write access to a file system whose superblock is mounted read-only. On Linux, for
each mount point write access is granted only if the mount point itself and the
file system superblock backing it are not marked read-only. C<ReadWritePaths> only
controls the former, not the latter, hence a read-only file system superblock remains
protected.

Paths listed in C<InaccessiblePaths> will be made inaccessible for processes inside
the namespace along with everything below them in the file system hierarchy. This may be more restrictive than
desired, because it is not possible to nest C<ReadWritePaths>, C<ReadOnlyPaths>,
C<BindPaths>, or C<BindReadOnlyPaths> inside it. For a more flexible option,
see C<TemporaryFileSystem>.

Content in paths listed in C<NoExecPaths> are not executable even if the usual
file access controls would permit this. Nest C<ExecPaths> inside of
C<NoExecPaths> in order to provide executable content within non-executable
directories.

Non-directory paths may be specified as well. These options may be specified more than once,
in which case all paths listed will have limited access from within the namespace. If the empty string is
assigned to this option, the specific list is reset, and all prior assignments have no effect.

Paths in C<ReadWritePaths>, C<ReadOnlyPaths>,
C<InaccessiblePaths>, C<ExecPaths> and
C<NoExecPaths> may be prefixed with C<->, in which case they will be
ignored when they do not exist. If prefixed with C<+> the paths are taken relative to the root
directory of the unit, as configured with C<RootDirectory>/C<RootImage>,
instead of relative to the root directory of the host (see above). When combining C<-> and
C<+> on the same path make sure to specify C<-> first, and C<+>
second.

Note that these settings will disconnect propagation of mounts from the unit's processes to the
host. This means that this setting may not be used for services which shall be able to install mount points in
the main mount namespace. For C<ReadWritePaths> and C<ReadOnlyPaths>,
propagation in the other direction is not affected, i.e. mounts created on the host generally appear in the
unit processes' namespace, and mounts removed on the host also disappear there too. In particular, note that
mount propagation from host to unit will result in unmodified mounts to be created in the unit's namespace,
i.e. writable mounts appearing on the host will be writable in the unit's namespace too, even when propagated
below a path marked with C<ReadOnlyPaths>! Restricting access with these options hence does
not extend to submounts of a directory that are created later on. This means the lock-down offered by that
setting is not complete, and does not offer full protection.

Note that the effect of these settings may be undone by privileged processes. In order to set up an
effective sandboxed environment for a unit it is thus recommended to combine these settings with either
C<CapabilityBoundingSet=~CAP_SYS_ADMIN> or C<SystemCallFilter=~@mount>.

Please be extra careful when applying these options to API file systems (a list of them could be
found in C<MountAPIVPS>), since they may be required for basic system functionalities.
Moreover, C</run/> needs to be writable for setting up mount namespace and propagation.

Simple allow-list example using these directives:

    [Service]
    ReadOnlyPaths=/
    ReadWritePaths=/var /run
    InaccessiblePaths=-/lost+found
    NoExecPaths=/
    ExecPaths=/usr/sbin/my_daemon /usr/lib /usr/lib64
. I< Optional. Type list of uniline.  > 

=head2 InaccessiblePaths

Sets up a new file system namespace for executed processes. These options may be used
to limit access a process has to the file system. Each setting takes a space-separated list of paths
relative to the host's root directory (i.e. the system running the service manager). Note that if
paths contain symlinks, they are resolved relative to the root directory set with
C<RootDirectory>/C<RootImage>.

Paths listed in C<ReadWritePaths> are accessible from within the namespace
with the same access modes as from outside of it. Paths listed in C<ReadOnlyPaths>
are accessible for reading only, writing will be refused even if the usual file access controls would
permit this. Nest C<ReadWritePaths> inside of C<ReadOnlyPaths> in
order to provide writable subdirectories within read-only directories. Use
C<ReadWritePaths> in order to allow-list specific paths for write access if
C<ProtectSystem=strict> is used. Note that C<ReadWritePaths> cannot
be used to gain write access to a file system whose superblock is mounted read-only. On Linux, for
each mount point write access is granted only if the mount point itself and the
file system superblock backing it are not marked read-only. C<ReadWritePaths> only
controls the former, not the latter, hence a read-only file system superblock remains
protected.

Paths listed in C<InaccessiblePaths> will be made inaccessible for processes inside
the namespace along with everything below them in the file system hierarchy. This may be more restrictive than
desired, because it is not possible to nest C<ReadWritePaths>, C<ReadOnlyPaths>,
C<BindPaths>, or C<BindReadOnlyPaths> inside it. For a more flexible option,
see C<TemporaryFileSystem>.

Content in paths listed in C<NoExecPaths> are not executable even if the usual
file access controls would permit this. Nest C<ExecPaths> inside of
C<NoExecPaths> in order to provide executable content within non-executable
directories.

Non-directory paths may be specified as well. These options may be specified more than once,
in which case all paths listed will have limited access from within the namespace. If the empty string is
assigned to this option, the specific list is reset, and all prior assignments have no effect.

Paths in C<ReadWritePaths>, C<ReadOnlyPaths>,
C<InaccessiblePaths>, C<ExecPaths> and
C<NoExecPaths> may be prefixed with C<->, in which case they will be
ignored when they do not exist. If prefixed with C<+> the paths are taken relative to the root
directory of the unit, as configured with C<RootDirectory>/C<RootImage>,
instead of relative to the root directory of the host (see above). When combining C<-> and
C<+> on the same path make sure to specify C<-> first, and C<+>
second.

Note that these settings will disconnect propagation of mounts from the unit's processes to the
host. This means that this setting may not be used for services which shall be able to install mount points in
the main mount namespace. For C<ReadWritePaths> and C<ReadOnlyPaths>,
propagation in the other direction is not affected, i.e. mounts created on the host generally appear in the
unit processes' namespace, and mounts removed on the host also disappear there too. In particular, note that
mount propagation from host to unit will result in unmodified mounts to be created in the unit's namespace,
i.e. writable mounts appearing on the host will be writable in the unit's namespace too, even when propagated
below a path marked with C<ReadOnlyPaths>! Restricting access with these options hence does
not extend to submounts of a directory that are created later on. This means the lock-down offered by that
setting is not complete, and does not offer full protection.

Note that the effect of these settings may be undone by privileged processes. In order to set up an
effective sandboxed environment for a unit it is thus recommended to combine these settings with either
C<CapabilityBoundingSet=~CAP_SYS_ADMIN> or C<SystemCallFilter=~@mount>.

Please be extra careful when applying these options to API file systems (a list of them could be
found in C<MountAPIVPS>), since they may be required for basic system functionalities.
Moreover, C</run/> needs to be writable for setting up mount namespace and propagation.

Simple allow-list example using these directives:

    [Service]
    ReadOnlyPaths=/
    ReadWritePaths=/var /run
    InaccessiblePaths=-/lost+found
    NoExecPaths=/
    ExecPaths=/usr/sbin/my_daemon /usr/lib /usr/lib64
. I< Optional. Type list of uniline.  > 

=head2 ExecPaths

Sets up a new file system namespace for executed processes. These options may be used
to limit access a process has to the file system. Each setting takes a space-separated list of paths
relative to the host's root directory (i.e. the system running the service manager). Note that if
paths contain symlinks, they are resolved relative to the root directory set with
C<RootDirectory>/C<RootImage>.

Paths listed in C<ReadWritePaths> are accessible from within the namespace
with the same access modes as from outside of it. Paths listed in C<ReadOnlyPaths>
are accessible for reading only, writing will be refused even if the usual file access controls would
permit this. Nest C<ReadWritePaths> inside of C<ReadOnlyPaths> in
order to provide writable subdirectories within read-only directories. Use
C<ReadWritePaths> in order to allow-list specific paths for write access if
C<ProtectSystem=strict> is used. Note that C<ReadWritePaths> cannot
be used to gain write access to a file system whose superblock is mounted read-only. On Linux, for
each mount point write access is granted only if the mount point itself and the
file system superblock backing it are not marked read-only. C<ReadWritePaths> only
controls the former, not the latter, hence a read-only file system superblock remains
protected.

Paths listed in C<InaccessiblePaths> will be made inaccessible for processes inside
the namespace along with everything below them in the file system hierarchy. This may be more restrictive than
desired, because it is not possible to nest C<ReadWritePaths>, C<ReadOnlyPaths>,
C<BindPaths>, or C<BindReadOnlyPaths> inside it. For a more flexible option,
see C<TemporaryFileSystem>.

Content in paths listed in C<NoExecPaths> are not executable even if the usual
file access controls would permit this. Nest C<ExecPaths> inside of
C<NoExecPaths> in order to provide executable content within non-executable
directories.

Non-directory paths may be specified as well. These options may be specified more than once,
in which case all paths listed will have limited access from within the namespace. If the empty string is
assigned to this option, the specific list is reset, and all prior assignments have no effect.

Paths in C<ReadWritePaths>, C<ReadOnlyPaths>,
C<InaccessiblePaths>, C<ExecPaths> and
C<NoExecPaths> may be prefixed with C<->, in which case they will be
ignored when they do not exist. If prefixed with C<+> the paths are taken relative to the root
directory of the unit, as configured with C<RootDirectory>/C<RootImage>,
instead of relative to the root directory of the host (see above). When combining C<-> and
C<+> on the same path make sure to specify C<-> first, and C<+>
second.

Note that these settings will disconnect propagation of mounts from the unit's processes to the
host. This means that this setting may not be used for services which shall be able to install mount points in
the main mount namespace. For C<ReadWritePaths> and C<ReadOnlyPaths>,
propagation in the other direction is not affected, i.e. mounts created on the host generally appear in the
unit processes' namespace, and mounts removed on the host also disappear there too. In particular, note that
mount propagation from host to unit will result in unmodified mounts to be created in the unit's namespace,
i.e. writable mounts appearing on the host will be writable in the unit's namespace too, even when propagated
below a path marked with C<ReadOnlyPaths>! Restricting access with these options hence does
not extend to submounts of a directory that are created later on. This means the lock-down offered by that
setting is not complete, and does not offer full protection.

Note that the effect of these settings may be undone by privileged processes. In order to set up an
effective sandboxed environment for a unit it is thus recommended to combine these settings with either
C<CapabilityBoundingSet=~CAP_SYS_ADMIN> or C<SystemCallFilter=~@mount>.

Please be extra careful when applying these options to API file systems (a list of them could be
found in C<MountAPIVPS>), since they may be required for basic system functionalities.
Moreover, C</run/> needs to be writable for setting up mount namespace and propagation.

Simple allow-list example using these directives:

    [Service]
    ReadOnlyPaths=/
    ReadWritePaths=/var /run
    InaccessiblePaths=-/lost+found
    NoExecPaths=/
    ExecPaths=/usr/sbin/my_daemon /usr/lib /usr/lib64
. I< Optional. Type list of uniline.  > 

=head2 NoExecPaths

Sets up a new file system namespace for executed processes. These options may be used
to limit access a process has to the file system. Each setting takes a space-separated list of paths
relative to the host's root directory (i.e. the system running the service manager). Note that if
paths contain symlinks, they are resolved relative to the root directory set with
C<RootDirectory>/C<RootImage>.

Paths listed in C<ReadWritePaths> are accessible from within the namespace
with the same access modes as from outside of it. Paths listed in C<ReadOnlyPaths>
are accessible for reading only, writing will be refused even if the usual file access controls would
permit this. Nest C<ReadWritePaths> inside of C<ReadOnlyPaths> in
order to provide writable subdirectories within read-only directories. Use
C<ReadWritePaths> in order to allow-list specific paths for write access if
C<ProtectSystem=strict> is used. Note that C<ReadWritePaths> cannot
be used to gain write access to a file system whose superblock is mounted read-only. On Linux, for
each mount point write access is granted only if the mount point itself and the
file system superblock backing it are not marked read-only. C<ReadWritePaths> only
controls the former, not the latter, hence a read-only file system superblock remains
protected.

Paths listed in C<InaccessiblePaths> will be made inaccessible for processes inside
the namespace along with everything below them in the file system hierarchy. This may be more restrictive than
desired, because it is not possible to nest C<ReadWritePaths>, C<ReadOnlyPaths>,
C<BindPaths>, or C<BindReadOnlyPaths> inside it. For a more flexible option,
see C<TemporaryFileSystem>.

Content in paths listed in C<NoExecPaths> are not executable even if the usual
file access controls would permit this. Nest C<ExecPaths> inside of
C<NoExecPaths> in order to provide executable content within non-executable
directories.

Non-directory paths may be specified as well. These options may be specified more than once,
in which case all paths listed will have limited access from within the namespace. If the empty string is
assigned to this option, the specific list is reset, and all prior assignments have no effect.

Paths in C<ReadWritePaths>, C<ReadOnlyPaths>,
C<InaccessiblePaths>, C<ExecPaths> and
C<NoExecPaths> may be prefixed with C<->, in which case they will be
ignored when they do not exist. If prefixed with C<+> the paths are taken relative to the root
directory of the unit, as configured with C<RootDirectory>/C<RootImage>,
instead of relative to the root directory of the host (see above). When combining C<-> and
C<+> on the same path make sure to specify C<-> first, and C<+>
second.

Note that these settings will disconnect propagation of mounts from the unit's processes to the
host. This means that this setting may not be used for services which shall be able to install mount points in
the main mount namespace. For C<ReadWritePaths> and C<ReadOnlyPaths>,
propagation in the other direction is not affected, i.e. mounts created on the host generally appear in the
unit processes' namespace, and mounts removed on the host also disappear there too. In particular, note that
mount propagation from host to unit will result in unmodified mounts to be created in the unit's namespace,
i.e. writable mounts appearing on the host will be writable in the unit's namespace too, even when propagated
below a path marked with C<ReadOnlyPaths>! Restricting access with these options hence does
not extend to submounts of a directory that are created later on. This means the lock-down offered by that
setting is not complete, and does not offer full protection.

Note that the effect of these settings may be undone by privileged processes. In order to set up an
effective sandboxed environment for a unit it is thus recommended to combine these settings with either
C<CapabilityBoundingSet=~CAP_SYS_ADMIN> or C<SystemCallFilter=~@mount>.

Please be extra careful when applying these options to API file systems (a list of them could be
found in C<MountAPIVPS>), since they may be required for basic system functionalities.
Moreover, C</run/> needs to be writable for setting up mount namespace and propagation.

Simple allow-list example using these directives:

    [Service]
    ReadOnlyPaths=/
    ReadWritePaths=/var /run
    InaccessiblePaths=-/lost+found
    NoExecPaths=/
    ExecPaths=/usr/sbin/my_daemon /usr/lib /usr/lib64
. I< Optional. Type list of uniline.  > 

=head2 TemporaryFileSystem

Takes a space-separated list of mount points for temporary file systems (tmpfs). If set, a new file
system namespace is set up for executed processes, and a temporary file system is mounted on each mount point.
This option may be specified more than once, in which case temporary file systems are mounted on all listed mount
points. If the empty string is assigned to this option, the list is reset, and all prior assignments have no effect.
Each mount point may optionally be suffixed with a colon (C<:>) and mount options such as
C<size=10%> or C<ro>. By default, each temporary file system is mounted
with C<nodev,strictatime,mode=0755>. These can be disabled by explicitly specifying the corresponding
mount options, e.g., C<dev> or C<nostrictatime>.

This is useful to hide files or directories not relevant to the processes invoked by the unit, while necessary
files or directories can be still accessed by combining with C<BindPaths> or
C<BindReadOnlyPaths>:

Example: if a unit has the following,

    TemporaryFileSystem=/var:ro
    BindReadOnlyPaths=/var/lib/systemd

then the invoked processes by the unit cannot see any files or directories under C</var/> except for
C</var/lib/systemd> or its contents. I< Optional. Type list of uniline.  > 

=head2 PrivateTmp

Takes a boolean argument, or C<disconnected>. If enabled, a new
file system namespace will be set up for the executed processes, and C</tmp/>
and C</var/tmp/> directories inside it are not shared with processes outside of
the namespace, plus all temporary files created by a service in these directories will be removed
after the service is stopped. For this setting, the same restrictions regarding mount propagation
and privileges apply as for C<ReadOnlyPaths> and related calls, see above. This
setting is useful to secure access to temporary files of the process, but makes sharing between
processes via C</tmp/> or C</var/tmp/> impossible. If
C<DynamicUser> is enabled, C<disconnected> is implied. Otherwise,
defaults to false.

If C<true>, the backing storage of the private temporary directories will
remain on the host's C</tmp/> and C</var/tmp/> directories. It is
possible to run two or more units within the same private C</tmp/> and
C</var/tmp/> namespace by using the C<JoinsNamespaceOf> directive,
see L<systemd.unit(5)>
for details. This has the side effect of adding C<Wants> and
C<After> dependencies on all mount units necessary to access
C</tmp/> and C</var/tmp/> on the host. Moreover, an implicit
C<After> ordering on
L<systemd-tmpfiles-setup.service(8)>
is added.

If C<disconnected>, the directories will be backed by a completely new tmpfs
instance, meaning that the storage is fully disconnected from the host namespace. The tmpfs instance
does not shared with other units even if the C<JoinsNamespaceOf> directive is used.
If C<DefaultDependencies=no> is specified,
C<RequiresMountsFor=/WantsMountsFor=> for C</var/> is not
specified, and C<RootDirectory=/RootImage=> is not specified, then a new tmpfs is
mounted only on C</tmp/>, hence the host's
C</var/tmp> is still accessible from the unit. In that case,
C<$TMPDIR> environment variable is set to C</tmp> to suggest the
processes in the unit to use C</tmp/>. This automatically adds
C<WantsMountsFor=/var/> dependency, unless C<DefaultDependencies=no>
and/or C<RootDirectory=/RootImage=> are specified.

Note that the implementation of this setting might be impossible (for example if mount namespaces are not
available), and the unit should be written in a way that does not solely rely on this setting for
security. I< Optional. Type enum. choice: 'disconnected', 'no', 'yes'.  > 

=head2 PrivateDevices

Takes a boolean argument. If true, sets up a new C</dev/> mount for
the executed processes and only adds API pseudo devices such as C</dev/null>,
C</dev/zero> or C</dev/random> (as well as the pseudo TTY
subsystem) to it, but no physical devices such as C</dev/sda>, system memory
C</dev/mem>, system ports C</dev/port> and others. This is useful
to turn off physical device access by the executed process. Defaults to false.

Enabling this option will install a system call filter to block low-level I/O system calls that
are grouped in the C<@raw-io> set, remove C<CAP_MKNOD> and
C<CAP_SYS_RAWIO> from the capability bounding set for the unit, and set
C<DevicePolicy=closed> (see
L<systemd.resource-control(5)>
for details). Note that using this setting will disconnect propagation of mounts from the service to
the host (propagation in the opposite direction continues to work). This means that this setting may
not be used for services which shall be able to install mount points in the main mount namespace. The
new C</dev/> will be mounted read-only and 'noexec'. The latter may break old
programs which try to set up executable memory by using
L<mmap(2)> of
C</dev/zero> instead of using C<MAP_ANON>. For this setting the
same restrictions regarding mount propagation and privileges apply as for
C<ReadOnlyPaths> and related calls, see above.

Note that the implementation of this setting might be impossible (for example if mount
namespaces are not available), and the unit should be written in a way that does not solely rely on
this setting for security.

When access to some but not all devices must be possible, the C<DeviceAllow>
setting might be used instead. See
L<systemd.resource-control(5)>.
I< Optional. Type boolean.  > 

=over 4

=item upstream_default value :

no

=back



=head2 PrivateNetwork

Takes a boolean argument. If true, sets up a new network namespace for the executed processes
and configures only the loopback network device C<lo> inside it. No other network devices will
be available to the executed process. This is useful to turn off network access by the executed process.
Defaults to false. It is possible to run two or more units within the same private network namespace by using
the C<JoinsNamespaceOf> directive, see
L<systemd.unit(5)> for
details. Note that this option will disconnect all socket families from the host, including
C<AF_NETLINK> and C<AF_UNIX>. Effectively, for
C<AF_NETLINK> this means that device configuration events received from
L<systemd-udevd.service(8)> are
not delivered to the unit's processes. And for C<AF_UNIX> this has the effect that
C<AF_UNIX> sockets in the abstract socket namespace of the host will become unavailable to
the unit's processes (however, those located in the file system will continue to be accessible).

Note that the implementation of this setting might be impossible (for example if network namespaces are
not available), and the unit should be written in a way that does not solely rely on this setting for
security.

When this option is enabled, C<PrivateMounts> is implied unless it is
explicitly disabled, and C</sys> will be remounted to associate it with the new
network namespace.

When this option is used on a socket unit any sockets bound on behalf of this unit will be
bound within a private network namespace. This may be combined with
C<JoinsNamespaceOf> to listen on sockets inside of network namespaces of other
services. I< Optional. Type boolean.  > 

=over 4

=item upstream_default value :

no

=back



=head2 NetworkNamespacePath

Takes an absolute file system path referring to a Linux network namespace
pseudo-file (i.e. a file like C</proc/$PID/ns/net> or a bind mount or symlink to
one). When set the invoked processes are added to the network namespace referenced by that path. The
path has to point to a valid namespace file at the moment the processes are forked off. If this
option is used C<PrivateNetwork> has no effect. If this option is used together with
C<JoinsNamespaceOf> then it only has an effect if this unit is started before any of
the listed units that have C<PrivateNetwork> or
C<NetworkNamespacePath> configured, as otherwise the network namespace of those
units is reused.

When this option is enabled, C<PrivateMounts> is implied unless it is
explicitly disabled, and C</sys> will be remounted to associate it with the new
network namespace.

When this option is used on a socket unit any sockets bound on behalf of this unit will be
bound within the specified network namespace. I< Optional. Type uniline.  > 

=head2 PrivateIPC

Takes a boolean argument. If true, sets up a new IPC namespace for the executed processes.
Each IPC namespace has its own set of System V IPC identifiers and its own POSIX message queue file system.
This is useful to avoid name clash of IPC identifiers. Defaults to false. It is possible to run two or
more units within the same private IPC namespace by using the C<JoinsNamespaceOf> directive,
see L<systemd.unit(5)> for
details.

Note that IPC namespacing does not have an effect on
C<AF_UNIX> sockets, which are the most common
form of IPC used on Linux. Instead, C<AF_UNIX>
sockets in the file system are subject to mount namespacing, and
those in the abstract namespace are subject to network namespacing.
IPC namespacing only has an effect on SysV IPC (which is mostly
legacy) as well as POSIX message queues (for which
C<AF_UNIX>/C<SOCK_SEQPACKET>
sockets are typically a better replacement). IPC namespacing also
has no effect on POSIX shared memory (which is subject to mount
namespacing) either. See
L<ipc_namespaces(7)> for
the details.

Note that the implementation of this setting might be impossible (for example if IPC namespaces are
not available), and the unit should be written in a way that does not solely rely on this setting for
security. I< Optional. Type boolean.  > 

=over 4

=item upstream_default value :

no

=back



=head2 IPCNamespacePath

Takes an absolute file system path referring to a Linux IPC namespace
pseudo-file (i.e. a file like C</proc/$PID/ns/ipc> or a bind mount or symlink to
one). When set the invoked processes are added to the network namespace referenced by that path. The
path has to point to a valid namespace file at the moment the processes are forked off. If this
option is used C<PrivateIPC> has no effect. If this option is used together with
C<JoinsNamespaceOf> then it only has an effect if this unit is started before any of
the listed units that have C<PrivateIPC> or
C<IPCNamespacePath> configured, as otherwise the network namespace of those
units is reused. I< Optional. Type uniline.  > 

=head2 MemoryKSM

Takes a boolean argument. When set, it enables KSM (kernel samepage merging) for
the processes. KSM is a memory-saving de-duplication feature. Anonymous memory pages with identical
content can be replaced by a single write-protected page. This feature should only be enabled for
jobs that share the same security domain. For details, see
L<Kernel Samepage Merging|https://docs.kernel.org/admin-guide/mm/ksm.html> in the
kernel documentation.

Note that this functionality might not be available, for example if KSM is disabled in the
kernel, or the kernel does not support controlling KSM at the process level through
L<prctl(2)>. I< Optional. Type boolean.  > 

=head2 PrivatePIDs

Takes a boolean argument. Defaults to false. If enabled, sets up a new PID namespace
for the executed processes. Each executed process is now PID 1 - the init process - in the new namespace.
C</proc/> is mounted such that only processes in the PID namespace are visible.
If C<PrivatePIDs> is set, C<MountAPIVFS=yes> is implied.

C<PrivatePIDs> is only supported for service units. This setting is not supported
with C<Type=forking> since the kernel will kill all processes in the PID namespace if
the init process terminates.

This setting will be ignored if the kernel does not support PID namespaces.

Note unprivileged user services (i.e. a service run by the per-user instance of the service manager)
will fail with C<PrivatePIDs=yes> if C</proc/> is masked
(i.e. C</proc/kmsg> is over-mounted with C<tmpfs> like
L<systemd-nspawn(1)> does).
This is due to a kernel restriction not allowing unprivileged user namespaces to mount a less restrictive
instance of C</proc/>. I< Optional. Type boolean.  > 

=over 4

=item upstream_default value :

no

=back



=head2 PrivateUsers

Takes a boolean argument or one of C<self>, C<identity>,
or C<full>. Defaults to false. If enabled, sets up a new user namespace for the
executed processes and configures a user and group mapping. If set to a true value or
C<self>, a minimal user and group mapping is configured that maps the
C<root> user and group as well as the unit's own user and group to themselves and
everything else to the C<nobody> user and group. This is useful to securely detach
the user and group databases used by the unit from the rest of the system, and thus to create an
effective sandbox environment. All files, directories, processes, IPC objects and other resources
owned by users/groups not equaling C<root> or the unit's own will stay visible from
within the unit but appear owned by the C<nobody> user and group.

If the parameter is C<identity>, user namespacing is set up with an identity
mapping for the first 65536 UIDs/GIDs. Any UIDs/GIDs above 65536 will be mapped to the
C<nobody> user and group, respectively. While this does not provide UID/GID isolation,
since all UIDs/GIDs are chosen identically it does provide process capability isolation, and hence is
often a good choice if proper user namespacing with distinct UID maps is not appropriate.

If the parameter is C<full>, user namespacing is set up with an identity
mapping for all UIDs/GIDs. In addition, for system services, C<full> allows the unit
to call setgroups() system calls (by setting
C</proc/pid/setgroups> to C<allow>).
Similar to C<identity>, this does not provide UID/GID isolation, but it does provide
process capability isolation.

If this mode is enabled, all unit processes are run without privileges in the host user
namespace (regardless of whether the unit's own user/group is C<root> or not). Specifically
this means that the process will have zero process capabilities on the host's user namespace, but
full capabilities within the service's user namespace. Settings such as
C<CapabilityBoundingSet> will affect only the latter, and there's no way to acquire
additional capabilities in the host's user namespace.

When this setting is set up by a per-user instance of the service manager, the mapping of the
C<root> user and group to itself is omitted (unless the user manager is root).
Additionally, in the per-user instance manager case, the
user namespace will be set up before most other namespaces. This means that combining
C<PrivateUsers>=C<true> with other namespaces will enable use of features not
normally supported by the per-user instances of the service manager.

This setting is particularly useful in conjunction with
C<RootDirectory>/C<RootImage>, as the need to synchronize the user and group
databases in the root directory and on the host is reduced, as the only users and groups who need to be matched
are C<root>, C<nobody> and the unit's own user and group. I< Optional. Type enum. choice: 'full', 'identity', 'no', 'self', 'yes'.  > 

=over 4

=item upstream_default value :

no

=back



=head2 ProtectHostname

Takes a boolean argument or C<private>. If enabled, sets up a new UTS
namespace for the executed processes. If enabled, a hostname can be optionally specified following a
colon (e.g. C<yes:foo> or C<private:host.example.com>), and the
hostname is set in the new UTS namespace for the unit. If set to a true value, changing hostname or
domainname via sethostname() and setdomainname() system
calls is prevented. If set to C<private>, changing hostname or domainname is allowed
but only affects the unit's UTS namespace. Defaults to off.

Note that the implementation of this setting might be impossible (for example if UTS namespaces
are not available), and the unit should be written in a way that does not solely rely on this setting
for security.

Note that when this option is enabled for a service hostname changes no longer propagate from
the system into the service, it is hence not suitable for services that need to take notice of system
hostname changes dynamically.

Note that this option does not prevent changing system hostname via hostnamectl.
However, C<User> and C<Group> may be used to run as an unprivileged user
to disallow changing system hostname. See SetHostname() in
L<org.freedesktop.hostname1(5)>
for more details. I< Optional. Type enum. choice: 'no', 'private', 'yes'.  > 

=over 4

=item upstream_default value :

no

=back



=head2 ProtectClock

Takes a boolean argument. If set, writes to the hardware clock or system clock will
be denied. Defaults to off. Enabling this option removes C<CAP_SYS_TIME> and
C<CAP_WAKE_ALARM> from the capability bounding set for this unit, installs a system
call filter to block calls that can set the clock, and C<DeviceAllow=char-rtc r> is
implied. Note that the system calls are blocked altogether, the filter does not take into account
that some of the calls can be used to read the clock state with some parameter combinations.
Effectively, C</dev/rtc0>, C</dev/rtc1>, etc. are made read-only
to the service. See
L<systemd.resource-control(5)>
for the details about C<DeviceAllow>.

It is recommended to turn this on for most services that do not need modify the clock or check
its state. I< Optional. Type boolean.  > 

=over 4

=item upstream_default value :

no

=back



=head2 ProtectKernelTunables

Takes a boolean argument. If true, kernel variables accessible through
C</proc/sys/>, C</sys/>, C</proc/sysrq-trigger>,
C</proc/latency_stats>, C</proc/acpi>,
C</proc/timer_stats>, C</proc/fs> and C</proc/irq> will
be made read-only and C</proc/kallsyms> as well as C</proc/kcore> will be
inaccessible to all processes of the unit.
Usually, tunable kernel variables should be initialized only at boot-time, for example with the
L<sysctl.d(5)> mechanism. Few
services need to write to these at runtime; it is hence recommended to turn this on for most services. For this
setting the same restrictions regarding mount propagation and privileges apply as for
C<ReadOnlyPaths> and related calls, see above. Defaults to off.
Note that this option does not prevent indirect changes to kernel tunables affected by IPC calls to
other processes. However, C<InaccessiblePaths> may be used to make relevant IPC file system
objects inaccessible. If C<ProtectKernelTunables> is set,
C<MountAPIVFS=yes> is implied. I< Optional. Type boolean.  > 

=over 4

=item upstream_default value :

no

=back



=head2 ProtectKernelModules

Takes a boolean argument. If true, explicit module loading will be denied. This allows
module load and unload operations to be turned off on modular kernels. It is recommended to turn this on for most
services
that do not need special file systems or extra kernel modules to work. Defaults to off. Enabling this option
removes C<CAP_SYS_MODULE> from the capability bounding set for the unit, and installs a
system call filter to block module system calls, also C</usr/lib/modules> is made
inaccessible. For this setting the same restrictions regarding mount propagation and privileges apply as for
C<ReadOnlyPaths> and related calls, see above. Note that limited automatic module loading due
to user configuration or kernel mapping tables might still happen as side effect of requested user operations,
both privileged and unprivileged. To disable module auto-load feature please see
L<sysctl.d(5)>C<kernel.modules_disabled> mechanism and
C</proc/sys/kernel/modules_disabled> documentation. I< Optional. Type boolean.  > 

=over 4

=item upstream_default value :

no

=back



=head2 ProtectKernelLogs

Takes a boolean argument. If true, access to the kernel log ring buffer will be denied. It is
recommended to turn this on for most services that do not need to read from or write to the kernel log ring
buffer. Enabling this option removes C<CAP_SYSLOG> from the capability bounding set for this
unit, and installs a system call filter to block the
L<syslog(2)>
system call (not to be confused with the libc API
L<syslog(3)>
for userspace logging). The kernel exposes its log buffer to userspace via C</dev/kmsg> and
C</proc/kmsg>. If enabled, these are made inaccessible to all the processes in the unit.
I< Optional. Type boolean.  > 

=head2 ProtectControlGroups

Takes a boolean argument or the special values C<private> or
C<strict>. If true, the Linux Control Groups (L<cgroups(7)>) hierarchies
accessible through C</sys/fs/cgroup/> will be made read-only to all processes of the
unit. If set to C<private>, the unit will run in a cgroup namespace with a private
writable mount of C</sys/fs/cgroup/>. If set to C<strict>, the unit
will run in a cgroup namespace with a private read-only mount of C</sys/fs/cgroup/>.
Defaults to off. If C<ProtectControlGroups> is set, C<MountAPIVFS=yes>
is implied. Note C<private> and C<strict> are downgraded to false and
true respectively unless the system is using the unified control group hierarchy and the kernel supports
cgroup namespaces.

Except for container managers no services should require write access to the control groups hierarchies;
it is hence recommended to set C<ProtectControlGroups> to true or C<strict>
for most services. For this setting the same restrictions regarding mount propagation and privileges apply
as for C<ReadOnlyPaths> and related settings, see above. I< Optional. Type enum. choice: 'no', 'private', 'strict', 'yes'.  > 

=over 4

=item upstream_default value :

no

=back



=head2 RestrictAddressFamilies

Restricts the set of socket address families accessible to the processes of this
unit. Takes C<none>, or a space-separated list of address family names to
allow-list, such as C<AF_UNIX>, C<AF_INET> or
C<AF_INET6>, see
L<address_families(7)>
for all possible options. When C<none> is specified, then all address
families will be denied. When prefixed with C<~> the listed address
families will be applied as deny list, otherwise as allow list.

By default, no restrictions apply, all address families are accessible to processes. If
assigned the empty string, any previous address family restriction changes are undone. This setting
does not affect commands prefixed with C<+>.

Use this option to limit exposure of processes to remote access, in particular via exotic and
sensitive network protocols, such as C<AF_PACKET>. Note that in most cases, the
local C<AF_UNIX> address family should be included in the configured allow list as
it is frequently used for local communication, including for
L<syslog(2)>
logging.

Note that this restricts access to the L<socket(2)>
system call only. Sockets passed into the process by other means (for example, by using socket
activation with socket units, see
L<systemd.socket(5)>)
are unaffected. Also, sockets created with socketpair() (which creates connected
AF_UNIX sockets) or the
L<io_uring(7)>
functions, are not affected. Thus, it is recommended to combined this setting with
C<SystemCallFilter=@service>, to only allow a limited subset of system calls.

Note that this option is limited to some ABIs, in particular x86-64, but currently has no
effect on 32-bit x86, s390, s390x, mips, mips-le, ppc, ppc-le, ppc64, or ppc64-le, and is ignored. On
systems supporting multiple ABIs (such as x86/x86-64) it is recommended to turn off alternative ABIs
for services, so that they cannot be used to circumvent the restrictions of this option.
Specifically, it is recommended to combine this option with
C<SystemCallArchitectures=native> or similar. I< Optional. Type uniline.  > 

=head2 RestrictFileSystems

Restricts the set of filesystems processes of this unit can open files on. Takes a space-separated
list of filesystem names. Any filesystem listed is made accessible to the unit's processes, access to filesystem
types not listed is prohibited (allow-listing). If the first character of the list is C<~>, the
effect is inverted: access to the filesystems listed is prohibited (deny-listing). If the empty string is assigned,
access to filesystems is not restricted.

If you specify both types of this option (i.e. allow-listing and deny-listing), the first encountered will take
precedence and will dictate the default action (allow access to the filesystem or deny it). Then the next occurrences
of this option will add or delete the listed filesystems from the set of the restricted filesystems, depending on its
type and the default action.

Example: if a unit has the following,

    RestrictFileSystems=ext4 tmpfs
    RestrictFileSystems=ext2 ext4

then access to C<ext4>, C<tmpfs>, and C<ext2> is allowed
and access to other filesystems is denied.

Example: if a unit has the following,

    RestrictFileSystems=ext4 tmpfs
    RestrictFileSystems=~ext4

then only access C<tmpfs> is allowed.

Example: if a unit has the following,

    RestrictFileSystems=~ext4 tmpfs
    RestrictFileSystems=ext4

then only access to C<tmpfs> is denied.

As the number of possible filesystems is large, predefined sets of filesystems are provided. A set
starts with C<@> character, followed by name of the set.

Use
L<systemd-analyze(1)>'s
filesystems command to retrieve a list of filesystems defined on the local
system.

Note that this setting might not be supported on some systems (for example if the LSM eBPF hook is
not enabled in the underlying kernel or if not using the unified control group hierarchy). In that case this setting
has no effect. I< Optional. Type uniline.  > 

=head2 RestrictNamespaces

Restricts access to Linux namespace functionality for the processes of this unit. For details
about Linux namespaces, see L<namespaces(7)>. Either
takes a boolean argument, or a space-separated list of namespace type identifiers. If false (the default), no
restrictions on namespace creation and switching are made. If true, access to any kind of namespacing is
prohibited. Otherwise, a space-separated list of namespace type identifiers must be specified, consisting of
any combination of: C<cgroup>, C<ipc>, C<net>,
C<mnt>, C<pid>, C<user>, C<uts>, and
C<time>. Any namespace type listed is made accessible to the unit's processes, access to
namespace types not listed is prohibited (allow-listing). By prepending the list with a single tilde
character (C<~>) the effect may be inverted: only the listed namespace types will be made
inaccessible, all unlisted ones are permitted (deny-listing). If the empty string is assigned, the default
namespace restrictions are applied, which is equivalent to false. This option may appear more than once, in
which case the namespace types are merged by C<OR>, or by C<AND> if the
lines are prefixed with C<~> (see examples below). Internally, this setting limits access to
the L<unshare(2)>,
L<clone(2)> and
L<setns(2)> system calls, taking
the specified flags parameters into account. Note that — if this option is used — in addition to restricting
creation and switching of the specified types of namespaces (or all of them, if true) access to the
setns() system call with a zero flags parameter is prohibited. This setting is only
supported on x86, x86-64, mips, mips-le, mips64, mips64-le, mips64-n32, mips64-le-n32, ppc64, ppc64-le, s390
and s390x, and enforces no restrictions on other architectures.

Example: if a unit has the following,

    RestrictNamespaces=cgroup ipc
    RestrictNamespaces=cgroup net

then C<cgroup>, C<ipc>, and C<net> are set.
If the second line is prefixed with C<~>, e.g.,

    RestrictNamespaces=cgroup ipc
    RestrictNamespaces=~cgroup net

then, only C<ipc> is set. I< Optional. Type uniline.  > 

=head2 DelegateNamespaces

Delegates ownership of the given namespace types to the user namespace of the
processes of this unit. For details about Linux namespaces, see L<namespaces(7)>.
Either takes a boolean argument, or a space-separated list of namespace type identifiers. If false
(the default), the unit's processes' user namespace will not have ownership over any namespaces
created during setup of the unit's sandboxed environment. If true, ownership of all namespace types
(except for user namespaces, where the concept doesn't apply) created during setup of the unit's
sandboxed environment is delegated to the unit's processes' user namespace. Otherwise, a
space-separated list of namespace type identifiers must be specified, consisting of any combination
of: C<cgroup>, C<ipc>, C<net>,
C<mnt>, C<pid>, and C<uts>. All namespaces of
the listed types will be owned by the unit's processes' user namespace if they are created during
setup of the unit's sandboxed environment (allow-listing). By prepending the list with a single tilde
character (C<~>) the effect may be inverted: all namespaces of types not listed and
created during setup of the unit's sandboxed environment will be owned by the unit's processes' user
namespace (deny-listing). If the empty string is assigned, the default namespace ownership is
applied, which is equivalent to false. This option may appear more than once, in which case the
namespace types are merged by C<OR>, or by C<AND> if the lines
are prefixed with C<~> (see examples below). Internally, this setting controls the
order in which namespaces are unshared by systemd. Namespace types that should be owned by the unit's
processes' user namespace will be unshared after unsharing the user namespace. Internally, this
setting controls the order in which namespaces are unshared. Delegated namespaces will be unshared
after the user namespace is unshared. Other namespaces will be unshared before the user namespace is
unshared.

Delegating any namespace with C<DelegateNamespaces> implies
C<PrivateUsers=self> unless C<PrivateUsers> is explicitly enabled
already by the unit. Delegating a namespace does not imply that the namespace is unshared, that is
done with the namespace specific unit setting such as C<PrivateNetwork> or
C<PrivateMounts>.

Note that some namespace sandboxing options might entail mount namespace for private API VFS instances,
such as C<PrivatePIDs>, C<ProtectControlGroups=private/strict>, or
C<PrivateNetwork>. If any of the mentioned options are enabled, mount namespace
is implicitly delegated. I< Optional. Type uniline.  > 

=head2 PrivateBPF

Takes a boolean argument. If set, mount a private instance of the BPF filesystem
on C</sys/fs/bpf/>, effectively hiding the host bpffs which contains information
about loaded programs and maps. Otherwise, if C<ProtectKernelTunables> is set, the
instance from the host is inherited but mounted read-only. Defaults to false.

This can be used together with the bpffs delegate feature to choose what BPF functions are
available to the unit's processes. When mounting the BPF filesystem with the fsopen() API, four mount
options can be specified to set a list of BPF commands, maps, programs and attachment types that are
allowed to be used. Processes needs to get a file descriptor for the bpffs mountpoint and use that to
get a token which will enable for that user namespace the BPF functionalities chosen upon bpffs mount.
A more detailed explanation of the feature can be found in this
L<LWN post|https://lwn.net/Articles/947173/>. I< Optional. Type boolean.  > 

=over 4

=item upstream_default value :

no

=back



=head2 BPFDelegateCommands

Accepts a list of BPF commands to allow or C<any> to allow everything.
Defaults to none. The accepted values are:

This will set the C<delegate_cmds> bpffs mount option.

Requires C<PrivateBPF=yes> to be effective,
see C<PrivateBPF> more details. I< Optional. Type uniline.  > 

=head2 BPFDelegateMaps

Accepts a list of BPF maps to allow or C<any> to allow everything.
Defaults to none. The accepted values are:

This will set the C<delegate_maps> bpffs mount option.

Requires C<PrivateBPF=yes> to be effective,
see C<PrivateBPF> more details. I< Optional. Type uniline.  > 

=head2 BPFDelegatePrograms

Accepts a list of BPF programs to allow or C<any> to allow everything.
Defaults to none. The accepted values are:

This will set the C<delegate_progs> bpffs mount option.

Requires C<PrivateBPF=yes> to be effective,
see C<PrivateBPF> more details. I< Optional. Type uniline.  > 

=head2 BPFDelegateAttachments

Accepts a list of BPF attach points to allow or C<any> to allow everything.
Defaults to none. The accepted values are:

This will set the C<delegate_attachs> bpffs mount option.

Requires C<PrivateBPF=yes> to be effective,
see C<PrivateBPF> more details. I< Optional. Type uniline.  > 

=head2 LockPersonality

Takes a boolean argument. If set, locks down the L<personality(2)> system
call so that the kernel execution domain may not be changed from the default or the personality selected with
C<Personality> directive. This may be useful to improve security, because odd personality
emulations may be poorly tested and source of vulnerabilities. I< Optional. Type boolean.  > 

=head2 MemoryDenyWriteExecute

Takes a boolean argument. If set, attempts to create memory mappings that are writable and
executable at the same time, or to change existing memory mappings to become executable, or mapping shared
memory segments as executable, are prohibited. Specifically, a system call filter is added (or
preferably, an equivalent kernel check is enabled with
L<prctl(2)>) that
rejects L<mmap(2)>
system calls with both C<PROT_EXEC> and C<PROT_WRITE> set,
L<mprotect(2)> or
L<pkey_mprotect(2)> system calls
with C<PROT_EXEC> set and
L<shmat(2)> system calls with
C<SHM_EXEC> set. Note that this option is incompatible with programs and libraries that
generate program code dynamically at runtime, including JIT execution engines, executable stacks, and code
"trampoline" feature of various C compilers. This option improves service security, as it makes harder for
software exploits to change running code dynamically. However, the protection can be circumvented, if
the service can write to a filesystem, which is not mounted with C<noexec> (such as
C</dev/shm>), or it can use memfd_create(). This can be
prevented by making such file systems inaccessible to the service
(e.g. C<InaccessiblePaths=/dev/shm>) and installing further system call filters
(C<SystemCallFilter=~memfd_create>). Note that this feature is fully available on
x86-64, and partially on x86. Specifically, the shmat() protection is not
available on x86. Note that on systems supporting multiple ABIs (such as x86/x86-64) it is
recommended to turn off alternative ABIs for services, so that they cannot be used to circumvent the
restrictions of this option. Specifically, it is recommended to combine this option with
C<SystemCallArchitectures=native> or similar. I< Optional. Type boolean.  > 

=head2 RestrictRealtime

Takes a boolean argument. If set, any attempts to enable realtime scheduling in a process of
the unit are refused. This restricts access to realtime task scheduling policies such as
C<SCHED_FIFO>, C<SCHED_RR> or C<SCHED_DEADLINE>. See
L<sched(7)>
for details about these scheduling policies. Realtime scheduling policies may be used to monopolize CPU
time for longer periods of time, and may hence be used to lock up or otherwise trigger Denial-of-Service
situations on the system. It is hence recommended to restrict access to realtime scheduling to the few programs
that actually require them. Defaults to off. I< Optional. Type boolean.  > 

=over 4

=item upstream_default value :

no

=back



=head2 RestrictSUIDSGID

Takes a boolean argument. If set, any attempts to set the set-user-ID (SUID) or
set-group-ID (SGID) bits on files or directories will be denied (for details on these bits see
L<inode(7)>).
As the SUID/SGID bits are mechanisms to elevate privileges, and allow users to acquire the
identity of other users, it is recommended to restrict creation of SUID/SGID files to the few
programs that actually require them. Note that this restricts marking of any type of file system
object with these bits, including both regular files and directories (where the SGID is a different
meaning than for files, see documentation). This option is implied if C<DynamicUser>
is enabled.

In other cases, this setting defaults to the value set with C<DefaultRestrictSUIDSGID> in
L<systemd-system.conf(5)>, which
defaults to off. I< Optional. Type boolean.  > 

=head2 RemoveIPC

Takes a boolean parameter. If set, all System V and POSIX IPC objects owned by the user and
group the processes of this unit are run as are removed when the unit is stopped. This setting only has an
effect if at least one of C<User>, C<Group> and
C<DynamicUser> are used. It has no effect on IPC objects owned by the root user. Specifically,
this removes System V semaphores, as well as System V and POSIX shared memory segments and message queues. If
multiple units use the same user or group the IPC objects are removed when the last of these units is
stopped. This setting is implied if C<DynamicUser> is set. I< Optional. Type boolean.  > 

=head2 PrivateMounts

Takes a boolean parameter. If set, the processes of this unit will be run in their own private
file system (mount) namespace with all mount propagation from the processes towards the host's main file system
namespace turned off. This means any file system mount points established or removed by the unit's processes
will be private to them and not be visible to the host. However, file system mount points established or
removed on the host will be propagated to the unit's processes. See L<mount_namespaces(7)> for
details on file system namespaces. Defaults to off.

When turned on, this executes three operations for each invoked process: a new
C<CLONE_NEWNS> namespace is created, after which all existing mounts are remounted to
C<MS_SLAVE> to disable propagation from the unit's processes to the host (but leaving
propagation in the opposite direction in effect). Finally, the mounts are remounted again to the propagation
mode configured with C<MountFlags>, see below.

File system namespaces are set up individually for each process forked off by the service manager. Mounts
established in the namespace of the process created by C<ExecStartPre> will hence be cleaned
up automatically as soon as that process exits and will not be available to subsequent processes forked off for
C<ExecStart> (and similar applies to the various other commands configured for
units). Similarly, C<JoinsNamespaceOf> does not permit sharing kernel mount namespaces between
units, it only enables sharing of the C</tmp/> and C</var/tmp/>
directories.

Other file system namespace unit settings — C<PrivateTmp>,
C<PrivateDevices>, C<ProtectSystem>,
C<ProtectHome>, C<ReadOnlyPaths>,
C<InaccessiblePaths>, C<ReadWritePaths>,
C<BindPaths>, C<BindReadOnlyPaths>, … — also enable file system
namespacing in a fashion equivalent to this option. Hence it is primarily useful to explicitly
request this behaviour if none of the other settings are used. I< Optional. Type boolean.  > 

=over 4

=item upstream_default value :

no

=back



=head2 MountFlags

Takes a mount propagation setting: C<shared>, C<slave> or
C<private>, which controls whether file system mount points in the file system namespaces set up
for this unit's processes will receive or propagate mounts and unmounts from other file system namespaces. See
L<mount(2)>
for details on mount propagation, and the three propagation flags in particular.

This setting only controls the final propagation setting in effect on all mount
points of the file system namespace created for each process of this unit. Other file system namespacing unit
settings (see the discussion in C<PrivateMounts> above) will implicitly disable mount and
unmount propagation from the unit's processes towards the host by changing the propagation setting of all mount
points in the unit's file system namespace to C<slave> first. Setting this option to
C<shared> does not reestablish propagation in that case.

If not set – but file system namespaces are enabled through another file system namespace unit setting –
C<shared> mount propagation is used, but — as mentioned — as C<slave> is applied
first, propagation from the unit's processes to the host is still turned off.

It is not recommended to use C<private> mount propagation for units, as this means
temporary mounts (such as removable media) of the host will stay mounted and thus indefinitely busy in forked
off processes, as unmount propagation events will not be received by the file system namespace of the unit.

Usually, it is best to leave this setting unmodified, and use higher level file system namespacing
options instead, in particular C<PrivateMounts>, see above. I< Optional. Type uniline.  > 

=head2 SystemCallFilter

Takes a space-separated list of system call names or system call groups. If this
setting is used, system calls executed by the unit processes except for the listed ones will result
in the system call being denied (allow-listing). If the first character of the list is
C<~>, the effect is inverted: only the listed system calls will be denied
(deny-listing). This option may be specified more than once, in which case the filter masks are
merged. If the empty string is assigned, the filter is reset, all prior assignments will have no
effect.

Commands prefixed with C<+> are not subject to filtering. The
execve(), exit(), exit_group(),
getrlimit(), rt_sigreturn(),
sigreturn() system calls and the system calls for querying time and sleeping are
implicitly allow-listed and do not need to be listed explicitly.

The default action when a system call is denied is to terminate the processes with a
C<SIGSYS> signal. This can changed using C<SystemCallErrorNumber>,
see below. In addition, deny-listed system calls and system call groups may optionally be suffixed
with a colon (C<:>) and an argument in the same format as
C<SystemCallErrorNumber>, to take this action when the matching system call is made.
This takes precedence over the action specified in C<SystemCallErrorNumber>.

This feature makes use of the Secure Computing Mode 2 interfaces of the kernel ('seccomp
filtering') and is useful for enforcing a minimal sandboxing environment.

Note that on systems supporting multiple ABIs (such as x86/x86-64) it is recommended to turn
off alternative ABIs for services, so that they cannot be used to circumvent the restrictions of this
option. Specifically, it is recommended to combine this option with
C<SystemCallArchitectures=native> or similar.

Note that strict system call filters may impact execution and error handling code paths of the
service invocation. Specifically, access to the execve() system call is required
for the execution of the service binary — if it is blocked service invocation will necessarily fail.
Also, if execution of the service binary fails for some reason (for example: missing service
executable), the error handling logic might require access to an additional set of system calls in
order to process and log this failure correctly. It might be necessary to temporarily disable system
call filters in order to allow debugging of such failures.

If you specify both types of this option (i.e. allow-listing and deny-listing), the first
encountered will take precedence and will dictate the default action (termination or approval of a
system call). Then the next occurrences of this option will add or delete the listed system calls
from the set of the filtered system calls, depending of its type and the default action. (For
example, if you have started with an allow list rule for read() and
write(), and right after it add a deny list rule for write(),
then write() will be removed from the set.)

As the number of possible system calls is large, predefined groups of system calls are
provided. A group starts with C<@> character, followed by name of the set.
Currently predefined system call setsSetDescription@aioAsynchronous I/O (L<io_setup(2)>, L<io_submit(2)>, and related
calls)@basic-ioSystem calls for basic I/O: reading, writing, seeking, file descriptor duplication and closing
(L<read(2)>, L<write(2)>, and related calls)@chownChanging file ownership (L<chown(2)>, L<fchownat(2)>, and related
calls)@clockSystem calls for changing the system clock (L<adjtimex(2)>, L<settimeofday(2)>, and related
calls)@cpu-emulationSystem calls for CPU emulation functionality (L<vm86(2)> and related calls)@debugDebugging,
performance monitoring and tracing functionality (L<ptrace(2)>, L<perf_event_open(2)> and related
calls)@file-systemFile system operations: opening, creating files and directories for read and write, renaming and
removing them, reading file properties, or creating hard and symbolic links@io-eventEvent loop system calls
(L<poll(2)>, L<select(2)>, L<epoll(7)>, L<eventfd(2)> and related calls)@ipcPipes, SysV IPC, POSIX Message Queues and
other IPC (L<mq_overview(7)>, L<svipc(7)>)@keyringKernel keyring access (L<keyctl(2)> and related calls)@memlockLocking
of memory in RAM (L<mlock(2)>, L<mlockall(2)> and related calls)@moduleLoading and unloading of kernel modules
(L<init_module(2)>, L<delete_module(2)> and related calls)@mountMounting and unmounting of file systems (L<mount(2)>,
L<chroot(2)>, and related calls)@network-ioSocket I/O (including local AF_UNIX): L<socket(7)>,
L<unix(7)>@obsoleteUnusual, obsolete or unimplemented (L<create_module(2)>, L<gtty(2)>, …)@pkeySystem calls that deal
with memory protection keys (L<pkeys(7)>)@privilegedAll system calls which need super-user capabilities
(L<capabilities(7)>)@processProcess control, execution, namespacing operations (L<clone(2)>, L<kill(2)>,
L<namespaces(7)>, …)@raw-ioRaw I/O port access (L<ioperm(2)>, L<iopl(2)>, pciconfig_read(), …)@rebootSystem calls for
rebooting and reboot preparation (L<reboot(2)>, kexec(), …)@resourcesSystem calls for changing resource limits, memory
and scheduling parameters (L<setrlimit(2)>, L<setpriority(2)>, …)@sandboxSystem calls for sandboxing programs
(L<seccomp(2)>, Landlock system calls, …)@setuidSystem calls for changing user ID and group ID credentials,
(L<setuid(2)>, L<setgid(2)>, L<setresuid(2)>, …)@signalSystem calls for manipulating and handling process signals
(L<signal(2)>, L<sigprocmask(2)>, …)@swapSystem calls for enabling/disabling swap devices (L<swapon(2)>,
L<swapoff(2)>)@syncSynchronizing files and memory to disk (L<fsync(2)>, L<msync(2)>, and related calls)@system-serviceA
reasonable set of system calls used by common system services, excluding any special purpose calls. This is the
recommended starting point for allow-listing system calls for system services, as it contains what is typically needed
by system services, but excludes overly specific interfaces. For example, the following APIs are excluded: C<@clock>,
C<@mount>, C<@swap>, C<@reboot>.@timerSystem calls for scheduling operations by time (L<alarm(2)>, L<timer_create(2)>,
…)@knownAll system calls defined by the kernel. This list is defined statically in systemd based on a kernel version
that was available when this systemd version was released. It will become progressively more out-of-date as the kernel
is updated.
Note, that as new system calls are added to the kernel, additional system calls might be added to the groups
above. Contents of the sets may also change between systemd versions. In addition, the list of system calls
depends on the kernel version and architecture for which systemd was compiled. Use
systemd-analyze syscall-filter to list the actual list of system calls in each
filter.

Generally, allow-listing system calls (rather than deny-listing) is the safer mode of
operation. It is recommended to enforce system call allow lists for all long-running system
services. Specifically, the following lines are a relatively safe basic choice for the majority of
system services:

    [Service]
    SystemCallFilter=@system-service
    SystemCallErrorNumber=EPERM

Note that various kernel system calls are defined redundantly: there are multiple system calls
for executing the same operation. For example, the pidfd_send_signal() system
call may be used to execute operations similar to what can be done with the older
kill() system call, hence blocking the latter without the former only provides
weak protection. Since new system calls are added regularly to the kernel as development progresses,
keeping system call deny lists comprehensive requires constant work. It is thus recommended to use
allow-listing instead, which offers the benefit that new system calls are by default implicitly
blocked until the allow list is updated.

Also note that a number of system calls are required to be accessible for the dynamic linker to
work. The dynamic linker is required for running most regular programs (specifically: all dynamic ELF
binaries, which is how most distributions build packaged programs). This means that blocking these
system calls (which include open(), openat() or
mmap()) will make most programs typically shipped with generic distributions
unusable.

It is recommended to combine the file system namespacing related options with
C<SystemCallFilter=~@mount>, in order to prohibit the unit's processes to undo the
mappings. Specifically these are the options C<PrivateTmp>,
C<PrivateDevices>, C<ProtectSystem>, C<ProtectHome>,
C<ProtectKernelTunables>, C<ProtectControlGroups>,
C<ProtectKernelLogs>, C<ProtectClock>, C<ReadOnlyPaths>,
C<InaccessiblePaths> and C<ReadWritePaths>. I< Optional. Type list of uniline.  > 

=head2 SystemCallErrorNumber

Takes an C<errno> error number (between 1 and 4095) or errno name
such as C<EPERM>, C<EACCES> or C<EUCLEAN>, to
return when the system call filter configured with C<SystemCallFilter> is triggered,
instead of terminating the process immediately. See L<errno(3)> for a
full list of error codes. When this setting is not used, or when the empty string or the special
setting C<kill> is assigned, the process will be terminated immediately when the
filter is triggered. I< Optional. Type uniline.  > 

=head2 SystemCallArchitectures

Takes a space-separated list of architecture identifiers to include in the system call
filter. The known architecture identifiers are the same as for C<ConditionArchitecture>
described in L<systemd.unit(5)>,
as well as C<x32>, C<mips64-n32>, C<mips64-le-n32>, and
the special identifier C<native>. The special identifier C<native>
implicitly maps to the native architecture of the system (or more precisely: to the architecture the system
manager is compiled for). By default, this option is set to the empty list, i.e. no filtering is applied.

If this setting is used, processes of this unit will only be permitted to call native system calls, and
system calls of the specified architectures. For the purposes of this option, the x32 architecture is treated
as including x86-64 system calls. However, this setting still fulfills its purpose, as explained below, on
x32.

System call filtering is not equally effective on all architectures. For example, on x86
filtering of network socket-related calls is not possible, due to ABI limitations — a limitation that x86-64
does not have, however. On systems supporting multiple ABIs at the same time — such as x86/x86-64 — it is hence
recommended to limit the set of permitted system call architectures so that secondary ABIs may not be used to
circumvent the restrictions applied to the native ABI of the system. In particular, setting
C<SystemCallArchitectures=native> is a good choice for disabling non-native ABIs.

System call architectures may also be restricted system-wide via the
C<SystemCallArchitectures> option in the global configuration. See
L<systemd-system.conf(5)> for
details. I< Optional. Type uniline.  > 

=head2 SystemCallLog

Takes a space-separated list of system call names. If this setting is used, all
system calls executed by the unit processes for the listed ones will be logged. If the first
character of the list is C<~>, the effect is inverted: all system calls except the
listed system calls will be logged. This feature makes use of the Secure Computing Mode 2 interfaces
of the kernel ('seccomp filtering') and is useful for auditing or setting up a minimal sandboxing
environment. This option may be specified more than once, in which case the filter masks are merged.
If the empty string is assigned, the filter is reset, all prior assignments will have no effect.
This does not affect commands prefixed with C<+>. I< Optional. Type list of uniline.  > 

=head2 Environment

Sets environment variables for executed processes. Each line is unquoted using the
rules described in "Quoting" section in
L<systemd.syntax(7)>
and becomes a list of variable assignments. If you need to assign a value containing spaces or the
equals sign to a variable, put quotes around the whole assignment. Variable expansion is not
performed inside the strings and the C<$> character has no special meaning. Specifier
expansion is performed, see the "Specifiers" section in
L<systemd.unit(5)>.

This option may be specified more than once, in which case all listed variables will be set. If
the same variable is listed twice, the later setting will override the earlier setting. If the empty
string is assigned to this option, the list of environment variables is reset, all prior assignments
have no effect.

The names of the variables can contain ASCII letters, digits, and the underscore character.
Variable names cannot be empty or start with a digit. In variable values, most characters are
allowed, but non-printable characters are currently rejected.

Example:

    Environment="VAR1=word1 word2" VAR2=word3 "VAR3=$word 5 6"

gives three variables C<VAR1>,
C<VAR2>, C<VAR3>
with the values C<word1 word2>,
C<word3>, C<$word 5 6>.

See L<environ(7)> for
details about environment variables.

Note that environment variables are not suitable for passing secrets (such as passwords, key
material, …)  to service processes. Environment variables set for a unit are exposed to unprivileged
clients via D-Bus IPC, and generally not understood as being data that requires protection. Moreover,
environment variables are propagated down the process tree, including across security boundaries
(such as setuid/setgid executables), and hence might leak to processes that should not have access to
the secret data. Use C<LoadCredential>, C<LoadCredentialEncrypted>
or C<SetCredentialEncrypted> (see below) to pass data to unit processes
securely. I< Optional. Type list of uniline.  > 

=head2 EnvironmentFile

Similar to C<Environment>, but reads the environment variables from
a text file. The text file should contain newline-separated variable assignments. Empty lines, lines
without an C<=> separator, or lines starting with C<;> or
C<#> will be ignored, which may be used for commenting. The file must be encoded with
UTF-8. Valid characters are
L<unicode scalar values|https://www.unicode.org/glossary/#unicode_scalar_value>
other than
L<unicode noncharacters|https://www.unicode.org/glossary/#noncharacter>,
C<U+0000> C<NUL>, and C<U+FEFF>L<unicode byte order mark|https://www.unicode.org/glossary/#byte_order_mark>.
Control codes other than C<NUL> are allowed.

In the file, an unquoted value after the C<=> is parsed with the same backslash-escape
rules as L<POSIX shell unquoted
text|https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_02_01>, but unlike in a shell,
interior whitespace is preserved and quotes after the
first non-whitespace character are preserved. Leading and trailing whitespace (space, tab, carriage return) is
discarded, but interior whitespace within the line is preserved verbatim. A line ending with a backslash will be
continued to the following one, with the newline itself discarded. A backslash
C<\> followed by any character other than newline will preserve the following character, so that
C<\\> will become the value C<\>.

In the file, a C<'>-quoted value after the C<=> can span
multiple lines and contain any character verbatim other than single quote, like L<POSIX
shell single-quoted text|https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_02_02>. No
backslash-escape sequences are recognized. Leading and trailing
whitespace outside of the single quotes is discarded.

In the file, a C<">-quoted value after the C<=> can span
multiple lines, and the same escape sequences are recognized as in L<POSIX
shell double-quoted text|https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_02_03>.
Backslash (C<\>) followed by any of
C<"\`$> will preserve that character. A backslash followed by newline is a line
continuation, and the newline itself is discarded. A backslash followed by any other character is
ignored; both the backslash and the following character are preserved verbatim. Leading and trailing
whitespace outside of the double quotes is discarded.

The argument passed should be an absolute filename or wildcard expression, optionally prefixed with
C<->, which indicates that if the file does not exist, it will not be read and no error or
warning message is logged. This option may be specified more than once in which case all specified files are
read. If the empty string is assigned to this option, the list of file to read is reset, all prior assignments
have no effect.

The files listed with this directive will be read shortly before the process is executed (more
specifically, after all processes from a previous unit state terminated. This means you can generate these
files in one unit state, and read it with this option in the next. The files are read from the file
system of the service manager, before any file system changes like bind mounts take place).

Settings from these files override settings made with C<Environment>. If the same
variable is set twice from these files, the files will be read in the order they are specified and the later
setting will override the earlier setting. I< Optional. Type list of uniline.  > 

=head2 PassEnvironment

Pass environment variables set for the system service manager to executed processes. Takes a
space-separated list of variable names. This option may be specified more than once, in which case all listed
variables will be passed. If the empty string is assigned to this option, the list of environment variables to
pass is reset, all prior assignments have no effect. Variables specified that are not set for the system
manager will not be passed and will be silently ignored. Note that this option is only relevant for the system
service manager, as system services by default do not automatically inherit any environment variables set for
the service manager itself. However, in case of the user service manager all environment variables are passed
to the executed processes anyway, hence this option is without effect for the user service manager.

Variables set for invoked processes due to this setting are subject to being overridden by those
configured with C<Environment> or C<EnvironmentFile>.

Example:

    PassEnvironment=VAR1 VAR2 VAR3

passes three variables C<VAR1>,
C<VAR2>, C<VAR3>
with the values set for those variables in PID1.

See L<environ(7)> for details
about environment variables. I< Optional. Type list of uniline.  > 

=head2 UnsetEnvironment

Explicitly unset environment variable assignments that would normally be passed from the
service manager to invoked processes of this unit. Takes a space-separated list of variable names or variable
assignments. This option may be specified more than once, in which case all listed variables/assignments will
be unset. If the empty string is assigned to this option, the list of environment variables/assignments to
unset is reset. If a variable assignment is specified (that is: a variable name, followed by
C<=>, followed by its value), then any environment variable matching this precise assignment is
removed. If a variable name is specified (that is a variable name without any following C<=> or
value), then any assignment matching the variable name, regardless of its value is removed. Note that the
effect of C<UnsetEnvironment> is applied as final step when the environment list passed to
executed processes is compiled. That means it may undo assignments from any configuration source, including
assignments made through C<Environment> or C<EnvironmentFile>, inherited from
the system manager's global set of environment variables, inherited via C<PassEnvironment>,
set by the service manager itself (such as C<$NOTIFY_SOCKET> and such), or set by a PAM module
(in case C<PAMName> is used).

See "Environment Variables in Spawned Processes" below for a description of how those
settings combine to form the inherited environment. See L<environ(7)> for general
information about environment variables. I< Optional. Type list of uniline.  > 

=head2 StandardInput

Controls where file descriptor 0 (STDIN) of the executed processes is connected to. Takes one
of C<null>, C<tty>, C<tty-force>, C<tty-fail>,
C<data>, C<file:path>, C<socket> or
C<fd:name>.

If C<null> is selected, standard input will be connected to C</dev/null>,
i.e. all read attempts by the process will result in immediate EOF.

If C<tty> is selected, standard input is connected to a TTY (as configured by
C<TTYPath>, see below) and the executed process becomes the controlling process of the
terminal. If the terminal is already being controlled by another process, the executed process waits until the
current controlling process releases the terminal.

C<tty-force> is similar to C<tty>, but the executed process is forcefully and
immediately made the controlling process of the terminal, potentially removing previous controlling processes
from the terminal.

C<tty-fail> is similar to C<tty>, but if the terminal already has a
controlling process start-up of the executed process fails.

The C<data> option may be used to configure arbitrary textual or binary data to pass via
standard input to the executed process. The data to pass is configured via
C<StandardInputText>/C<StandardInputData> (see below). Note that the actual
file descriptor type passed (memory file, regular file, UNIX pipe, …) might depend on the kernel and available
privileges. In any case, the file descriptor is read-only, and when read returns the specified data followed by
EOF.

The C<file:path> option may be used to connect a specific file
system object to standard input. An absolute path following the C<:> character is expected,
which may refer to a regular file, a FIFO or special file. If an C<AF_UNIX> socket in the
file system is specified, a stream socket is connected to it. The latter is useful for connecting standard
input of processes to arbitrary system services.

The C<socket> option is valid in socket-activated services only, and requires the relevant
socket unit file (see
L<systemd.socket(5)> for details)
to have C<Accept=yes> set, or to specify a single socket only. If this option is set, standard
input will be connected to the socket the service was activated from, which is primarily useful for
compatibility with daemons designed for use with the traditional L<inetd(8)> socket activation
daemon (C<$LISTEN_FDS> (and related) environment variables are not passed when
C<socket> value is configured).

The C<fd:name> option connects standard input to a specific,
named file descriptor provided by a socket unit. The name may be specified as part of this option, following a
C<:> character (e.g. C<fd:foobar>). If no name is specified, the name
C<stdin> is implied (i.e. C<fd> is equivalent to C<fd:stdin>).
At least one socket unit defining the specified name must be provided via the C<Sockets>
option, and the file descriptor name may differ from the name of its containing socket unit. If multiple
matches are found, the first one will be used. See C<FileDescriptorName> in
L<systemd.socket(5)> for more
details about named file descriptors and their ordering.

This setting defaults to C<null>, unless
C<StandardInputText>/C<StandardInputData> are set, in which case it
defaults to C<data>. I< Optional. Type enum. choice: 'data', 'null', 'socket', 'tty', 'tty-fail', 'tty-force'.  > 

=head2 StandardOutput

Controls where file descriptor 1 (stdout) of the executed processes is connected
to. Takes one of C<inherit>, C<null>, C<tty>,
C<journal>, C<kmsg>, C<journal+console>,
C<kmsg+console>, C<file:path>,
C<append:path>, C<truncate:path>,
C<socket> or C<fd:name>.

C<inherit> duplicates the file descriptor of standard input for standard output.

C<null> connects standard output to C</dev/null>, i.e. everything written
to it will be lost.

C<tty> connects standard output to a tty (as configured via C<TTYPath>,
see below). If the TTY is used for output only, the executed process will not become the controlling process of
the terminal, and will not fail or wait for other processes to release the terminal. Note: if a unit
tries to print multiple lines to a TTY during bootup or shutdown, then there's a chance that those
lines will be broken up by status messages. SetShowStatus() can be used to
prevent this problem. See
L<org.freedesktop.systemd1(5)>
for details.

C<journal> connects standard output with the journal, which is accessible via
L<journalctl(1)>. Note
that everything that is written to kmsg (see below) is implicitly stored in the journal as well, the
specific option listed below is hence a superset of this one. (Also note that any external,
additional syslog daemons receive their log data from the journal, too, hence this is the option to
use when logging shall be processed with such a daemon.)

C<kmsg> connects standard output with the kernel log buffer which is accessible via
L<dmesg(1)>,
in addition to the journal. The journal daemon might be configured to send all logs to kmsg anyway, in which
case this option is no different from C<journal>.

C<journal+console> and C<kmsg+console> work in a similar way as the
two options above but copy the output to the system console as well.

The C<file:path> option may be used to connect a specific file
system object to standard output. The semantics are similar to the same option of
C<StandardInput>, see above. If path refers to a regular file
on the filesystem, it is opened (created if it does not exist yet using privileges of the user executing the
systemd process) for writing at the beginning of the file, but without truncating it.
If standard input and output are directed to the same file path, it is opened only once — for reading as well
as writing — and duplicated. This is particularly useful when the specified path refers to an
C<AF_UNIX> socket in the file system, as in that case only a
single stream connection is created for both input and output.

C<append:path> is similar to
C<file:path> above, but it opens the file in append mode.

C<truncate:path> is similar to
C<file:path> above, but it truncates the file when opening
it. For units with multiple command lines, e.g. C<Type=oneshot> services with
multiple C<ExecStart>, or services with C<ExecCondition>,
C<ExecStartPre> or C<ExecStartPost>, the output file is reopened
and therefore re-truncated for each command line. If the output file is truncated while another
process still has the file open, e.g. by an C<ExecReload> running concurrently with
an C<ExecStart>, and the other process continues writing to the file without
adjusting its offset, then the space between the file pointers of the two processes may be filled
with C<NUL> bytes, producing a sparse file. Thus,
C<truncate:path> is typically only useful for units where
only one process runs at a time, such as services with a single C<ExecStart> and no
C<ExecStartPost>, C<ExecReload>, C<ExecStop> or
similar.

C<socket> connects standard output to a socket acquired via socket activation. The
semantics are similar to the same option of C<StandardInput>, see above.

The C<fd:name> option connects standard output to a
specific, named file descriptor provided by a socket unit. A name may be specified as part of this
option, following a C<:> character
(e.g. C<fd:foobar>). If no name is specified, the name
C<stdout> is implied (i.e. C<fd> is equivalent to
C<fd:stdout>). At least one socket unit defining the specified name must be provided
via the C<Sockets> option, and the file descriptor name may differ from the name of
its containing socket unit. If multiple matches are found, the first one will be used. See
C<FileDescriptorName> in
L<systemd.socket(5)>
for more details about named descriptors and their ordering.

If the standard output (or error output, see below) of a unit is connected to the journal or
the kernel log buffer, the unit will implicitly gain a dependency of type C<After>
on C<systemd-journald.socket> (also see the "Implicit Dependencies" section
above). Also note that, in this case, stdout (or stderr, see below) will be an
C<AF_UNIX> stream socket, and not a pipe or FIFO that can be reopened. This means
when executing shell scripts the construct echo "hello" > /dev/stderr for
writing text to stderr will not work. To mitigate this use the construct echo "hello"
>&2 instead, which is mostly equivalent and avoids this pitfall.

If C<StandardInput> is set to one of C<tty>, C<tty-force>,
C<tty-fail>, C<socket>, or C<fd:name>, this
setting defaults to C<inherit>.

In other cases, this setting defaults to the value set with C<DefaultStandardOutput> in
L<systemd-system.conf(5)>, which
defaults to C<journal>. Note that setting this parameter might result in additional dependencies
to be added to the unit (see above). I< Optional. Type enum. choice: 'inherit', 'journal', 'journal+console', 'kmsg', 'kmsg+console', 'null', 'socket', 'tty'.  > 

=head2 StandardError

Controls where file descriptor 2 (stderr) of the executed processes is connected to. The
available options are identical to those of C<StandardOutput>, with some exceptions: if set to
C<inherit> the file descriptor used for standard output is duplicated for standard error, while
C<fd:name> will use a default file descriptor name of
C<stderr>.

This setting defaults to the value set with C<DefaultStandardError> in
L<systemd-system.conf(5)>, which
defaults to C<inherit>. Note that setting this parameter might result in additional dependencies
to be added to the unit (see above). I< Optional. Type uniline.  > 

=head2 StandardInputText

Configures arbitrary textual or binary data to pass via file descriptor 0 (STDIN) to
the executed processes. These settings have no effect unless C<StandardInput> is set
to C<data> (which is the default if C<StandardInput> is not set
otherwise, but C<StandardInputText>/C<StandardInputData> is). Use
this option to embed process input data directly in the unit file.

C<StandardInputText> accepts arbitrary textual data. C-style escapes for special
characters as well as the usual C<%>-specifiers are resolved. Each time this setting is used
the specified text is appended to the per-unit data buffer, followed by a newline character (thus every use
appends a new line to the end of the buffer). Note that leading and trailing whitespace of lines configured
with this option is removed. If an empty line is specified the buffer is cleared (hence, in order to insert an
empty line, add an additional C<\n> to the end or beginning of a line).

C<StandardInputData> accepts arbitrary binary data, encoded in
L<Base64|https://tools.ietf.org/html/rfc2045#section-6.8>. No escape sequences or specifiers are
resolved. Any whitespace in the encoded version is ignored during decoding.

Note that C<StandardInputText> and C<StandardInputData> operate on the
same data buffer, and may be mixed in order to configure both binary and textual data for the same input
stream. The textual or binary data is joined strictly in the order the settings appear in the unit
file. Assigning an empty string to either will reset the data buffer.

Please keep in mind that in order to maintain readability long unit file settings may be split into
multiple lines, by suffixing each line (except for the last) with a C<\> character (see
L<systemd.unit(5)> for
details). This is particularly useful for large data configured with these two options. Example:

    …
    StandardInput=data
    StandardInputData=V2XigLJyZSBubyBzdHJhbmdlcnMgdG8gbG92ZQpZb3Uga25vdyB0aGUgcnVsZXMgYW5kIHNvIGRv \
    IEkKQSBmdWxsIGNvbW1pdG1lbnQncyB3aGF0IEnigLJtIHRoaW5raW5nIG9mCllvdSB3b3VsZG4n \
    dCBnZXQgdGhpcyBmcm9tIGFueSBvdGhlciBndXkKSSBqdXN0IHdhbm5hIHRlbGwgeW91IGhvdyBJ \
    J20gZmVlbGluZwpHb3R0YSBtYWtlIHlvdSB1bmRlcnN0YW5kCgpOZXZlciBnb25uYSBnaXZlIHlv \
    dSB1cApOZXZlciBnb25uYSBsZXQgeW91IGRvd24KTmV2ZXIgZ29ubmEgcnVuIGFyb3VuZCBhbmQg \
    ZGVzZXJ0IHlvdQpOZXZlciBnb25uYSBtYWtlIHlvdSBjcnkKTmV2ZXIgZ29ubmEgc2F5IGdvb2Ri \
    eWUKTmV2ZXIgZ29ubmEgdGVsbCBhIGxpZSBhbmQgaHVydCB5b3UK
    …
I< Optional. Type uniline.  > 

=head2 StandardInputData

Configures arbitrary textual or binary data to pass via file descriptor 0 (STDIN) to
the executed processes. These settings have no effect unless C<StandardInput> is set
to C<data> (which is the default if C<StandardInput> is not set
otherwise, but C<StandardInputText>/C<StandardInputData> is). Use
this option to embed process input data directly in the unit file.

C<StandardInputText> accepts arbitrary textual data. C-style escapes for special
characters as well as the usual C<%>-specifiers are resolved. Each time this setting is used
the specified text is appended to the per-unit data buffer, followed by a newline character (thus every use
appends a new line to the end of the buffer). Note that leading and trailing whitespace of lines configured
with this option is removed. If an empty line is specified the buffer is cleared (hence, in order to insert an
empty line, add an additional C<\n> to the end or beginning of a line).

C<StandardInputData> accepts arbitrary binary data, encoded in
L<Base64|https://tools.ietf.org/html/rfc2045#section-6.8>. No escape sequences or specifiers are
resolved. Any whitespace in the encoded version is ignored during decoding.

Note that C<StandardInputText> and C<StandardInputData> operate on the
same data buffer, and may be mixed in order to configure both binary and textual data for the same input
stream. The textual or binary data is joined strictly in the order the settings appear in the unit
file. Assigning an empty string to either will reset the data buffer.

Please keep in mind that in order to maintain readability long unit file settings may be split into
multiple lines, by suffixing each line (except for the last) with a C<\> character (see
L<systemd.unit(5)> for
details). This is particularly useful for large data configured with these two options. Example:

    …
    StandardInput=data
    StandardInputData=V2XigLJyZSBubyBzdHJhbmdlcnMgdG8gbG92ZQpZb3Uga25vdyB0aGUgcnVsZXMgYW5kIHNvIGRv \
    IEkKQSBmdWxsIGNvbW1pdG1lbnQncyB3aGF0IEnigLJtIHRoaW5raW5nIG9mCllvdSB3b3VsZG4n \
    dCBnZXQgdGhpcyBmcm9tIGFueSBvdGhlciBndXkKSSBqdXN0IHdhbm5hIHRlbGwgeW91IGhvdyBJ \
    J20gZmVlbGluZwpHb3R0YSBtYWtlIHlvdSB1bmRlcnN0YW5kCgpOZXZlciBnb25uYSBnaXZlIHlv \
    dSB1cApOZXZlciBnb25uYSBsZXQgeW91IGRvd24KTmV2ZXIgZ29ubmEgcnVuIGFyb3VuZCBhbmQg \
    ZGVzZXJ0IHlvdQpOZXZlciBnb25uYSBtYWtlIHlvdSBjcnkKTmV2ZXIgZ29ubmEgc2F5IGdvb2Ri \
    eWUKTmV2ZXIgZ29ubmEgdGVsbCBhIGxpZSBhbmQgaHVydCB5b3UK
    …
I< Optional. Type uniline.  > 

=head2 LogLevelMax

Sets the maximum log level for log messages generated by this unit. Takes a
syslog log level, one of C<emerg> (lowest log level, only highest
priority messages), C<alert>, C<crit>, C<err>,
C<warning>, C<notice>, C<info>, C<debug>
(highest log level, also lowest priority messages). See L<syslog(3)> for
details. By default, the maximum log level is not overridden.

This option can be used to configure the logging system to drop log messages of a specific
service above the specified level. For example, set
C<LogLevelMax>=C<info> in order to turn off debug logging of a
particularly chatty unit. Alternatively, this option can be used to enable extra logging about a
specific unit by the system or user manager processes without changing the global log level for the
system or user manager processes by setting C<LogLevelMax>=C<debug>.

Note that the configured level is applied to any log messages written by any of the processes
belonging to this unit, as well as any log messages written by the system or user manager processes
in reference to this unit, sent via any supported logging protocol. The override is applied early in
the logging pipeline, before any kind of further processing is done. Moreover, messages which pass
through this filter successfully might still be dropped by filters applied at a later stage in the
logging subsystem. For example, C<MaxLevelStore> configured in
L<journald.conf(5)>
might prohibit messages of higher log levels to be stored on disk, even though the per-unit
C<LogLevelMax> permitted it to be processed. I< Optional. Type uniline.  > 

=head2 LogExtraFields

Configures additional log metadata fields to include in all log records generated by
processes associated with this unit, including systemd. This setting takes one or more journal field
assignments in the format C<FIELD=VALUE> separated by whitespace. See
L<systemd.journal-fields(7)>
for details on the journal field concept. Even though the underlying journal implementation permits
binary field values, this setting accepts only valid UTF-8 values. To include space characters in a
journal field value, enclose the assignment in double quotes (").
The usual specifiers are expanded in all assignments (see below). Note that this setting is not only
useful for attaching additional metadata to log records of a unit, but given that all fields and
values are indexed may also be used to implement cross-unit log record matching. Assign an empty
string to reset the list.

Note that this functionality is currently only available in system services, not in per-user
services. I< Optional. Type uniline.  > 

=head2 LogRateLimitIntervalSec

Configures the rate limiting that is applied to log messages generated by this unit.
If, in the time interval defined by C<LogRateLimitIntervalSec>, more messages than
specified in C<LogRateLimitBurst> are logged by a service, all further messages
within the interval are dropped until the interval is over. A message about the number of dropped
messages is generated. The time specification for C<LogRateLimitIntervalSec> may be
specified in the following units: "s", "min", "h", "ms", "us". See
L<systemd.time(7)> for
details. The default settings are set by C<RateLimitIntervalSec> and
C<RateLimitBurst> configured in
L<journald.conf(5)>.
Note that this only applies to log messages that are processed by the logging subsystem, i.e. by
L<systemd-journald.service(8)>.
This means that if you connect a service's stderr directly to a file via
C<StandardOutput=file:…> or a similar setting, the rate limiting will not be applied
to messages written that way (but it will be enforced for messages generated via
L<syslog(3)>
and similar functions). I< Optional. Type uniline.  > 

=head2 LogRateLimitBurst

Configures the rate limiting that is applied to log messages generated by this unit.
If, in the time interval defined by C<LogRateLimitIntervalSec>, more messages than
specified in C<LogRateLimitBurst> are logged by a service, all further messages
within the interval are dropped until the interval is over. A message about the number of dropped
messages is generated. The time specification for C<LogRateLimitIntervalSec> may be
specified in the following units: "s", "min", "h", "ms", "us". See
L<systemd.time(7)> for
details. The default settings are set by C<RateLimitIntervalSec> and
C<RateLimitBurst> configured in
L<journald.conf(5)>.
Note that this only applies to log messages that are processed by the logging subsystem, i.e. by
L<systemd-journald.service(8)>.
This means that if you connect a service's stderr directly to a file via
C<StandardOutput=file:…> or a similar setting, the rate limiting will not be applied
to messages written that way (but it will be enforced for messages generated via
L<syslog(3)>
and similar functions). I< Optional. Type uniline.  > 

=head2 LogFilterPatterns

Define an extended regular expression to filter log messages based on the
C<MESSAGE> field of the structured message. If the first character of the pattern is
C<~>, log entries matching the pattern should be discarded. This option takes a single
pattern as an argument but can be used multiple times to create a list of allowed and denied patterns.
If the empty string is assigned, the filter is reset, and all prior assignments will have no effect.

Because the C<~> character is used to define denied patterns, it must be replaced
with C<\x7e> to allow a message starting with C<~>. For example,
C<~foobar> would add a pattern matching C<foobar> to the deny list, while
C<\x7efoobar> would add a pattern matching C<~foobar> to the allow list.

Log messages are tested against denied patterns (if any), then against allowed patterns
(if any). If a log message matches any of the denied patterns, it is discarded immediately without considering
allowed patterns. Remaining log messages are tested against allowed patterns. Messages matching
against none of the allowed pattern are discarded. If no allowed patterns are defined, then all
messages are processed directly after going through denied filters.

Filtering is based on the unit for which C<LogFilterPatterns> is defined, meaning log
messages coming from
L<systemd(1)> about the
unit are not taken into account. Filtered log messages will not be forwarded to traditional syslog daemons,
the kernel log buffer (kmsg), the systemd console, or sent as wall messages to all logged-in
users.

Note that this functionality is currently only available in system services, not in per-user
services. I< Optional. Type uniline.  > 

=head2 LogNamespace

Run the unit's processes in the specified journal namespace. Expects a short
user-defined string identifying the namespace. If not used the processes of the service are run in
the default journal namespace, i.e. their log stream is collected and processed by
C<systemd-journald.service>. If this option is used any log data generated by
processes of this unit (regardless of whether via the syslog(), journal native logging
or stdout/stderr logging) is collected and processed by an instance of the
C<systemd-journald@.service> template unit, which manages the specified
namespace. The log data is stored in a data store independent from the default log namespace's data
store. See
L<systemd-journald.service(8)>
for details about journal namespaces.

Internally, journal namespaces are implemented through Linux mount namespacing and
over-mounting the directory that contains the relevant C<AF_UNIX> sockets used for
logging in the unit's mount namespace. Since mount namespaces are used this setting disconnects
propagation of mounts from the unit's processes to the host, similarly to how
C<ReadOnlyPaths> and similar settings describe above work. Journal namespaces may hence
not be used for services that need to establish mount points on the host.

When this option is used the unit will automatically gain ordering and requirement dependencies
on the two socket units associated with the C<systemd-journald@.service> instance
so that they are automatically established prior to the unit starting up. Note that when this option
is used log output of this service does not appear in the regular
L<journalctl(1)>
output, unless the C<--namespace=> option is used. I< Optional. Type uniline.  > 

=head2 SyslogIdentifier

Sets the process name ("syslog tag") to prefix log lines sent to
the logging system or the kernel log buffer with. If not set, defaults to the process name of the
executed process. This option is only useful when C<StandardOutput> or
C<StandardError> are set to C<journal> or C<kmsg> (or to
the same settings in combination with C<+console>) and only applies to log messages
written to stdout or stderr. I< Optional. Type uniline.  > 

=head2 SyslogFacility

Sets the syslog facility identifier to use when logging. One of
C<kern>, C<user>, C<mail>, C<daemon>,
C<auth>, C<syslog>, C<lpr>, C<news>,
C<uucp>, C<cron>, C<authpriv>, C<ftp>,
C<local0>, C<local1>, C<local2>, C<local3>,
C<local4>, C<local5>, C<local6> or
C<local7>. See L<syslog(3)> for
details. This option is only useful when C<StandardOutput> or
C<StandardError> are set to C<journal> or C<kmsg> (or to
the same settings in combination with C<+console>), and only applies to log messages
written to stdout or stderr. Defaults to C<daemon>. I< Optional. Type uniline.  > 

=head2 SyslogLevel

The default syslog log level to use when logging to the logging system or
the kernel log buffer. One of C<emerg>, C<alert>, C<crit>,
C<err>, C<warning>, C<notice>, C<info>,
C<debug>. See L<syslog(3)> for
details. This option is only useful when C<StandardOutput> or
C<StandardError> are set to C<journal> or
C<kmsg> (or to the same settings in combination with C<+console>), and only applies
to log messages written to stdout or stderr. Note that individual lines output by executed processes may be
prefixed with a different log level which can be used to override the default log level specified here. The
interpretation of these prefixes may be disabled with C<SyslogLevelPrefix>, see below. For
details, see L<sd-daemon(3)>.
Defaults to C<info>. I< Optional. Type uniline.  > 

=head2 SyslogLevelPrefix

Takes a boolean argument. If true and C<StandardOutput> or
C<StandardError> are set to C<journal> or C<kmsg> (or to
the same settings in combination with C<+console>), log lines written by the executed
process that are prefixed with a log level will be processed with this log level set but the prefix
removed. If set to false, the interpretation of these prefixes is disabled and the logged lines are
passed on as-is. This only applies to log messages written to stdout or stderr. For details about
this prefixing see
L<sd-daemon(3)>.
Defaults to true. I< Optional. Type boolean.  > 

=over 4

=item upstream_default value :

yes

=back



=head2 TTYPath

Sets the terminal device node to use if standard input, output, or error are connected to a TTY
(see above). Defaults to C</dev/console>. I< Optional. Type uniline.  > 

=head2 TTYReset

Reset the terminal device specified with C<TTYPath> before and after
execution. This does not erase the screen (see C<TTYVTDisallocate> below for
that). Defaults to C<no>. I< Optional. Type uniline.  > 

=head2 TTYVHangup

Disconnect all clients which have opened the terminal device specified with
C<TTYPath> before and after execution. Defaults to C<no>. I< Optional. Type uniline.  > 

=head2 TTYColumns

Configure the size of the TTY specified with C<TTYPath>. If unset or
set to the empty string, it is attempted to retrieve the dimensions of the terminal screen via ANSI
sequences, and if that fails the kernel defaults (typically 80x24) are used. I< Optional. Type uniline.  > 

=head2 TTYRows

Configure the size of the TTY specified with C<TTYPath>. If unset or
set to the empty string, it is attempted to retrieve the dimensions of the terminal screen via ANSI
sequences, and if that fails the kernel defaults (typically 80x24) are used. I< Optional. Type uniline.  > 

=head2 TTYVTDisallocate

If the terminal device specified with C<TTYPath> is a virtual
console terminal, try to deallocate the TTY before and after execution. This ensures that the screen
and scrollback buffer is cleared. If the terminal device is of any other type of TTY an attempt is
made to clear the screen via ANSI sequences. Defaults to C<no>. I< Optional. Type uniline.  > 

=head2 LoadCredential

Pass a credential to the unit. Credentials are limited-size binary or textual objects
that may be passed to unit processes. They are primarily intended for passing cryptographic keys
(both public and private) or certificates, user account information or identity information from host
to services, but can be freely used to pass any kind of limited-size information to a service. The
data is accessible from the unit's processes via the file system, at a read-only location that (if
possible and permitted) is backed by non-swappable memory. The data is only accessible to the user
associated with the unit, via the C<User>/C<DynamicUser> settings
(as well as the superuser). When available, the location of credentials is exported as the
C<$CREDENTIALS_DIRECTORY> environment variable to the unit's processes.

The C<LoadCredential> setting takes a textual ID to use as name for a
credential plus a file system path, separated by a colon. The ID must be a short ASCII string
suitable as filename in the filesystem, and may be chosen freely by the user. If the specified path
is absolute it is opened as regular file and the credential data is read from it. If the absolute
path refers to an C<AF_UNIX> stream socket in the file system a connection is made
to it (once at process invocation) and the credential data read from the connection, providing an
easy IPC integration point for dynamically transferring credentials from other services.

If the specified path is not absolute and itself qualifies as valid credential identifier it is
attempted to find a credential that the service manager itself received under the specified name —
which may be used to propagate credentials from an invoking environment (e.g. a container manager
that invoked the service manager) into a service. If no matching passed credential is found, the
system service manager will search the directories C</etc/credstore/>,
C</run/credstore/> and C</usr/lib/credstore/> for files under the
credential's name — which hence are recommended locations for credential data on disk. If
C<LoadCredentialEncrypted> is used C</run/credstore.encrypted/>,
C</etc/credstore.encrypted/>, and
C</usr/lib/credstore.encrypted/> are searched as well. The per-user service manager
will search C<$XDG_CONFIG_HOME/credstore/>,
C<$XDG_RUNTIME_DIR/credstore/>, C<$HOME/.local/lib/credstore/>
(and the counterparts ending with C<…/credstore.encrypted/>) instead. The
L<systemd-path(1)> tool
may be used to query the precise credential store search path.

If the file system path is omitted it is chosen identical to the credential name, i.e. this is
a terse way to declare credentials to inherit from the service manager or credstore directories into
a service. This option may be used multiple times, each time defining an additional credential to
pass to the unit.

Note that if the path is not specified or a valid credential identifier is given, i.e.
in the above two cases, a missing credential is not considered fatal.

If an absolute path referring to a directory is specified, every file in that directory
(recursively) will be loaded as a separate credential. The ID for each credential will be the
provided ID suffixed with C<_$FILENAME> (e.g., C<Key_file1>). When
loading from a directory, symlinks will be ignored.

The contents of the file/socket may be arbitrary binary or textual data, including newline
characters and C<NUL> bytes.

The C<LoadCredentialEncrypted> setting is identical to
C<LoadCredential>, except that the credential data is decrypted and authenticated
before being passed on to the executed processes. Specifically, the referenced path should refer to a
file or socket with an encrypted credential, as implemented by
L<systemd-creds(1)>. This
credential is loaded, decrypted, authenticated and then passed to the application in plaintext form,
in the same way a regular credential specified via C<LoadCredential> would be. A
credential configured this way may be symmetrically encrypted/authenticated with a secret key derived
from the system's TPM2 security chip, or with a secret key stored in
C</var/lib/systemd/credential.secret>, or with both. Using encrypted and
authenticated credentials improves security as credentials are not stored in plaintext and only
authenticated and decrypted into plaintext the moment a service requiring them is started. Moreover,
credentials may be bound to the local hardware and installations, so that they cannot easily be
analyzed offline, or be generated externally. See
L<systemd.resource-control(5)>
for the details about C<DevicePolicy> or C<DeviceAllow>.

Note that encrypted credentials targeted for services of the per-user service manager must be
encrypted with systemd-creds encrypt --user, and those for the system service
manager without the C<--user> switch. Encrypted credentials are always targeted to a
specific user or the system as a whole, and it is ensured that per-user service managers cannot
decrypt secrets intended for the system or for other users.

The credential files/IPC sockets must be accessible to the service manager, but do not have to
be directly accessible to the unit's processes: the credential data is read and copied into separate,
read-only copies for the unit that are accessible to appropriately privileged processes. This is
particularly useful in combination with C<DynamicUser> as this way privileged data
can be made available to processes running under a dynamic UID (i.e. not a previously known one)
without having to open up access to all users.

In order to reference the path a credential may be read from within a
C<ExecStart> command line use C<${CREDENTIALS_DIRECTORY}/mycred>,
e.g. C<ExecStart=cat ${CREDENTIALS_DIRECTORY}/mycred>. In order to reference the path
a credential may be read from within a C<Environment> line use
C<%d/mycred>, e.g. C<Environment=MYCREDPATH=%d/mycred>. For system
services the path may also be referenced as
C</run/credentials/UNITNAME> in cases where no
interpolation is possible, e.g. configuration files of software that does not yet support credentials
natively. C<$CREDENTIALS_DIRECTORY> is considered the primary interface to look for
credentials, though, since it also works for user services.

Currently, an accumulated credential size limit of 1 MB per unit is enforced.

The service manager itself may receive system credentials that can be propagated to services
from a hosting container manager or VM hypervisor. See the L<Container
Interface|https://systemd.io/CONTAINER_INTERFACE> documentation for details
about the former. For the latter, pass L<DMI/SMBIOS|https://www.dmtf.org/standards/smbios> OEM string table entries
(field type
11) with a prefix of C<io.systemd.credential:> or
C<io.systemd.credential.binary:>. In both cases a key/value pair separated by
C<=> is expected. In the latter case, the right-hand side is Base64 decoded when
parsed (thus permitting binary data to be passed in). Example
L<qemu|https://www.qemu.org/docs/master/system/index.html> switch: C<-smbios
type=11,value=io.systemd.credential:xx=yy>, or C<-smbios
type=11,value=io.systemd.credential.binary:rick=TmV2ZXIgR29ubmEgR2l2ZSBZb3UgVXA=>. Alternatively,
use the qemu C<fw_cfg> node
C<opt/io.systemd.credentials/>. Example qemu switch:
C<-fw_cfg name=opt/io.systemd.credentials/mycred,string=supersecret>. They may also
be passed from the UEFI firmware environment via
L<systemd-stub(7)>,
from the initrd (see
L<systemd(1)>), or be
specified on the kernel command line using the C<systemd.set_credential=> and
C<systemd.set_credential_binary=> switches (see
L<systemd(1)> – this is
not recommended since unprivileged userspace can read the kernel command line).

If referencing an C<AF_UNIX> stream socket to connect to, the connection will
originate from an abstract namespace socket, that includes information about the unit and the
credential ID in its socket name. Use L<getpeername(2)>
to query this information. The returned socket name is formatted as C<NUL>RANDOM C</unit/> UNITC</> ID, i.e. a C<NUL>
byte (as required
for abstract namespace socket names), followed by a random string (consisting of alphadecimal
characters), followed by the literal string C</unit/>, followed by the requesting
unit name, followed by the literal character C</>, followed by the textual credential
ID requested. Example: C<\0adf9d86b6eda275e/unit/foobar.service/credx> in case the
credential C<credx> is requested for a unit C<foobar.service>. This
functionality is useful for using a single listening socket to serve credentials to multiple
consumers.

For further information see L<System and Service
Credentials|https://systemd.io/CREDENTIALS> documentation. I< Optional. Type uniline.  > 

=head2 LoadCredentialEncrypted

Pass a credential to the unit. Credentials are limited-size binary or textual objects
that may be passed to unit processes. They are primarily intended for passing cryptographic keys
(both public and private) or certificates, user account information or identity information from host
to services, but can be freely used to pass any kind of limited-size information to a service. The
data is accessible from the unit's processes via the file system, at a read-only location that (if
possible and permitted) is backed by non-swappable memory. The data is only accessible to the user
associated with the unit, via the C<User>/C<DynamicUser> settings
(as well as the superuser). When available, the location of credentials is exported as the
C<$CREDENTIALS_DIRECTORY> environment variable to the unit's processes.

The C<LoadCredential> setting takes a textual ID to use as name for a
credential plus a file system path, separated by a colon. The ID must be a short ASCII string
suitable as filename in the filesystem, and may be chosen freely by the user. If the specified path
is absolute it is opened as regular file and the credential data is read from it. If the absolute
path refers to an C<AF_UNIX> stream socket in the file system a connection is made
to it (once at process invocation) and the credential data read from the connection, providing an
easy IPC integration point for dynamically transferring credentials from other services.

If the specified path is not absolute and itself qualifies as valid credential identifier it is
attempted to find a credential that the service manager itself received under the specified name —
which may be used to propagate credentials from an invoking environment (e.g. a container manager
that invoked the service manager) into a service. If no matching passed credential is found, the
system service manager will search the directories C</etc/credstore/>,
C</run/credstore/> and C</usr/lib/credstore/> for files under the
credential's name — which hence are recommended locations for credential data on disk. If
C<LoadCredentialEncrypted> is used C</run/credstore.encrypted/>,
C</etc/credstore.encrypted/>, and
C</usr/lib/credstore.encrypted/> are searched as well. The per-user service manager
will search C<$XDG_CONFIG_HOME/credstore/>,
C<$XDG_RUNTIME_DIR/credstore/>, C<$HOME/.local/lib/credstore/>
(and the counterparts ending with C<…/credstore.encrypted/>) instead. The
L<systemd-path(1)> tool
may be used to query the precise credential store search path.

If the file system path is omitted it is chosen identical to the credential name, i.e. this is
a terse way to declare credentials to inherit from the service manager or credstore directories into
a service. This option may be used multiple times, each time defining an additional credential to
pass to the unit.

Note that if the path is not specified or a valid credential identifier is given, i.e.
in the above two cases, a missing credential is not considered fatal.

If an absolute path referring to a directory is specified, every file in that directory
(recursively) will be loaded as a separate credential. The ID for each credential will be the
provided ID suffixed with C<_$FILENAME> (e.g., C<Key_file1>). When
loading from a directory, symlinks will be ignored.

The contents of the file/socket may be arbitrary binary or textual data, including newline
characters and C<NUL> bytes.

The C<LoadCredentialEncrypted> setting is identical to
C<LoadCredential>, except that the credential data is decrypted and authenticated
before being passed on to the executed processes. Specifically, the referenced path should refer to a
file or socket with an encrypted credential, as implemented by
L<systemd-creds(1)>. This
credential is loaded, decrypted, authenticated and then passed to the application in plaintext form,
in the same way a regular credential specified via C<LoadCredential> would be. A
credential configured this way may be symmetrically encrypted/authenticated with a secret key derived
from the system's TPM2 security chip, or with a secret key stored in
C</var/lib/systemd/credential.secret>, or with both. Using encrypted and
authenticated credentials improves security as credentials are not stored in plaintext and only
authenticated and decrypted into plaintext the moment a service requiring them is started. Moreover,
credentials may be bound to the local hardware and installations, so that they cannot easily be
analyzed offline, or be generated externally. See
L<systemd.resource-control(5)>
for the details about C<DevicePolicy> or C<DeviceAllow>.

Note that encrypted credentials targeted for services of the per-user service manager must be
encrypted with systemd-creds encrypt --user, and those for the system service
manager without the C<--user> switch. Encrypted credentials are always targeted to a
specific user or the system as a whole, and it is ensured that per-user service managers cannot
decrypt secrets intended for the system or for other users.

The credential files/IPC sockets must be accessible to the service manager, but do not have to
be directly accessible to the unit's processes: the credential data is read and copied into separate,
read-only copies for the unit that are accessible to appropriately privileged processes. This is
particularly useful in combination with C<DynamicUser> as this way privileged data
can be made available to processes running under a dynamic UID (i.e. not a previously known one)
without having to open up access to all users.

In order to reference the path a credential may be read from within a
C<ExecStart> command line use C<${CREDENTIALS_DIRECTORY}/mycred>,
e.g. C<ExecStart=cat ${CREDENTIALS_DIRECTORY}/mycred>. In order to reference the path
a credential may be read from within a C<Environment> line use
C<%d/mycred>, e.g. C<Environment=MYCREDPATH=%d/mycred>. For system
services the path may also be referenced as
C</run/credentials/UNITNAME> in cases where no
interpolation is possible, e.g. configuration files of software that does not yet support credentials
natively. C<$CREDENTIALS_DIRECTORY> is considered the primary interface to look for
credentials, though, since it also works for user services.

Currently, an accumulated credential size limit of 1 MB per unit is enforced.

The service manager itself may receive system credentials that can be propagated to services
from a hosting container manager or VM hypervisor. See the L<Container
Interface|https://systemd.io/CONTAINER_INTERFACE> documentation for details
about the former. For the latter, pass L<DMI/SMBIOS|https://www.dmtf.org/standards/smbios> OEM string table entries
(field type
11) with a prefix of C<io.systemd.credential:> or
C<io.systemd.credential.binary:>. In both cases a key/value pair separated by
C<=> is expected. In the latter case, the right-hand side is Base64 decoded when
parsed (thus permitting binary data to be passed in). Example
L<qemu|https://www.qemu.org/docs/master/system/index.html> switch: C<-smbios
type=11,value=io.systemd.credential:xx=yy>, or C<-smbios
type=11,value=io.systemd.credential.binary:rick=TmV2ZXIgR29ubmEgR2l2ZSBZb3UgVXA=>. Alternatively,
use the qemu C<fw_cfg> node
C<opt/io.systemd.credentials/>. Example qemu switch:
C<-fw_cfg name=opt/io.systemd.credentials/mycred,string=supersecret>. They may also
be passed from the UEFI firmware environment via
L<systemd-stub(7)>,
from the initrd (see
L<systemd(1)>), or be
specified on the kernel command line using the C<systemd.set_credential=> and
C<systemd.set_credential_binary=> switches (see
L<systemd(1)> – this is
not recommended since unprivileged userspace can read the kernel command line).

If referencing an C<AF_UNIX> stream socket to connect to, the connection will
originate from an abstract namespace socket, that includes information about the unit and the
credential ID in its socket name. Use L<getpeername(2)>
to query this information. The returned socket name is formatted as C<NUL>RANDOM C</unit/> UNITC</> ID, i.e. a C<NUL>
byte (as required
for abstract namespace socket names), followed by a random string (consisting of alphadecimal
characters), followed by the literal string C</unit/>, followed by the requesting
unit name, followed by the literal character C</>, followed by the textual credential
ID requested. Example: C<\0adf9d86b6eda275e/unit/foobar.service/credx> in case the
credential C<credx> is requested for a unit C<foobar.service>. This
functionality is useful for using a single listening socket to serve credentials to multiple
consumers.

For further information see L<System and Service
Credentials|https://systemd.io/CREDENTIALS> documentation. I< Optional. Type uniline.  > 

=head2 ImportCredential

Pass one or more credentials to the unit. Takes a credential name for which we will
attempt to find a credential that the service manager itself received under the specified name —
which may be used to propagate credentials from an invoking environment (e.g. a container manager
that invoked the service manager) into a service. If the credential name is a glob, all credentials
matching the glob are passed to the unit. Matching credentials are searched for in the system
credentials, the encrypted system credentials, and under C</etc/credstore/>,
C</run/credstore/>, C</usr/lib/credstore/>,
C</run/credstore.encrypted/>, C</etc/credstore.encrypted/>, and
C</usr/lib/credstore.encrypted/> in that order. When multiple credentials of the
same name are found, the first one found is used.

The globbing expression implements a restrictive subset of L<glob(7)>: only
a single trailing C<*> wildcard may be specified. Both C<?> and
C<[]> wildcards are not permitted, nor are C<*> wildcards anywhere
except at the end of the glob expression.

Optionally, the credential name or glob may be followed by a colon followed by a rename pattern.
If specified, all credentials matching the credential name or glob are renamed according to the given
pattern. For example, if C<ImportCredential=my.original.cred:my.renamed.cred> is
specified, the service manager will read the C<my.original.cred> credential and make
it available as the C<my.renamed.cred> credential to the service. Similarly, if
C<ImportCredential=my.original.*:my.renamed.> is specified, the service manager will
read all credentials starting with C<my.original.> and make them available as
C<my.renamed.xxx> to the service.

If C<ImportCredential> is specified multiple times and multiple credentials
end up with the same name after renaming, the first one is kept and later ones are dropped.

When multiple credentials of the same name are found, credentials found by
C<LoadCredential> and C<LoadCredentialEncrypted> take priority over
credentials found by C<ImportCredential>.

Note that if decryption or authentication of a credential picked up as result of
C<ImportCredential> fails it will be skipped gracefully (a warning is generated, but
the credential will not be made available to the invoked service). This is different for those
configured via
C<SetCredentialEncrypted>/C<LoadCredentialEncrypted>, where failed
decryption/authentication will result in service failure. I< Optional. Type uniline.  > 

=head2 SetCredential

The C<SetCredential> setting is similar to
C<LoadCredential> but accepts a literal value to use as data for the credential,
instead of a file system path to read the data from. Do not use this option for data that is supposed
to be secret, as it is accessible to unprivileged processes via IPC. It's only safe to use this for
user IDs, public key material and similar non-sensitive data. For everything else use
C<LoadCredential>. In order to embed binary data into the credential data use
C-style escaping (i.e. C<\n> to embed a newline, or C<\x00> to embed
a C<NUL> byte).

The C<SetCredentialEncrypted> setting is identical to
C<SetCredential> but expects an encrypted credential in literal form as value. This
allows embedding confidential credentials securely directly in unit files. Use
L<systemd-creds(1)>'
C<-p> switch to generate suitable C<SetCredentialEncrypted> lines
directly from plaintext credentials. For further details see
C<LoadCredentialEncrypted> above.

When multiple credentials of the same name are found, credentials found by
C<LoadCredential>, C<LoadCredentialEncrypted> and
C<ImportCredential> take priority over credentials found by
C<SetCredential>. As such, C<SetCredential> will act as default if
no credentials are found by any of the former. In this case, not being able to retrieve the credential
from the path specified in C<LoadCredential> or
C<LoadCredentialEncrypted> is not considered fatal. I< Optional. Type uniline.  > 

=head2 SetCredentialEncrypted

The C<SetCredential> setting is similar to
C<LoadCredential> but accepts a literal value to use as data for the credential,
instead of a file system path to read the data from. Do not use this option for data that is supposed
to be secret, as it is accessible to unprivileged processes via IPC. It's only safe to use this for
user IDs, public key material and similar non-sensitive data. For everything else use
C<LoadCredential>. In order to embed binary data into the credential data use
C-style escaping (i.e. C<\n> to embed a newline, or C<\x00> to embed
a C<NUL> byte).

The C<SetCredentialEncrypted> setting is identical to
C<SetCredential> but expects an encrypted credential in literal form as value. This
allows embedding confidential credentials securely directly in unit files. Use
L<systemd-creds(1)>'
C<-p> switch to generate suitable C<SetCredentialEncrypted> lines
directly from plaintext credentials. For further details see
C<LoadCredentialEncrypted> above.

When multiple credentials of the same name are found, credentials found by
C<LoadCredential>, C<LoadCredentialEncrypted> and
C<ImportCredential> take priority over credentials found by
C<SetCredential>. As such, C<SetCredential> will act as default if
no credentials are found by any of the former. In this case, not being able to retrieve the credential
from the path specified in C<LoadCredential> or
C<LoadCredentialEncrypted> is not considered fatal. I< Optional. Type uniline.  > 

=head2 UtmpIdentifier

Takes a four character identifier string for an L<utmp(5)> and wtmp entry
for this service. This should only be set for services such as getty implementations (such
as L<agetty(8)>) where utmp/wtmp
entries must be created and cleared before and after execution, or for services that shall be executed as if
they were run by a getty process (see below). If the configured string is longer than four
characters, it is truncated and the terminal four characters are used. This setting interprets %I style string
replacements. This setting is unset by default, i.e. no utmp/wtmp entries are created or cleaned up for this
service. I< Optional. Type uniline.  > 

=head2 UtmpMode

Takes one of C<init>, C<login> or C<user>. If
C<UtmpIdentifier> is set, controls which type of L<utmp(5)>/wtmp entries
for this service are generated. This setting has no effect unless C<UtmpIdentifier> is set
too. If C<init> is set, only an C<INIT_PROCESS> entry is generated and the
invoked process must implement a getty-compatible utmp/wtmp logic. If
C<login> is set, first an C<INIT_PROCESS> entry, followed by a
C<LOGIN_PROCESS> entry is generated. In this case, the invoked process must implement a
L<login(1)>-compatible
utmp/wtmp logic. If C<user> is set, first an C<INIT_PROCESS> entry, then a
C<LOGIN_PROCESS> entry and finally a C<USER_PROCESS> entry is
generated. In this case, the invoked process may be any process that is suitable to be run as session
leader. Defaults to C<init>. I< Optional. Type enum. choice: 'init', 'login', 'user'.  > 

=head2 KillMode

Specifies how processes of this unit shall be killed. One of
C<control-group>, C<mixed>, C<process>,
C<none>.

If set to C<control-group>, all remaining processes in the control group of this
unit will be killed on unit stop (for services: after the stop command is executed, as configured
with C<ExecStop>). If set to C<mixed>, the
C<SIGTERM> signal (see below) is sent to the main process while the subsequent
C<SIGKILL> signal (see below) is sent to all remaining processes of the unit's
control group. If set to C<process>, only the main process itself is killed (not
recommended!). If set to C<none>, no process is killed (strongly recommended
against!). In this case, only the stop command will be executed on unit stop, but no process will be
killed otherwise.  Processes remaining alive after stop are left in their control group and the
control group continues to exist after stop unless empty.

Note that it is not recommended to set C<KillMode> to
C<process> or even C<none>, as this allows processes to escape
the service manager's lifecycle and resource management, and to remain running even while their
service is considered stopped and is assumed to not consume any resources.

Processes will first be terminated via C<SIGTERM> (unless the signal to send
is changed via C<KillSignal> or C<RestartKillSignal>). Optionally,
this is immediately followed by a C<SIGHUP> (if enabled with
C<SendSIGHUP>). If processes still remain after:
the main process of a unit has exited (applies to C<KillMode>:
C<mixed>)the delay configured via the C<TimeoutStopSec> has passed
(applies to C<KillMode>: C<control-group>, C<mixed>,
C<process>)
the termination request is repeated with the C<SIGKILL> signal or the signal specified via
C<FinalKillSignal> (unless this is disabled via the C<SendSIGKILL>
option). See L<kill(2)>
for more information.

Defaults to C<control-group>. I< Optional. Type uniline.  > 

=head2 KillSignal

Specifies which signal to use when stopping a service. This controls the signal that
is sent as first step of shutting down a unit (see above), and is usually followed by
C<SIGKILL> (see above and below). For a list of valid signals, see
L<signal(7)>.
Defaults to C<SIGTERM>.

Note that, right after sending the signal specified in this setting, systemd will always send
C<SIGCONT>, to ensure that even suspended tasks can be terminated cleanly. I< Optional. Type uniline.  > 

=head2 RestartKillSignal

Specifies which signal to use when restarting a service. The same as
C<KillSignal> described above, with the exception that this setting is used in a
restart job. Not set by default, and the value of C<KillSignal> is used. I< Optional. Type uniline.  > 

=head2 SendSIGHUP

Specifies whether to send
C<SIGHUP> to remaining processes immediately
after sending the signal configured with
C<KillSignal>. This is useful to indicate to
shells and shell-like programs that their connection has been
severed. Takes a boolean value. Defaults to C<no>.
I< Optional. Type boolean.  > 

=over 4

=item upstream_default value :

no

=back



=head2 SendSIGKILL

Specifies whether to send
C<SIGKILL> (or the signal specified by
C<FinalKillSignal>) to remaining processes
after a timeout, if the normal shutdown procedure left
processes of the service around. When disabled, a
C<KillMode> of C<control-group>
or C<mixed> service will not restart if
processes from prior services exist within the control group.
Takes a boolean value. Defaults to C<yes>.
I< Optional. Type boolean.  > 

=over 4

=item upstream_default value :

yes

=back



=head2 FinalKillSignal

Specifies which signal to send to remaining
processes after a timeout if C<SendSIGKILL>
is enabled. The signal configured here should be one that is
not typically caught and processed by services (C<SIGTERM>
is not suitable). Developers can find it useful to use this to
generate a coredump to troubleshoot why a service did not
terminate upon receiving the initial C<SIGTERM>
signal. This can be achieved by configuring C<LimitCORE>
and setting C<FinalKillSignal> to either
C<SIGQUIT> or C<SIGABRT>.
Defaults to C<SIGKILL>.
I< Optional. Type uniline.  > 

=head2 WatchdogSignal

Specifies which signal to use to terminate the
service when the watchdog timeout expires (enabled through
C<WatchdogSec>). Defaults to C<SIGABRT>.
I< Optional. Type uniline.  > 

=head2 Type

Configures the mechanism via which the service notifies the manager that the service start-up
has finished. One of C<simple>, C<exec>, C<forking>,
C<oneshot>, C<dbus>, C<notify>,
C<notify-reload>, or C<idle>:

It is recommended to use C<Type>=C<exec> for long-running
services, as it ensures that process setup errors (e.g. errors such as a missing service
executable, or missing user) are properly tracked. However, as this service type will not propagate
the failures in the service's own startup code (as opposed to failures in the preparatory steps the
service manager executes before execve()) and does not allow ordering of other
units against completion of initialization of the service code itself (which for example is useful
if clients need to connect to the service through some form of IPC, and the IPC channel is only
established by the service itself — in contrast to doing this ahead of time through socket or bus
activation or similar), it might not be sufficient for many cases. If so, C<notify>,
C<notify-reload>, or C<dbus> (the latter only in case the service
provides a D-Bus interface) are the preferred options as they allow service program code to
precisely schedule when to consider the service started up successfully and when to proceed with
follow-up units. The C<notify>/C<notify-reload> service types require
explicit support in the service codebase (as sd_notify() or an equivalent API
needs to be invoked by the service at the appropriate time) — if it is not supported, then
C<forking> is an alternative: it supports the traditional heavy-weight UNIX service
start-up protocol. Note that using any type other than C<simple> possibly delays the
boot process, as the service manager needs to wait for at least some service initialization to
complete. (Also note it is generally not recommended to use C<idle> or
C<oneshot> for long-running services.)

Note that various service settings (e.g. C<User>, C<Group>
through libc NSS) might result in "hidden" blocking IPC calls to other services when
used. Sometimes it might be advisable to use the C<simple> service type to ensure
that the service manager's transaction logic is not affected by such potentially slow operations
and hidden dependencies, as this is the only service type where the service manager will not wait
for such service execution setup operations to complete before proceeding. I< Optional. Type uniline.  > 

=head2 ExitType

Specifies when the manager should consider the service to be finished. One of C<main> or
C<cgroup>:

It is generally recommended to use C<ExitType>=C<main> when a service has
a known forking model and a main process can reliably be determined. C<ExitType>=C<cgroup> is meant for applications
whose forking model is not known ahead of time and which
might not have a specific main process. It is well suited for transient or automatically generated services,
such as graphical applications inside of a desktop environment. I< Optional. Type uniline.  > 

=head2 RemainAfterExit

Takes a boolean value that specifies whether
the service shall be considered active even when all its
processes exited. Defaults to C<no>. I< Optional. Type boolean.  > 

=over 4

=item upstream_default value :

no

=back



=head2 GuessMainPID

Takes a boolean value that specifies whether
systemd should try to guess the main PID of a service if it
cannot be determined reliably. This option is ignored unless
C<Type=forking> is set and
C<PIDFile> is unset because for the other types
or with an explicitly configured PID file, the main PID is
always known. The guessing algorithm might come to incorrect
conclusions if a daemon consists of more than one process. If
the main PID cannot be determined, failure detection and
automatic restarting of a service will not work reliably.
Defaults to C<yes>. I< Optional. Type boolean.  > 

=over 4

=item upstream_default value :

yes

=back



=head2 PIDFile

Takes a path referring to the PID file of the service. Usage of this option is
recommended for services where C<Type> is set to C<forking>. The path
specified typically points to a file below C</run/>. If a relative path is
specified for system service, then it is hence prefixed with C</run/>, and prefixed
with C<$XDG_RUNTIME_DIR> if specified in a user service. The service manager will
read the PID of the main process of the service from this file after start-up of the service. The
service manager will not write to the file configured here, although it will remove the file after
the service has shut down if it still exists. The PID file does not need to be owned by a privileged
user, but if it is owned by an unprivileged user additional safety restrictions are enforced: the
file may not be a symlink to a file owned by a different user (neither directly nor indirectly), and
the PID file must refer to a process already belonging to the service.

Note that PID files should be avoided in modern projects. Use C<Type=notify>,
C<Type=notify-reload> or C<Type=simple> where possible, which does not
require use of PID files to determine the main process of a service and avoids needless
forking. I< Optional. Type uniline.  > 

=head2 BusName

Takes a D-Bus destination name that this service shall use. This option is mandatory
for services where C<Type> is set to C<dbus>. It is recommended to
always set this property if known to make it easy to map the service name to the D-Bus destination.
In particular, systemctl service-log-level/service-log-target verbs make use of
this. I< Optional. Type uniline.  > 

=head2 ExecStart

Commands that are executed when this service is started.

Unless C<Type> is C<oneshot>, exactly one command must be
given. When C<Type=oneshot> is used, this setting may be used multiple times to
define multiple commands to execute. If the empty string is assigned to this option, the list of
commands to start is reset, prior assignments of this option will have no effect. If no
C<ExecStart> is specified, then the service must have
C<RemainAfterExit=yes> and at least one C<ExecStop> line
set. (Services lacking both C<ExecStart> and C<ExecStop> are not
valid.)

If more than one command is configured, the commands are invoked sequentially in the order they
appear in the unit file. If one of the commands fails (and is not prefixed with
C<->), other lines are not executed, and the unit is considered failed.

Unless C<Type=forking> is set, the process started via this command line will
be considered the main process of the daemon. I< Optional. Type list of uniline.  > 

=head2 ExecStartPre

Additional commands that are executed before or after the command in
C<ExecStart>, respectively. Syntax is the same as for C<ExecStart>.
Multiple command lines are allowed, regardless of the service type (i.e. C<Type>),
and the commands are executed one after the other, serially.

If any of those commands (not prefixed with
C<->) fail, the rest are not executed and the
unit is considered failed.

C<ExecStart> commands are only run after
all C<ExecStartPre> commands that were not prefixed
with a C<-> exit successfully.

C<ExecStartPost> commands are only run after the commands specified in
C<ExecStart> have been invoked successfully, as determined by
C<Type> (i.e. the process has been started for C<Type=simple> or
C<Type=idle>, the last C<ExecStart> process exited successfully for
C<Type=oneshot>, the initial process exited successfully for
C<Type=forking>, C<READY=1> is sent for
C<Type=notify>/C<Type=notify-reload>, or the
C<BusName> has been taken for C<Type=dbus>).

Note that C<ExecStartPre> may not be
used to start long-running processes. All processes forked
off by processes invoked via C<ExecStartPre> will
be killed before the next service process is run.

Note that if any of the commands specified in C<ExecStartPre>,
C<ExecStart>, or C<ExecStartPost> fail (and are not prefixed with
C<->, see above) or time out before the service is fully up, execution continues with commands
specified in C<ExecStopPost>, the commands in C<ExecStop> are skipped.

Note that the execution of C<ExecStartPost> is taken into account for the purpose of
C<Before>/C<After> ordering constraints. I< Optional. Type list of uniline.  > 

=head2 ExecStartPost

Additional commands that are executed before or after the command in
C<ExecStart>, respectively. Syntax is the same as for C<ExecStart>.
Multiple command lines are allowed, regardless of the service type (i.e. C<Type>),
and the commands are executed one after the other, serially.

If any of those commands (not prefixed with
C<->) fail, the rest are not executed and the
unit is considered failed.

C<ExecStart> commands are only run after
all C<ExecStartPre> commands that were not prefixed
with a C<-> exit successfully.

C<ExecStartPost> commands are only run after the commands specified in
C<ExecStart> have been invoked successfully, as determined by
C<Type> (i.e. the process has been started for C<Type=simple> or
C<Type=idle>, the last C<ExecStart> process exited successfully for
C<Type=oneshot>, the initial process exited successfully for
C<Type=forking>, C<READY=1> is sent for
C<Type=notify>/C<Type=notify-reload>, or the
C<BusName> has been taken for C<Type=dbus>).

Note that C<ExecStartPre> may not be
used to start long-running processes. All processes forked
off by processes invoked via C<ExecStartPre> will
be killed before the next service process is run.

Note that if any of the commands specified in C<ExecStartPre>,
C<ExecStart>, or C<ExecStartPost> fail (and are not prefixed with
C<->, see above) or time out before the service is fully up, execution continues with commands
specified in C<ExecStopPost>, the commands in C<ExecStop> are skipped.

Note that the execution of C<ExecStartPost> is taken into account for the purpose of
C<Before>/C<After> ordering constraints. I< Optional. Type list of uniline.  > 

=head2 ExecCondition

Optional commands that are executed before the commands in
C<ExecStartPre>. Syntax is the same as for C<ExecStart>. Multiple
command lines are allowed, regardless of the service type (i.e. C<Type>), and the
commands are executed one after the other, serially.

The behavior is like an C<ExecStartPre> and condition check hybrid: when an
C<ExecCondition> command exits with exit code 1 through 254 (inclusive), the remaining
commands are skipped and the unit is not marked as failed. However, if an
C<ExecCondition> command exits with 255 or abnormally (e.g. timeout, killed by a
signal, etc.), the unit will be considered failed (and remaining commands will be skipped). Exit code of 0 or
those matching C<SuccessExitStatus> will continue execution to the next commands.

The same recommendations about not running long-running processes in C<ExecStartPre>
also applies to C<ExecCondition>. C<ExecCondition> will also run the commands
in C<ExecStopPost>, as part of stopping the service, in the case of any non-zero or abnormal
exits, like the ones described above. I< Optional. Type list of uniline.  > 

=head2 ExecReload

Commands to execute to trigger a configuration reload in the service. This argument
takes multiple command lines, following the same scheme as described for
C<ExecStart> above. Use of this setting is optional. Specifier and environment
variable substitution is supported here following the same scheme as for
C<ExecStart>.

One additional, special environment variable is set: if known, C<$MAINPID> is
set to the main process of the daemon, and may be used for command lines like the following:

    ExecReload=kill -HUP $MAINPID

Note however that reloading a daemon by enqueuing a signal (as with the example line above) is
usually not a good choice, because this is an asynchronous operation and hence not suitable when
ordering reloads of multiple services against each other. It is thus strongly recommended to either
use C<Type>=C<notify-reload> in place of
C<ExecReload>, or to set C<ExecReload> to a command that not only
triggers a configuration reload of the daemon, but also synchronously waits for it to complete. For
example, L<dbus-broker(1)>
uses the following:

    ExecReload=busctl call org.freedesktop.DBus \
    /org/freedesktop/DBus org.freedesktop.DBus \
    ReloadConfig
. I< Optional. Type list of uniline.  > 

=head2 ExecStop

Commands to execute to stop the service started via
C<ExecStart>. This argument takes multiple command lines, following the same scheme
as described for C<ExecStart> above. Use of this setting is optional. After the
commands configured in this option are run, it is implied that the service is stopped, and any
processes remaining for it are terminated according to the C<KillMode> setting (see
L<systemd.kill(5)>).
If this option is not specified, the process is terminated by sending the signal specified in
C<KillSignal> or C<RestartKillSignal> when service stop is
requested. Specifier and environment variable substitution is supported (including
C<$MAINPID>, see above).

Note that it is usually not sufficient to specify a command for this setting that only asks the
service to terminate (for example, by sending some form of termination signal to it), but does not
wait for it to do so. Since the remaining processes of the services are killed according to
C<KillMode> and C<KillSignal> or
C<RestartKillSignal> as described above immediately after the command exited, this
may not result in a clean stop. The specified command should hence be a synchronous operation, not an
asynchronous one.

Note that the commands specified in C<ExecStop> are only executed when the service
started successfully first. They are not invoked if the service was never started at all, or in case its
start-up failed, for example because any of the commands specified in C<ExecStart>,
C<ExecStartPre> or C<ExecStartPost> failed (and were not prefixed with
C<->, see above) or timed out. Use C<ExecStopPost> to invoke commands when a
service failed to start up correctly and is shut down again. Also note that the stop operation is always
performed if the service started successfully, even if the processes in the service terminated on their
own or were killed. The stop commands must be prepared to deal with that case. C<$MAINPID>
will be unset if systemd knows that the main process exited by the time the stop commands are called.

Service restart requests are implemented as stop operations followed by start operations. This
means that C<ExecStop> and C<ExecStopPost> are executed during a
service restart operation.

It is recommended to use this setting for commands that communicate with the service requesting
clean termination. For post-mortem clean-up steps use C<ExecStopPost> instead.
I< Optional. Type list of uniline.  > 

=head2 ExecStopPost

Additional commands that are executed after the service is stopped. This includes cases where
the commands configured in C<ExecStop> were used, where the service does not have any
C<ExecStop> defined, or where the service exited unexpectedly. This argument takes multiple
command lines, following the same scheme as described for C<ExecStart>. Use of these settings
is optional. Specifier and environment variable substitution is supported. Note that – unlike
C<ExecStop> – commands specified with this setting are invoked when a service failed to start
up correctly and is shut down again.

It is recommended to use this setting for clean-up operations that shall be executed even when
the service failed to start up correctly. Commands configured with this setting need to be able to
operate even if the service failed starting up half-way and left incompletely initialized data
around. As the service's processes have likely exited already when the commands specified with this
setting are executed they should not attempt to communicate with them.

Note that all commands that are configured with this setting are invoked with the result code of the
service, as well as the main process' exit code and status, set in the C<$SERVICE_RESULT>,
C<$EXIT_CODE> and C<$EXIT_STATUS> environment variables, see
L<systemd.exec(5)> for
details.

Note that the execution of C<ExecStopPost> is taken into account for the purpose of
C<Before>/C<After> ordering constraints. I< Optional. Type list of uniline.  > 

=head2 RestartSec

Configures the time to sleep before restarting
a service (as configured with C<Restart>).
Takes a unit-less value in seconds, or a time span value such
as "5min 20s". Defaults to 100ms. I< Optional. Type uniline.  > 

=head2 RestartSteps

Configures the number of steps to take to increase the interval
of auto-restarts from C<RestartSec> to C<RestartMaxDelaySec>.
Takes a positive integer or 0 to disable it. Defaults to 0.

This setting is effective only if C<RestartMaxDelaySec> is also set. I< Optional. Type uniline.  > 

=head2 RestartMaxDelaySec

Configures the longest time to sleep before restarting a service
as the interval goes up with C<RestartSteps>. Takes a value
in the same format as C<RestartSec>, or C<infinity>
to disable the setting. Defaults to C<infinity>.

This setting is effective only if C<RestartSteps> is also set. I< Optional. Type uniline.  > 

=head2 TimeoutStartSec

Configures the time to wait for start-up. If a daemon service does not signal
start-up completion within the configured time, the service will be considered failed and will be
shut down again. The precise action depends on the C<TimeoutStartFailureMode>
option. Takes a unit-less value in seconds, or a time span value such as "5min 20s". Pass
C<infinity> to disable the timeout logic. Defaults to
C<DefaultTimeoutStartSec> set in the manager, except when
C<Type=oneshot> is used, in which case the timeout is disabled by default (see
L<systemd-system.conf(5)>).

If a service of C<Type=notify>/C<Type=notify-reload> sends
C<EXTEND_TIMEOUT_USEC=…>, this may cause the start time to be extended beyond
C<TimeoutStartSec>. The first receipt of this message must occur before
C<TimeoutStartSec> is exceeded, and once the start time has extended beyond
C<TimeoutStartSec>, the service manager will allow the service to continue to start,
provided the service repeats C<EXTEND_TIMEOUT_USEC=…> within the interval specified
until the service startup status is finished by C<READY=1>. (see
L<sd_notify(3)>).

Note that the start timeout is also applied to service reloads, regardless of whether implemented
through C<ExecReload> or via the reload logic enabled via C<Type=notify-reload>.
If the reload does not complete within the configured time, the reload will be considered failed and
the service will continue running with the old configuration. This will not affect the running service,
but will be logged and will cause e.g. systemctl reload to fail. I< Optional. Type uniline.  > 

=head2 TimeoutStopSec

This option serves two purposes. First, it configures the time to wait for each
C<ExecStop> command. If any of them times out, subsequent C<ExecStop> commands
are skipped and the service will be terminated by C<SIGTERM>. If no C<ExecStop>
commands are specified, the service gets the C<SIGTERM> immediately. This default behavior
can be changed by the C<TimeoutStopFailureMode> option. Second, it configures the time
to wait for the service itself to stop. If it does not terminate in the specified time, it will be forcibly terminated
by C<SIGKILL> (see C<KillMode> in
L<systemd.kill(5)>).
Takes a unit-less value in seconds, or a time span value such
as "5min 20s". Pass C<infinity> to disable the
timeout logic. Defaults to
C<DefaultTimeoutStopSec> from the manager
configuration file (see
L<systemd-system.conf(5)>).

If a service of C<Type=notify>/C<Type=notify-reload> sends
C<EXTEND_TIMEOUT_USEC=…>, this may cause the stop time to be extended beyond
C<TimeoutStopSec>. The first receipt of this message must occur before
C<TimeoutStopSec> is exceeded, and once the stop time has extended beyond
C<TimeoutStopSec>, the service manager will allow the service to continue to stop,
provided the service repeats C<EXTEND_TIMEOUT_USEC=…> within the interval specified,
or terminates itself (see
L<sd_notify(3)>).
I< Optional. Type uniline.  > 

=head2 TimeoutAbortSec

This option configures the time to wait for the service to terminate when it was aborted due to a
watchdog timeout (see C<WatchdogSec>). If the service has a short C<TimeoutStopSec>
this option can be used to give the system more time to write a core dump of the service. Upon expiration the service
will be forcibly terminated by C<SIGKILL> (see C<KillMode> in
L<systemd.kill(5)>). The core file will
be truncated in this case. Use C<TimeoutAbortSec> to set a sensible timeout for the core dumping per
service that is large enough to write all expected data while also being short enough to handle the service failure
in due time.

Takes a unit-less value in seconds, or a time span value such as "5min 20s". Pass an empty value to skip
the dedicated watchdog abort timeout handling and fall back C<TimeoutStopSec>. Pass
C<infinity> to disable the timeout logic. Defaults to C<DefaultTimeoutAbortSec> from
the manager configuration file (see
L<systemd-system.conf(5)>).

If a service of C<Type=notify>/C<Type=notify-reload> handles
C<SIGABRT> itself (instead of relying on the kernel to write a core dump) it can
send C<EXTEND_TIMEOUT_USEC=…> to extended the abort time beyond
C<TimeoutAbortSec>. The first receipt of this message must occur before
C<TimeoutAbortSec> is exceeded, and once the abort time has extended beyond
C<TimeoutAbortSec>, the service manager will allow the service to continue to abort,
provided the service repeats C<EXTEND_TIMEOUT_USEC=…> within the interval specified,
or terminates itself (see
L<sd_notify(3)>).
I< Optional. Type uniline.  > 

=head2 TimeoutSec

A shorthand for configuring both
C<TimeoutStartSec> and
C<TimeoutStopSec> to the specified value.
I< Optional. Type uniline.  > 

=head2 TimeoutStartFailureMode

These options configure the action that is taken in case a daemon service does not signal
start-up within its configured C<TimeoutStartSec>, respectively if it does not stop within
C<TimeoutStopSec>. Takes one of C<terminate>, C<abort> and
C<kill>. Both options default to C<terminate>.

If C<terminate> is set the service will be gracefully terminated by sending the signal
specified in C<KillSignal> (defaults to C<SIGTERM>, see
L<systemd.kill(5)>). If the
service does not terminate the C<FinalKillSignal> is sent after
C<TimeoutStopSec>. If C<abort> is set, C<WatchdogSignal> is sent
instead and C<TimeoutAbortSec> applies before sending C<FinalKillSignal>.
This setting may be used to analyze services that fail to start-up or shut-down intermittently.
By using C<kill> the service is immediately terminated by sending
C<FinalKillSignal> without any further timeout. This setting can be used to expedite the
shutdown of failing services.
I< Optional. Type enum. choice: 'abort', 'kill', 'terminate'.  > 

=head2 TimeoutStopFailureMode

These options configure the action that is taken in case a daemon service does not signal
start-up within its configured C<TimeoutStartSec>, respectively if it does not stop within
C<TimeoutStopSec>. Takes one of C<terminate>, C<abort> and
C<kill>. Both options default to C<terminate>.

If C<terminate> is set the service will be gracefully terminated by sending the signal
specified in C<KillSignal> (defaults to C<SIGTERM>, see
L<systemd.kill(5)>). If the
service does not terminate the C<FinalKillSignal> is sent after
C<TimeoutStopSec>. If C<abort> is set, C<WatchdogSignal> is sent
instead and C<TimeoutAbortSec> applies before sending C<FinalKillSignal>.
This setting may be used to analyze services that fail to start-up or shut-down intermittently.
By using C<kill> the service is immediately terminated by sending
C<FinalKillSignal> without any further timeout. This setting can be used to expedite the
shutdown of failing services.
I< Optional. Type enum. choice: 'abort', 'kill', 'terminate'.  > 

=head2 RuntimeMaxSec

Configures a maximum time for the service to run. If this is used and the service has been
active for longer than the specified time it is terminated and put into a failure state. Note that this setting
does not have any effect on C<Type=oneshot> services, as they terminate immediately after
activation completed (use C<TimeoutStartSec> to limit their activation).
Pass C<infinity> (the default) to configure no runtime limit.

If a service of C<Type=notify>/C<Type=notify-reload> sends
C<EXTEND_TIMEOUT_USEC=…>, this may cause the runtime to be extended beyond
C<RuntimeMaxSec>. The first receipt of this message must occur before
C<RuntimeMaxSec> is exceeded, and once the runtime has extended beyond
C<RuntimeMaxSec>, the service manager will allow the service to continue to run,
provided the service repeats C<EXTEND_TIMEOUT_USEC=…> within the interval specified
until the service shutdown is achieved by C<STOPPING=1> (or termination). (see
L<sd_notify(3)>).
I< Optional. Type uniline.  > 

=head2 RuntimeRandomizedExtraSec

This option modifies C<RuntimeMaxSec> by increasing the maximum runtime by an
evenly distributed duration between 0 and the specified value (in seconds). If C<RuntimeMaxSec> is
unspecified, then this feature will be disabled.
I< Optional. Type uniline.  > 

=head2 WatchdogSec

Configures the watchdog timeout for a service.
The watchdog is activated when the start-up is completed. The
service must call
L<sd_notify(3)>
regularly with C<WATCHDOG=1> (i.e. the
"keep-alive ping"). If the time between two such calls is
larger than the configured time, then the service is placed in
a failed state and it will be terminated with
C<SIGABRT> (or the signal specified by
C<WatchdogSignal>). By setting
C<Restart> to C<on-failure>,
C<on-watchdog>, C<on-abnormal> or
C<always>, the service will be automatically
restarted. The time configured here will be passed to the
executed service process in the
C<WATCHDOG_USEC> environment variable. This
allows daemons to automatically enable the keep-alive pinging
logic if watchdog support is enabled for the service. If this
option is used, C<NotifyAccess> (see below)
should be set to open access to the notification socket
provided by systemd. If C<NotifyAccess> is
not set, it will be implicitly set to C<main>.
Defaults to 0, which disables this feature. The service can
check whether the service manager expects watchdog keep-alive
notifications. See
L<sd_watchdog_enabled(3)>
for details.
L<sd_event_set_watchdog(3)>
may be used to enable automatic watchdog notification support.
I< Optional. Type uniline.  > 

=head2 Restart

Configures whether the service shall be restarted when the service process exits,
is killed, or a timeout is reached. The service process may be the main service process, but it may
also be one of the processes specified with C<ExecStartPre>,
C<ExecStartPost>, C<ExecStop>, C<ExecStopPost>,
or C<ExecReload>. When the death of the process is a result of systemd operation
(e.g. service stop or restart), the service will not be restarted. Timeouts include missing the watchdog
"keep-alive ping" deadline and a service start, reload, and stop operation timeouts.

Takes one of C<no>, C<on-success>, C<on-failure>,
C<on-abnormal>, C<on-watchdog>, C<on-abort>, or
C<always>. If set to C<no> (the default), the service will not be restarted.
If set to C<on-success>, it will be restarted only when the service process exits cleanly.
In this context, a clean exit means any of the following:
exit code of 0;for types other than C<Type=oneshot>, one of the signals
C<SIGHUP>, C<SIGINT>,
C<SIGTERM>, or C<SIGPIPE>;
exit statuses and signals specified in
C<SuccessExitStatus>.
If set to C<on-failure>, the service will be restarted when the process exits with
a non-zero exit code, is terminated by a signal (including on core dump, but excluding the aforementioned
four signals), when an operation (such as service reload) times out, and when the configured watchdog
timeout is triggered. If set to C<on-abnormal>, the service will be restarted when
the process is terminated by a signal (including on core dump, excluding the aforementioned four signals),
when an operation times out, or when the watchdog timeout is triggered. If set to C<on-abort>,
the service will be restarted only if the service process exits due to an uncaught signal not specified
as a clean exit status. If set to C<on-watchdog>, the service will be restarted
only if the watchdog timeout for the service expires. If set to C<always>, the service
will be restarted regardless of whether it exited cleanly or not, got terminated abnormally by
a signal, or hit a timeout. Note that C<Type=oneshot> services will never be restarted
on a clean exit status, i.e. C<always> and C<on-success> are rejected
for them.

As exceptions to the setting above, the service will not
be restarted if the exit code or signal is specified in
C<RestartPreventExitStatus> (see below) or
the service is stopped with systemctl stop
or an equivalent operation. Also, the services will always be
restarted if the exit code or signal is specified in
C<RestartForceExitStatus> (see below).

Note that service restart is subject to unit start rate
limiting configured with C<StartLimitIntervalSec>
and C<StartLimitBurst>, see
L<systemd.unit(5)>
for details.

Setting this to C<on-failure> is the
recommended choice for long-running services, in order to
increase reliability by attempting automatic recovery from
errors. For services that shall be able to terminate on their
own choice (and avoid immediate restarting),
C<on-abnormal> is an alternative choice. I< Optional. Type enum. choice: 'always', 'no', 'on-abnormal', 'on-abort', 'on-failure', 'on-success', 'on-watchdog'.  > 

=head2 RestartMode

Takes a string value that specifies how a service should restart:
If set to C<normal> (the default), the service restarts by going through
a failed/inactive state.If set to C<direct>, the service transitions to the activating
state directly during auto-restart, skipping failed/inactive state.
C<ExecStopPost> is still invoked.
C<OnSuccess> and C<OnFailure> are skipped.This option is useful in cases where a dependency can fail temporarily but we
do not
want these temporary failures to make the dependent units fail. Dependent units are not
notified of these temporary failures.If set to C<debug>, the service manager will log messages that are
related to this unit at debug level while automated restarts are attempted, until either the
service hits the rate limit or it succeeds, and the C<$DEBUG_INVOCATION=1>
environment variable will be set for the unit. This is useful to be able to get additional
information when a service fails to start, without needing to proactively or permanently
enable debug level logging in systemd, which is very verbose. This is otherwise equivalent
to C<normal> mode. I< Optional. Type uniline.  > 

=head2 SuccessExitStatus

Takes a list of exit status definitions that, when returned by the main service
process, will be considered successful termination, in addition to the normal successful exit status
0 and, except for C<Type=oneshot>, the signals C<SIGHUP>, C<SIGINT>,
C<SIGTERM>, and C<SIGPIPE>. Exit status definitions can be
numeric termination statuses, termination status names, or termination signal names, separated by
spaces. See the Process Exit Codes section in
L<systemd.exec(5)> for
a list of termination status names (for this setting only the part without the
C<EXIT_> or C<EX_> prefix should be used). See L<signal(7)> for
a list of signal names.

Note that this setting does not change the mapping between numeric exit statuses and their
names, i.e. regardless how this setting is used 0 will still be mapped to C<SUCCESS>
(and thus typically shown as C<0/SUCCESS> in tool outputs) and 1 to
C<FAILURE> (and thus typically shown as C<1/FAILURE>), and so on. It
only controls what happens as effect of these exit statuses, and how it propagates to the state of
the service as a whole.

This option may appear more than once, in which case the list of successful exit statuses is
merged. If the empty string is assigned to this option, the list is reset, all prior assignments of
this option will have no effect.

Note: systemd-analyze exit-status may be used to list exit statuses and
translate between numerical status values and names. I< Optional. Type uniline.  > 

=head2 RestartPreventExitStatus

Takes a list of exit status definitions that, when returned by the main service
process, will prevent automatic service restarts, regardless of the restart setting configured with
C<Restart>. Exit status definitions can be numeric termination statuses, termination
status names, or termination signal names, separated by spaces. Defaults to the empty list, so that,
by default, no exit status is excluded from the configured restart logic.
A service with the C<RestartPreventExitStatus> setting
    RestartPreventExitStatus=TEMPFAIL 250 SIGKILL
Exit status 75 (C<TEMPFAIL>), 250, and the termination signal
C<SIGKILL> will not result in automatic service restarting.
This option may appear more than once, in which case the list of restart-preventing statuses is merged.
If the empty string is assigned to this option, the list is reset and all prior assignments of this
option will have no effect.

Note that this setting has no effect on processes configured via
C<ExecStartPre>, C<ExecStartPost>, C<ExecStop>,
C<ExecStopPost> or C<ExecReload>, but only on the main service
process, i.e. either the one invoked by C<ExecStart> or (depending on
C<Type>, C<PIDFile>, …) the otherwise configured main
process. I< Optional. Type uniline.  > 

=head2 RestartForceExitStatus

Takes a list of exit status definitions that, when returned by the main service
process, will force automatic service restarts, regardless of the restart setting configured with
C<Restart>. The argument format is similar to C<RestartPreventExitStatus>.

Note that for C<Type=oneshot> services, a success exit status will prevent
them from auto-restarting, no matter whether the corresponding exit statuses are listed in this
option or not. I< Optional. Type uniline.  > 

=head2 RootDirectoryStartOnly

Takes a boolean argument. If true, the root
directory, as configured with the
C<RootDirectory> option (see
L<systemd.exec(5)>
for more information), is only applied to the process started
with C<ExecStart>, and not to the various
other C<ExecStartPre>,
C<ExecStartPost>,
C<ExecReload>, C<ExecStop>,
and C<ExecStopPost> commands. If false, the
setting is applied to all configured commands the same way.
Defaults to false. I< Optional. Type boolean.  > 

=over 4

=item upstream_default value :

no

=back



=head2 NonBlocking

Set the C<O_NONBLOCK> flag for all file descriptors passed via
socket-based activation. If true, all file descriptors >= 3 (i.e. all except stdin, stdout, stderr),
excluding those passed in via the file descriptor storage logic (see
C<FileDescriptorStoreMax> for details), will have the
C<O_NONBLOCK> flag set and hence are in non-blocking mode. This option is only
useful in conjunction with a socket unit, as described in
L<systemd.socket(5)>
and has no effect on file descriptors which were previously saved in the file-descriptor store for
example.  Defaults to false.

Note that if the same socket unit is configured to be passed to multiple service units (via the
C<Sockets> setting, see below), and these services have different
C<NonBlocking> configurations, the precise state of C<O_NONBLOCK>
depends on the order in which these services are invoked, and will possibly change after service code
already took possession of the socket file descriptor, simply because the
C<O_NONBLOCK> state of a socket is shared by all file descriptors referencing
it. Hence it is essential that all services sharing the same socket use the same
C<NonBlocking> configuration, and do not change the flag in service code
either. I< Optional. Type uniline.  > 

=head2 NotifyAccess

Controls access to the service status notification socket, as accessible via the
L<sd_notify(3)>
call. Takes one of C<none> (the default), C<main>, C<exec>
or C<all>. If C<none>, no daemon status updates are accepted from the
service processes, all status update messages are ignored. If C<main>, only service
updates sent from the main process of the service are accepted. If C<exec>, only
service updates sent from any of the main or control processes originating from one of the
C<Exec*=> commands are accepted. If C<all>, all services updates from
all members of the service's control group are accepted. This option should be set to open access to
the notification socket when using
C<Type=notify>/C<Type=notify-reload> or
C<WatchdogSec> (see above). If those options are used but
C<NotifyAccess> is not configured, it will be implicitly set to
C<main>.

Note that sd_notify() notifications may be attributed to units correctly only if
either the sending process is still around at the time PID 1 processes the message, or if the sending process
is explicitly runtime-tracked by the service manager. The latter is the case if the service manager originally
forked off the process, i.e. on all processes that match C<main> or
C<exec>. Conversely, if an auxiliary process of the unit sends an
sd_notify() message and immediately exits, the service manager might not be able to
properly attribute the message to the unit, and thus will ignore it, even if
C<NotifyAccess>=C<all> is set for it.

Hence, to eliminate all race conditions involving lookup of the client's unit and attribution of notifications
to units correctly, sd_notify_barrier() may be used. This call acts as a synchronization point
and ensures all notifications sent before this call have been picked up by the service manager when it returns
successfully. Use of sd_notify_barrier() is needed for clients which are not invoked by the
service manager, otherwise this synchronization mechanism is unnecessary for attribution of notifications to the
unit. I< Optional. Type enum. choice: 'all', 'exec', 'main', 'none'.  > 

=head2 Sockets

Specifies the name of the socket units this
service shall inherit socket file descriptors from when the
service is started. Normally, it should not be necessary to use
this setting, as all socket file descriptors whose unit shares
the same name as the service (subject to the different unit
name suffix of course) are passed to the spawned
process.

Note that the same socket file descriptors may be passed
to multiple processes simultaneously. Also note that a
different service may be activated on incoming socket traffic
than the one which is ultimately configured to inherit the
socket file descriptors. Or, in other words: the
C<Service> setting of
C<.socket> units does not have to match the
inverse of the C<Sockets> setting of the
C<.service> it refers to.

This option may appear more than once, in which case the list of socket units is merged. Note
that once set, clearing the list of sockets again (for example, by assigning the empty string to this
option) is not supported. I< Optional. Type uniline.  > 

=head2 FileDescriptorStoreMax

Configure how many file descriptors may be stored in the service manager for the
service using
L<sd_pid_notify_with_fds(3)>'s
C<FDSTORE=1> messages. This is useful for implementing services that can restart
after an explicit request or a crash without losing state. Any open sockets and other file
descriptors which should not be closed during the restart may be stored this way. Application state
can either be serialized to a file in C<RuntimeDirectory>, or stored in a
L<memfd_create(2)>
memory file descriptor. Defaults to 0, i.e. no file descriptors may be stored in the service
manager. All file descriptors passed to the service manager from a specific service are passed back
to the service's main process on the next service restart (see
L<sd_listen_fds(3)> for
details about the precise protocol used and the order in which the file descriptors are passed). Any
file descriptors passed to the service manager are automatically closed when
C<POLLHUP> or C<POLLERR> is seen on them, or when the service is
fully stopped and no job is queued or being executed for it (the latter can be tweaked with
C<FileDescriptorStorePreserve>, see below). If this option is used,
C<NotifyAccess> (see above) should be set to open access to the notification socket
provided by systemd. If C<NotifyAccess> is not set, it will be implicitly set to
C<main>.

The fdstore command of
L<systemd-analyze(1)>
may be used to list the current contents of a service's file descriptor store.

Note that the service manager will only pass file descriptors contained in the file descriptor
store to the service's own processes, never to other clients via IPC or similar. However, it does
allow unprivileged clients to query the list of currently open file descriptors of a
service. Sensitive data may hence be safely placed inside the referenced files, but should not be
attached to the metadata (e.g. included in filenames) of the stored file
descriptors.

If this option is set to a non-zero value the C<$FDSTORE> environment variable
will be set for processes invoked for this service. See
L<systemd.exec(5)> for
details.

For further information on the file descriptor store see the L<File Descriptor
Store|https://systemd.io/FILE_DESCRIPTOR_STORE> overview. I< Optional. Type uniline.  > 

=head2 FileDescriptorStorePreserve

Takes one of C<no>, C<yes>,
C<restart> and controls when to release the service's file descriptor store
(i.e. when to close the contained file descriptors, if any). If set to C<no> the
file descriptor store is automatically released when the service is stopped; if
C<restart> (the default) it is kept around as long as the unit is neither inactive
nor failed, or a job is queued for the service, or the service is expected to be restarted. If
C<yes> the file descriptor store is kept around until the unit is removed from
memory (i.e. is not referenced anymore and inactive). The latter is useful to keep entries in the
file descriptor store pinned until the service manager exits.

Use systemctl clean --what=fdstore … to release the file descriptor store
explicitly. I< Optional. Type enum. choice: 'no', 'restart', 'yes'.  > 

=head2 USBFunctionDescriptors

Configure the location of a file containing
L<USB
FunctionFS|https://docs.kernel.org/usb/functionfs.html> descriptors, for implementation of USB
gadget functions. This is used only in conjunction with a
socket unit with C<ListenUSBFunction>
configured. The contents of this file are written to the
C<ep0> file after it is
opened. I< Optional. Type uniline.  > 

=head2 USBFunctionStrings

Configure the location of a file containing
USB FunctionFS strings.  Behavior is similar to
C<USBFunctionDescriptors>
above. I< Optional. Type uniline.  > 

=head2 OOMPolicy

Configure the out-of-memory (OOM) killing policy for the kernel and the userspace OOM
killer
L<systemd-oomd.service(8)>.
On Linux, when memory becomes scarce to the point that the kernel has trouble allocating memory for
itself, it might decide to kill a running process in order to free up memory and reduce memory
pressure. Note that C<systemd-oomd.service> is a more flexible solution that aims
to prevent out-of-memory situations for the userspace too, not just the kernel, by attempting to
terminate services earlier, before the kernel would have to act.

This setting takes one of C<continue>, C<stop> or
C<kill>. If set to C<continue> and a process in the unit is
killed by the OOM killer, this is logged but the unit continues running. If set to
C<stop> the event is logged but the unit is terminated cleanly by the service
manager. If set to C<kill> and one of the unit's processes is killed by the OOM
killer the kernel is instructed to kill all remaining processes of the unit too, by setting the
C<memory.oom.group> attribute to C<1>; also see kernel
page L<Control Group v2|https://docs.kernel.org/admin-guide/cgroup-v2.html>.

Defaults to the setting C<DefaultOOMPolicy> in
L<systemd-system.conf(5)>
is set to, except for units where C<Delegate> is turned on, where it defaults to
C<continue>.

Use the C<OOMScoreAdjust> setting to configure whether processes of the unit
shall be considered preferred or less preferred candidates for process termination by the Linux OOM
killer logic. See
L<systemd.exec(5)> for
details.

This setting also applies to
L<systemd-oomd.service(8)>.
Similarly to the kernel OOM kills performed by the kernel, this setting determines the state of the
unit after systemd-oomd kills a cgroup associated with it. I< Optional. Type uniline.  > 

=head2 OpenFile

Takes an argument of the form C<path:fd-name:options>,
where:
C<path> is a path to a file or an C<AF_UNIX> socket in the file system;C<fd-name> is a name that will be associated
with the file descriptor;
the name may contain any ASCII character, but must exclude control characters and ":", and must be at most 255
characters in length;
it is optional and, if not provided, defaults to the file name;C<options> is a comma-separated list of access options;
possible values are
C<read-only>,
C<append>,
C<truncate>,
C<graceful>;
if not specified, files will be opened in C<rw> mode;
if C<graceful> is specified, errors during file/socket opening are ignored.
Specifying the same option several times is treated as an error.
The file or socket is opened by the service manager and the file descriptor is passed to the service.
If the path is a socket, we call connect() on it.
See L<sd_listen_fds(3)>
for more details on how to retrieve these file descriptors.

This setting is useful to allow services to access files/sockets that they cannot access themselves
(due to running in a separate mount namespace, not having privileges, ...).

This setting can be specified multiple times, in which case all the specified paths are opened and the file descriptors
passed to the service.
If the empty string is assigned, the entire list of open files defined prior to this is reset. I< Optional. Type uniline.  > 

=head2 ReloadSignal

Configures the UNIX process signal to send to the service's main process when asked
to reload the service's configuration. Defaults to C<SIGHUP>. This option has no
effect unless C<Type>=C<notify-reload> is used, see
above. I< Optional. Type uniline.  > 

=head2 FailureAction

B<Deprecated> I< Optional. Type uniline.  > 

=head2 SuccessAction

B<Deprecated> I< Optional. Type uniline.  > 

=head2 StartLimitBurst

B<Deprecated> I< Optional. Type uniline.  > 

=head2 StartLimitInterval

B<Deprecated> I< Optional. Type uniline.  > 

=head2 RebootArgument

B<Deprecated> I< Optional. Type uniline.  > 

=head1 SEE ALSO

=over

=item *

L<cme>

=back

=head1 COPYRIGHT

=over

=item 2010-2016 Lennart Poettering and others

=item 2016 Dominique Dumont


=back

=head1 LICENSE

=over

=item LGPLv2.1+


=back

=cut

