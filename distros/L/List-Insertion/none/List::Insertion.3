.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "List::Insertion 3"
.TH List::Insertion 3 "2023-03-26" "perl v5.36.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
List::Insertion \- Binary search a list for insertion point
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Export a subroutine to locate the index of the first instance (left) of value
in a sorted simple scalar list:
.PP
.Vb 3
\&  # Exports \*(Aqsearch_numeric_left\*(Aq only
\&  #
\&  use List::Insertion {type=>"numeric", duplicate=>"left"};
\&
\&  # Data has value 30 duplcated
\&
\&  my @data=(10, 20, 30, 30, 40, 50, 60, 70);
\&  #index    0   1   2   3   4   5   6   7
\&
\&  # The insert position will be index 2, which is left of duplicates
\&  #
\&  my $key= 30;
\&  my $pos=search_numeric_left $key, \e@data;
\&
\&  if($data[$pos] == $key){
\&    # Exact match, $pos is the index of the searched $key in the array (left)
\&  }
\&  else{
\&    # $pos is the index where $key should be inserted
\&  }
.Ve
.PP
Same as above with string comparison:
.PP
.Vb 1
\&  use List::Insertion {type=>"string", duplicate=>"left"};
\&
\&  my @data=qw<10 20 30 30 40 50 60 70>;
\&  #index      0  1  2  3  4  5  6  7
\&
\&  my $key= "30";
\&  my $pos=search_string_left $key, \e@data;
\&
\&  if($data[$pos] eq $key){
\&  }
\&  else{
\&  }
.Ve
.PP
Export a subroutine to search for insertion point, of array of hashes, right of
duplicates, with accessor to comparison value:
.PP
.Vb 11
\&  # Data has value=>3 duplcated. Elements are hash refs so use an accessor snippet
\&  #
\&  use List::Insertion {type=>"numeric", duplicate=>"right", accessor=>\*(Aq\->{value}\*(Aq};
\&  my @data=(
\&    {value=>1, other=>"a"},
\&    {value=>2, other=>"b"},
\&    {value=>3, other=>"c"},
\&    {value=>3, other=>"d"},
\&    {value=>4, other=>"e"},
\&    {value=>5, other=>"f"},
\&  );
\&
\&  # The insert position will be index 4, which is right of duplicates
\&  #
\&  my $key= 3;
\&  my $pos=search_numeric_right $key, \e@data;
.Ve
.PP
Export 'make_search' and create anonymous subroutine instead of injecting named
subroutines to name space
.PP
.Vb 1
\&  use List:::Insertion "make_search";
\&
\&  my @data=(1, 2, 3);
\&
\&  my $search=make_search type=>"numeric", duplicate=>"left";
\&  my $key=2;
\&  my $pos=$search\->($key, \e@data);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
List::Insertion implements binary search algorithms to locate the
\&\fBinsertion\fR point of a sorted list for a given value. If the value were to be
inserted at that position, the list would remain sorted.
.PP
A distinction is made between inserting left or right of an exact match or
duplicated entry. This allows to insert data before contiguous equal items or
after.
.PP
Performance rather than flexibility is favoured in the implementation and
necessitates the following restrictions on the data stored in the array/list
and how it's compared:
.IP "Data must be sorted in asscending order only" 4
.IX Item "Data must be sorted in asscending order only"
This simplifies the combinations of subroutines exported
.IP "No code blocks can be specified" 4
.IX Item "No code blocks can be specified"
While code blocks are very flexible, 90% of the functionality can be achieved
with 'accessor' snippets.
.IP "Element comparision is implicitly numerical or string" 4
.IX Item "Element comparision is implicitly numerical or string"
No object methods for comparison. Only basic \f(CW\*(C`<=>\*(C'\fR, \f(CW\*(C`>=\*(C'\fR, \f(CW\*(C`le\*(C'\fR
and \f(CW\*(C`ge\*(C'\fR operators are used for internally for string and numeric comparison.
.IP "List element must be homogeneous and defined" 4
.IX Item "List element must be homogeneous and defined"
All items in the list are expected to have the same data structure. The
structure  can be a simple scalar like a string or number, in which case no
\&'acceesor' snippet is used.
.Sp
On the other hand it could be complex, like an array of arrays or hashes of
objects to any level. The only restriction in this case is the 'accessor'
snippet is able to access the value for comparison via post dereferencing or
method calls
.PP
Although intended for searching for a insertion point, this module can also be
used for general searching of elements. A simple check of equality between the
search key and  value at the found index will determine if the value was
actually found or not.
.PP
The returned index will never indicate 'not found' as there is always a insert
location in a list.
.PP
No symbols are exported by default. Specifications given at import time are
used to generate and export the search routine (s) needed. Anonymous search
subroutines can also be generated.
.SH "PERFORMANCE"
.IX Header "PERFORMANCE"
.SS "General Binary Search Performance"
.IX Subsection "General Binary Search Performance"
Thanks to the lack of a \s-1CODE\s0 blocks and more streamlined comparison, this
module is on par with List::BinarySearch::XS for at least one level of
structured data. Not bad for pure perl.
.PP
Please see the associated benchmarking script \fIbench.pl\fR in this distribution:
.PP
.Vb 4
\&  Results for searching an array with 1000 random numeric elements stored in a
\&  key/value hash. The keys searched are also randomly generated and may not
\&  existing inthe sorted list. Comparision between List::BinarySearch::PP,
\&  List::BinarySearch::XS, and List::Insertion
\&
\&               Rate L::BS::PP      L::I L::BS::XS
\&  L::BS::PP 14902/s        \-\-      \-80%      \-81%
\&  L::I      74796/s      402%        \-\-       \-6%
\&  L::BS::XS 79644/s      434%        6%        \-\-
.Ve
.SS "Building/Updating an Already Sorted List"
.IX Subsection "Building/Updating an Already Sorted List"
Perl is pretty fast when sorting bulk array data in a single sort call. However
adding a single new value and resorting an existing array is not nearly as
fast.
.PP
Normally to update an already sorted array with a new value, you would push the
new value to the array and resort. This module can improve performance by first
locating the insert point at which you would splice in the new value. For
example:
.PP
.Vb 1
\&  eg.
\&    
\&    my @data= map rand(10), 1..1000; 
\&
\&    my $key=4.3;
\&
\&    # Instead of this ...
\&    #
\&    my @perl_sort;
\&    push @perl_sort, $key;
\&    @perl_sort=sort {$a <=> $b} @perl_sort;
\&
\&    # Do this ...
\&    #
\&    my @sorted;
\&    my $pos;
\&    if(@sort){
\&      $pos=search_numeric_left $key, \e@sorted;
\&      splice @sorted, $pos, 0, $key;
\&    }
\&    else {
\&      push @sorted, $key;
\&    }
.Ve
.PP
The benchmarking script \fIbuild\-sorted.pl\fR in this distribution demonstrates
building a list where each element is a key value pair (hash) storing a random
value.  This module is within approx 20% of the \s-1XS\s0 implementation of
List::BinarySearch::XS and is much faster than the pure perl
List::BinarySearch::PP.
.PP
.Vb 4
\&  Results for constructing/sorting an array with 1000 random numeric elements
\&  one element at a time. Each element is key/value hash.  Comparision between
\&  List::BinarySearch::PP, List::BinarySearch::XS, perl sort, and
\&  List::Insertion
\&
\&                     Rate perl_sort_update L_BS_PP_update L_I_update L_BS_XS_update
\&  perl_sort_update 25.5/s               \-\-           \-86%       \-97%           \-97%
\&  L_BS_PP_update    179/s             603%             \-\-       \-76%           \-81%
\&  L_I_update        760/s            2884%           325%         \-\-           \-18%
\&  L_BS_XS_update    922/s            3523%           416%        21%             \-\-
.Ve
.SH "API"
.IX Header "API"
.SS "Importing"
.IX Subsection "Importing"
When importing this module, the type of comparison (string or numeric) and the
behaviour in dealing with duplicate values (left or right) is specified along
with optional accessor and prefix options.
.PP
Combinations of these options are generated via \f(CW\*(C`Data::Combination\*(C'\fR, allowing
multiple subroutines to be configured and returned with minimal typing.
.PP
Consider the following examples:
.PP
.Vb 1
\&    use List::Insertion {type=>"numeric", position=>left};                #(1)
\&
\&    use List::Insertion {type=>"numeric", position=>["left", "right"]};   #(2)
\&
\&    use List::Insertion {                                               #(3)
\&      type=>"numeric", duplicate=>["left", "right"], accessor=>\*(Aq\->{hash_key}\*(Aq
\&    };
\&
\&    use List::Insertion {                                               #(4)
\&      type=>"numeric", duplicate=>["left", "right"], accessor=>\*(Aq\->{hash_key}\->method\*(Aq,
\&      prefix=>"find"};
.Ve
.IP "1." 4
Imports the subroutine \*(L"search_numeric_left\*(R"
.IP "2." 4
Imports the subroutines \*(L"search_numeric_left\*(R" and \*(L"search_numeric_right\*(R"
.IP "3." 4
Imports the subroutines \*(L"search_numeric_left\*(R" and \*(L"search_numeric_right\*(R" and
uses the accessor '\->{hash_key} when accessing elements. Elements must all be
hash references and the hash key will be compared in numeric fashion.
.IP "4." 4
Imports the subroutines \*(L"find_numeric_left\*(R" and \*(L"find_numeric_right\*(R" and uses
the accessor '\->{hash_key}\->method' when accessing elements. Elements must all
respond to 'method', with its return value compared in numeric fashion.
.PP
The default values of supported options are used if no matching options are
present in an import specification. The defaults are:
.PP
.Vb 4
\&  type=>"string",
\&  duplicate=>"left",
\&  accessor=>"",
\&  prefix=>"search"
.Ve
.PP
Supported options during importing include:
.PP
\fItype\fR
.IX Subsection "type"
.PP
.Vb 1
\&  type=>NAME or type=[NAME,...]
.Ve
.PP
A plain scalar or array ref of comparison type names. The type is implicitly
used as the second part of an exported subroutines name. Supported values for
\&\s-1NAME\s0
are:
.IP "numeric" 4
.IX Item "numeric"
Numerical comparison
.IP "string" 4
.IX Item "string"
String comparison
.PP
\fIduplicate\fR
.IX Subsection "duplicate"
.PP
.Vb 1
\&  duplicate=>SIDE  or pos=>[SIDE,...]
.Ve
.PP
A plain scalar or array ref of side names. The side to choose when duplicate
values are encountered. This is used implicitly as the last part of an exported
subroutines name.
.PP
Supported values for \s-1SIDE\s0 are:
.IP "left, lesser" 4
.IX Item "left, lesser"
Choose the lower index when the duplicate items are encountered.
.Sp
.Vb 4
\&  eg 
\&    my @list=( 10, 20, 20, 20, 30)
\&                  /\e
\&                  ||
\&
\&    A \*(Aqleft\*(Aq search for 20 will result in a index of 1
.Ve
.IP "right, greater" 4
.IX Item "right, greater"
Choose the greater index (after duplicates) when the duplicate items are
encountered.
.Sp
.Vb 5
\&  eg  
\&    my @list=( 10, 20, 20, 20, 30)
\&                              /\e
\&                              ||
\&    A \*(Aqright\*(Aq search for 20 will result in a index of 4
.Ve
.PP
\fIaccessor\fR
.IX Subsection "accessor"
.PP
.Vb 1
\&  accessor=>STRING
.Ve
.PP
A string consisting of perl post dereferencing/method call syntax, which is
used is to access internal levels of a element's data structure. Internally
this string is literally appending to the array element indexing code:
.PP
.Vb 3
\&  eg
\&    Acessor: \->{hash_ref}[array_deref]\->method
\&    Interal code: ... $array[$index] ...
\&
\&    Resulting code: ... $array[$index]\->{hash_ref}[array_deref]\->method ...
.Ve
.PP
If not specified, it is treated as an empty string, and elements in the list
are treated as numeric/string simple scalars. Their value are used directly in
comparisons in the search algorithm.
.PP
If specified, elements are dereferenced/called with the accessor. The resulting
value is used in the comparison in the search algorithm.
.PP
The value of the search key is \s-1NOT\s0 subject to the accessor and is used directly
in comparison.
.PP
\fIprefix\fR
.IX Subsection "prefix"
.PP
.Vb 1
\&  prefix=>STRING
.Ve
.PP
A string which becomes the start of the imported subroutines name. If
unspecified, the string \*(L"search\*(R" is used.
.PP
.Vb 2
\&  eg 
\&    use List::Insertion {prefix=>"my_searcher", ...};
\&
\&    # The subrotine imported will start with my_searcher
\&
\&    my $pos=my_searcher_...
.Ve
.SS "Anonymous Subroutines"
.IX Subsection "Anonymous Subroutines"
Instead of importing named subroutines into your namespace, anonymous
subroutines can be generated by importing the \f(CW\*(C`make_search\*(C'\fR subroutine:
.PP
.Vb 1
\&  use List::Insertion "make_search";
.Ve
.PP
\fImake_search\fR
.IX Subsection "make_search"
.PP
.Vb 1
\&  my $sub=make_search {options}
.Ve
.PP
Creates a search subroutine configured with a options hash ref. Each option is
a key value pair, as described in the \fBimporting\fR section. Only simple scalars
key/values are allowed, as only a single subroutine is returned per call.
Multiple calls to this subroutine will need to be used to generate multiple
search subroutines.
.PP
This is the subroutine called internally during import to generate the named
subroutines.
.PP
The option \fBprefix\fR has no effect as the routine is anonymous.
.SS "Using Generated or Exported subrotines"
.IX Subsection "Using Generated or Exported subrotines"
The generated/imported subroutines are named in the format:
.PP
.Vb 1
\&  prefix_type_duplicate
.Ve
.PP
where prefix, type and duplicate represent the prefix, data type ( string or
numeric) and duplicated entry handling (left or right) configuration
.PP
These routines are called with two arguments, the search key and reference to
the sorted data:
.PP
.Vb 1
\&    my $insert=find_nv_left $key, \e@data;
.Ve
.PP
The return value is the index in the \f(CW@data\fR, which if inserting \f(CW$key\fR will
keep the list sorted.
.PP
The value of the element located at \f(CW$insert\fR my be equal to the search key.
.PP
\&\fB\s-1NOTE:\s0\fR Search routines never return less then 0 or otherwise indicate
\&'element not found'. The index is always the point when data can be inserted.
So an empty list will always return a found index of 0, as this where an
element would be inserted.
.SH "FUTURE WORK"
.IX Header "FUTURE WORK"
.IP "Make an \s-1XS\s0 version" 4
.IX Item "Make an XS version"
That could be tricky with the accessor feature.
.IP "Validate accessor" 4
.IX Item "Validate accessor"
Add a 'validator' for testing/confirmation of accessor syntax
.SH "SEE ALSO"
.IX Header "SEE ALSO"
List::BinarySearch and the List::BinarySearch::PP(pure perl)  and
List::BinarySearch::XS (\s-1XS\s0 enhanced) 'sub modules' provide more flexibility
than this module thanks to the use of code blocks for element comparison.
.SH "REPOSITORY and BUG REPORTING"
.IX Header "REPOSITORY and BUG REPORTING"
Please report any bugs and feature requests on the repo page:
GitHub <http://github.com/drclaw1394/perl-list-insertion>
.SH "AUTHOR"
.IX Header "AUTHOR"
Ruben Westerberg, <drclaw@mac.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2023 by Ruben Westerberg
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, or under the \s-1MIT\s0 license
.SH "DISCLAIMER OF WARRANTIES"
.IX Header "DISCLAIMER OF WARRANTIES"
\&\s-1THIS PACKAGE IS PROVIDED \*(L"AS IS\*(R" AND WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS FOR A PARTICULAR PURPOSE.\s0
